<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>设计 on "地瓜哥"博客网</title><link>https://www.diguage.com/tags/%E8%AE%BE%E8%AE%A1/</link><description>Recent content in 设计 on "地瓜哥"博客网</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Tue, 08 Jul 2025 09:29:43 +0800</lastBuildDate><atom:link href="https://www.diguage.com/tags/%E8%AE%BE%E8%AE%A1/index.xml" rel="self" type="application/rss+xml"/><item><title>Spring Boot 启动流程概述</title><link>https://www.diguage.com/post/spring-boot-startup-process-overview/</link><pubDate>Tue, 08 Jul 2025 09:23:05 +0800</pubDate><guid>https://www.diguage.com/post/spring-boot-startup-process-overview/</guid><description>&lt;div class="paragraph">
&lt;p>在 &lt;a href="https://www.diguage.com/post/spring-startup-process-overview/" target="_blank" rel="noopener">Spring 启动流程概述&lt;/a> 中，D瓜哥简要介绍了一下 Spring 的启动流程概述。前段时间查看了一下 Spring Boot 的启动流程，画了个时序图，分享一下。&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/spring-boot/SpringApplication-run.svg" alt="Spring Boot 启动流程" width="95%"/>
&lt;/div>
&lt;div class="title">图 1. Spring Boot 启动流程&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>结合这张时序图，再加上 &lt;a href="https://www.diguage.com/post/spring-startup-process-overview/" target="_blank" rel="noopener">Spring 启动流程概述&lt;/a> 中的 Spring 启动时序图，就可以看到 Spring Boot 和 Spring 启动的全貌了。&lt;/p>
&lt;/div></description></item><item><title>Redis 核心数据结构（四）</title><link>https://www.diguage.com/post/redis-core-data-structure-4/</link><pubDate>Tue, 17 Jun 2025 16:36:56 +0800</pubDate><guid>https://www.diguage.com/post/redis-core-data-structure-4/</guid><description>&lt;div class="paragraph">
&lt;p>在 &lt;a href="https://www.diguage.com/post/redis-core-data-structure-3/" target="_blank" rel="noopener">Redis 核心数据结构（三）&lt;/a> 中，重点介绍了一下 Redis 7+ 使用的底层的数据结构 listpack。本文重点看一下，Redis 是如何基于 listpack 以及其他数据结构类型来构建对外暴露的五个核心数据结构的。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_quicklist">quicklist&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>关于 quicklist 更详细的介绍，请看 &lt;a href="https://www.diguage.com/post/redis-core-data-structure-1/#quicklist" target="_blank" rel="noopener">Redis 核心数据结构（一：quicklist&lt;/a>。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>与上述内容不一样的地方是，现在的 quicklist 底层是使用 listpack 来构建的，而不是上述内容介绍的 ziplist。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_list">list&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>关于 &lt;code>list-max-listpack-size&lt;/code> 的解释，在源码中找到了详细介绍：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="title">&lt;code>redis.conf&lt;/code>&lt;/div>
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="bash">&lt;span class="c"># Lists are also encoded in a special way to save a lot of space.&lt;/span>
&lt;span class="c"># The number of entries allowed per internal list node can be specified&lt;/span>
&lt;span class="c"># as a fixed maximum size or a maximum number of elements.&lt;/span>
&lt;span class="c"># For a fixed maximum size, use -5 through -1, meaning:&lt;/span>
&lt;span class="c"># -5: max size: 64 Kb &amp;lt;-- not recommended for normal workloads&lt;/span>
&lt;span class="c"># -4: max size: 32 Kb &amp;lt;-- not recommended&lt;/span>
&lt;span class="c"># -3: max size: 16 Kb &amp;lt;-- probably not recommended&lt;/span>
&lt;span class="c"># -2: max size: 8 Kb &amp;lt;-- good&lt;/span>
&lt;span class="c"># -1: max size: 4 Kb &amp;lt;-- good&lt;/span>
&lt;span class="c"># Positive numbers mean store up to _exactly_ that number of elements&lt;/span>
&lt;span class="c"># per list node.&lt;/span>
&lt;span class="c"># The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),&lt;/span>
&lt;span class="c"># but if your use case is unique, adjust the settings as necessary.&lt;/span>
list-max-listpack-size &lt;span class="nt">-2&lt;/span>&lt;/code>&lt;/pre>
&lt;/div></description></item><item><title>Redis 核心数据结构（三）</title><link>https://www.diguage.com/post/redis-core-data-structure-3/</link><pubDate>Fri, 13 Jun 2025 17:36:31 +0800</pubDate><guid>https://www.diguage.com/post/redis-core-data-structure-3/</guid><description>&lt;div class="paragraph">
&lt;p>在五年前，D瓜哥写了 &lt;a href="https://www.diguage.com/post/redis-core-data-structure-1/" target="_blank" rel="noopener">Redis 核心数据结构（一）&lt;/a> 和 &lt;a href="https://www.diguage.com/post/redis-core-data-structure-2/" target="_blank" rel="noopener">Redis 核心数据结构（二）&lt;/a> 两篇文章，来对 Redis 内部的数据结构做了深入分析。随着时间的推移，Redis 的实现也在不断进化，现在这些内容已经跟不上最新发展了，推陈出新，现在重写文章，来介绍 Redis 的最新发展。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_listpack">listpack&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>从 Redis 7.0 开始，使用 listpack 替换原来的 ziplist。至于替换原因，在 &lt;a href="https://github.com/redis/redis/issues/8702" target="_blank" rel="noopener">[NEW] listpack migration - replace all usage of ziplist with listpack&lt;/a> 做了解释说明：&lt;/p>
&lt;/div>
&lt;div class="quoteblock">
&lt;blockquote>
&lt;div class="paragraph">
&lt;p>The reason for using listpack instead of ziplist is that ziplist may cause cascading updates when insert and delete in middle, which is the biggest problem.&lt;/p>
&lt;/div>
&lt;/blockquote>
&lt;div class="attribution">
— sundb
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>翻译过来：当在中间进行插入和删除时，ziplist 也许会产生级联更新，这是一个大问题。&lt;/p>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_编码规范">编码规范&lt;/h3>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/redis/listpack.png" alt="listpack 编码格式" width="95%"/>
&lt;/div>
&lt;div class="title">图 1. listpack 编码格式&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>相比 ziplist，listpack 更偏向空间换时间。淡化极致的内存使用率，向更快的方向发力。&lt;/p>
&lt;/div>
&lt;div class="sect3">
&lt;h4 id="integer">对整数编码&lt;/h4>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/redis/listpack-integer.png" alt="listpack 整数编码" width="95%"/>
&lt;/div></description></item><item><title>深入研究 BeanFactoryPostProcessor</title><link>https://www.diguage.com/post/dive-into-beanfactorypostprocessor/</link><pubDate>Sat, 01 Jun 2024 16:18:55 +0800</pubDate><guid>https://www.diguage.com/post/dive-into-beanfactorypostprocessor/</guid><description>&lt;div class="paragraph">
&lt;p>D瓜哥在 &lt;a href="https://www.diguage.com/post/spring-extensions-overview/" target="_blank" rel="noopener">Spring 扩展点概览及实践&lt;/a> 中概要性地介绍了一下 Spring 的核心扩展点。里面也提到了 &lt;code>BeanFactoryPostProcessor&lt;/code> 和 &lt;code>BeanDefinitionRegistryPostProcessor&lt;/code>，但仅仅提了一句，没有深入研究。在 &lt;a href="https://www.diguage.com/post/spring-extensions-and-mybatis/" target="_blank" rel="noopener">Spring 扩展点实践：整合 MyBATIS&lt;/a> 中，由于 &lt;code>MapperScannerConfigurer&lt;/code> 实现了 &lt;code>BeanDefinitionRegistryPostProcessor&lt;/code> 接口，也只是简单介绍了一些作用，又一次没有深入研究。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>最近，在开发一个插件时，遇到了一个问题：&lt;strong>利用 &lt;code>BeanFactoryPostProcessor&lt;/code> 对一些特定 &lt;code>BeanDefinition&lt;/code> 设置属性，但生成的 Bean 却没有相关的属性值。&lt;/strong>由此，对 &lt;code>BeanFactoryPostProcessor&lt;/code> 做了一些研究。记录一下，以备不时之需。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_spring_启动流程简介">Spring 启动流程简介&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>在 &lt;a href="https://www.diguage.com/post/spring-startup-process-overview/" target="_blank" rel="noopener">Spring 启动流程概述&lt;/a> 中，D瓜哥对 Spring 的启动流程做了比较详细的介绍。同时画了一张启动流程图，如下：&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/spring-framework/AbstractApplicationContext-refresh.svg" alt="AbstractApplicationContext.refresh — 重塑容器" width="95%"/>
&lt;/div>
&lt;div class="title">图 1. AbstractApplicationContext.refresh — 重塑容器&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>从该图中可以明显看到，如果需要对 Spring 的 &lt;code>BeanDefinition&lt;/code> 做些修改，那么，就需要通过实现 &lt;code>BeanFactoryPostProcessor&lt;/code> 接口，来对 Spring 做些扩展。坦白讲，为了上述流程图只展示了一个非常概要性的流程。如果深入一下 &lt;code>invokeBeanFactoryPostProcessors&lt;/code> 方法的细节，会发现这又是一番天地。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_beanfactorypostprocessor_调用详解">&lt;code>BeanFactoryPostProcessor&lt;/code> 调用详解&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>D瓜哥把 &lt;code>invokeBeanFactoryPostProcessors&lt;/code> 方法的流程图也画了出来，细节如下：&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/spring-framework/AbstractApplicationContext-invokeBeanFactoryPostProcessors.svg" alt="BeanDefinitionRegistryPostProcessor &amp;amp; BeanFactoryPostProcessor 调用过程" width="95%"/>
&lt;/div>
&lt;div class="title">图 2. BeanDefinitionRegistryPostProcessor &amp;amp; BeanFactoryPostProcessor 调用过程&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>从这张流程图上可以看出 &lt;code>BeanFactoryPostProcessor&lt;/code> 的调用过程，比在 &lt;a href="https://www.diguage.com/post/spring-startup-process-overview/" target="_blank" rel="noopener">Spring 启动流程概述&lt;/a> 中介绍的要复杂很多：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>首先，执行 &lt;code>BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry&lt;/code> 方法，顺序如下：&lt;/p>
&lt;div class="paragraph">
&lt;p>关于 &lt;code>BeanDefinitionRegistryPostProcessor&lt;/code> 的处理流程，D瓜哥在 &lt;a href="https://www.diguage.com/post/spring-extensions-overview/#bean-factory-post-processor" target="_blank" rel="noopener">Spring 扩展点概览及实践：BeanDefinitionRegistryPostProcessor&lt;/a> 中有更详细的描述，不了解的朋友请参考那篇文章的介绍。&lt;/p>
&lt;/div></description></item><item><title>Spring 应用合并之路</title><link>https://www.diguage.com/post/the-merging-spring-applications-road/</link><pubDate>Sat, 23 Dec 2023 20:38:47 +0800</pubDate><guid>https://www.diguage.com/post/the-merging-spring-applications-road/</guid><description>&lt;div class="paragraph">
&lt;p>公司最近一年在推进降本增效，在用尽各种手段之后，发现应用太多，每个应用都做跨机房容灾部署，则最少需要 4 台机器（称为容器更合适）。那么，将相近应用做一个合并，减少维护项目，提高机器利用率就是一个可选方案。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>经过前后三次不同的折腾，最后探索出来一个可行方案。记录一下，分享出来，希望对有相关需求的研发童鞋有所帮助。下面按照四种可能的方案，分别做介绍。另外，为了方便做演示，专门整了两个演示项目：&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/diguage/merge-demo-boot" target="_blank" rel="noopener">diguage/merge-demo-boot&lt;/a> — 合并项目，下面简称为 &lt;code>boot&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/diguage/merge-demo-web" target="_blank" rel="noopener">diguage/merge-demo-web&lt;/a> — 被合并项目，下面简称为 &lt;code>web&lt;/code>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_jar_包引用">Jar 包引用&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>这个方式，可能是给人印象最容易的方式。仔细思考一下，从维护性的角度来看，这个方式反而是最麻烦的方式，理由如下：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;code>web&lt;/code> 项目每次更新，都需要重新打包发布新版； &lt;code>boot&lt;/code> 项目也需要跟着更新发布。拉一次屎，脱两次裤子。属实麻烦。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>还需要考虑 &lt;code>web&lt;/code> 项目的加载问题，类似下面要描述的，是否共用容器：&lt;/p>
&lt;div class="olist loweralpha">
&lt;ol class="loweralpha" type="a">
&lt;li>
&lt;p>共用容器 — 这是最容器想到的方式。但是这种方式，需要解决 Bean 冲突的问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不共用容器 — 这种方式需要处理 &lt;code>web&lt;/code> 容器如何加载的问题。默认应该是无法识别。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>基于这些考虑，这种方式直接被抛弃了。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_仓库合并公用一套容器">仓库合并，公用一套容器&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>这是第一次尝试使用的方案。也是遇到问题最多的方案。&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>将两个仓库做合并。&lt;/p>
&lt;div class="olist loweralpha">
&lt;ol class="loweralpha" type="a">
&lt;li>
&lt;p>将 &lt;code>web&lt;/code> 仓库的地址配置到 &lt;code>boot&lt;/code> 项目里： &lt;code>git remote add web &lt;a href="mailto:git@github.com">git@github.com&lt;/a>:diguage/merge-demo-web.git&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 &lt;code>boot&lt;/code> 项目里，切出来一个分支： &lt;code>git switch -c web&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将 &lt;code>web&lt;/code> 分支的提交清空： &lt;code>git update-ref -d HEAD&lt;/code>，然后做一次提交；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将 &lt;code>web&lt;/code> 项目的代码克隆到 &lt;code>web&lt;/code> 分支上： &lt;code>git pull --rebase --allow-unrelated-histories web master&lt;/code>；注意，这里需要加 &lt;code>--allow-unrelated-histories&lt;/code> 参数，以允许不相干的仓库进行合并。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>从 &lt;code>boot&lt;/code> 项目的 &lt;code>master&lt;/code> 分支上，切出来一个合并分支： &lt;code>git switch -c merge&lt;/code>；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将 &lt;code>web&lt;/code> 项目向 &lt;code>boot&lt;/code> 项目合并： &lt;code>git merge --allow-unrelated-histories web&lt;/code>；注意，这里需要加 &lt;code>--allow-unrelated-histories&lt;/code> 参数，以允许不相干的仓库进行合并。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>处理代码冲突，完成合并即可。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Spring 对占位符的处理（一）：XML 中的 Bean</title><link>https://www.diguage.com/post/placeholder-in-spring-1/</link><pubDate>Mon, 01 May 2023 22:15:55 +0800</pubDate><guid>https://www.diguage.com/post/placeholder-in-spring-1/</guid><description>&lt;div class="paragraph">
&lt;p>最近有小伙伴在开发时，遇到了一个 Spring 占位符，例如 &lt;code>${token}&lt;/code>， 在不同环境下处理不一致的问题，正好对 Spring 对占位符的处理也有一些不清楚的地方，趁此机会，把 Spring 对占位符的处理机制深入了解一下，方便后续排查问题。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>经常阅读D瓜哥博客的朋友可能知道，D瓜哥在 &lt;a href="https://www.diguage.com/post/spring-extensions-and-dubbo-1/#spring-plugin" target="_blank" rel="noopener">Spring 扩展点实践：整合 Apache Dubbo（一）： Spring 插件机制简介&lt;/a> 中已经介绍了 Spring 的插件机制。在阅读以下内容之前，建议大家先去阅读一下这篇文章中“Spring 插件机制简介”章节的内容，以便于无缝衔接。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>在分析的过程中发现， Spring 对占位符有两种截然不同的出来阶段：① XML 配置文件中的占位符；② Java 源代码中 &lt;code>@Value&lt;/code> 注解中的占位符。由于内容较多，一篇讲解完有些过长，所以分三篇文章来分别介绍这两种处理过程。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>本篇首先来介绍一下对 XML 配置文件中的占位符的处理。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_示例代码">示例代码&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>在正式开始之前，先来看一下示例代码：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="title">&lt;code>UserRpc.java&lt;/code>&lt;/div>
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="java">&lt;span class="cm">/**
 * @author D瓜哥 · &lt;a href="https://www.diguage.com" target="_blank">https://www.diguage.com&lt;/a>
 * @since 2023-05-02 10:23:49
 */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">UserRpc&lt;/span> &lt;span class="o">{&lt;/span>

 &lt;span class="nd">@Value&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;${user.appId}&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
 &lt;span class="kd">private&lt;/span> &lt;span class="nc">String&lt;/span> &lt;span class="n">appId&lt;/span>&lt;span class="o">;&lt;/span>

 &lt;span class="c1">// 这里不使用注解，而是使用 XML 配置&lt;/span>
 &lt;span class="c1">// @Value(&amp;#34;${user.token}&amp;#34;)&lt;/span>
 &lt;span class="kd">private&lt;/span> &lt;span class="nc">String&lt;/span> &lt;span class="n">token&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="title">&lt;code>token.properties&lt;/code>&lt;/div>
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="bash">user.appId&lt;span class="o">=&lt;/span>dummyAppId
user.token&lt;span class="o">=&lt;/span>dummyToken&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="title">&lt;code>spring.xml&lt;/code>&lt;/div>
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="xml">&lt;span class="cp">&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;beans&lt;/span> &lt;span class="na">xmlns=&lt;/span>&lt;span class="s">&amp;#34;http://www.springframework.org/schema/beans&amp;#34;&lt;/span>
 &lt;span class="na">xmlns:xsi=&lt;/span>&lt;span class="s">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span>
 &lt;span class="na">xmlns:context=&lt;/span>&lt;span class="s">&amp;#34;http://www.springframework.org/schema/context&amp;#34;&lt;/span>
 &lt;span class="na">xsi:schemaLocation=&lt;/span>&lt;span class="s">&amp;#34;http://www.springframework.org/schema/beans
 http://www.springframework.org/schema/beans/spring-beans.xsd
 http://www.springframework.org/schema/context
 https://www.springframework.org/schema/context/spring-context.xsd&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>

 &lt;span class="c">&amp;lt;!-- @author D瓜哥 · &lt;a href="https://www.diguage.com" target="_blank">https://www.diguage.com&lt;/a> --&amp;gt;&lt;/span>

 &lt;span class="nt">&amp;lt;context:annotation-config/&amp;gt;&lt;/span>

 &lt;span class="nt">&amp;lt;bean&lt;/span> &lt;span class="na">id=&lt;/span>&lt;span class="s">&amp;#34;userRpc&amp;#34;&lt;/span>
 &lt;span class="na">class=&lt;/span>&lt;span class="s">&amp;#34;com.diguage.truman.context.UserRpc&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
 &lt;span class="c">&amp;lt;!-- XML 配置的占位符实例在此 --&amp;gt;&lt;/span>
 &lt;span class="nt">&amp;lt;property&lt;/span> &lt;span class="na">name=&lt;/span>&lt;span class="s">&amp;#34;token&amp;#34;&lt;/span> &lt;span class="na">value=&lt;/span>&lt;span class="s">&amp;#34;${user.token}&amp;#34;&lt;/span>&lt;span class="nt">/&amp;gt;&lt;/span>
 &lt;span class="nt">&amp;lt;/bean&amp;gt;&lt;/span>

 &lt;span class="nt">&amp;lt;context:property-placeholder&lt;/span> &lt;span class="na">location=&lt;/span>&lt;span class="s">&amp;#34;classpath:token.properties&amp;#34;&lt;/span>&lt;span class="nt">/&amp;gt;&lt;/span>

&lt;span class="nt">&amp;lt;/beans&amp;gt;&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_bean_标签处理">&lt;code>&amp;lt;bean&amp;gt;&lt;/code> 标签处理&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>在 &lt;a href="https://www.diguage.com/post/spring-startup-process-overview/" target="_blank" rel="noopener">Spring 启动流程概述&lt;/a> 中，已经介绍过，Spring 的启动过程几乎都被封装在 &lt;code>AbstractApplicationContext#refresh&lt;/code> 方法中。在 &lt;code>refresh&lt;/code> 方法中调用了 &lt;code>refreshBeanFactory&lt;/code> 方法；在 &lt;code>refreshBeanFactory&lt;/code> 方法执行过程中，调用了 &lt;code>loadBeanDefinitions&lt;/code> 方法。而 &lt;code>BeanDefinition&lt;/code> 的加载是由 &lt;code>org.springframework.context.support.AbstractRefreshableApplicationContext#loadBeanDefinitions&lt;/code> 来完成的。通过 XML 文件配置的 Bean 是由 &lt;code>org.springframework.context.support.AbstractXmlApplicationContext#loadBeanDefinitions(org.springframework.beans.factory.support.DefaultListableBeanFactory)&lt;/code> （&lt;code>AbstractRefreshableApplicationContext&lt;/code> 的子类）处理完成的。处理过程的时序图如下：&lt;/p>
&lt;/div></description></item><item><title>制定组织内 Maven BOM 的一些规范</title><link>https://www.diguage.com/post/specification-for-maven-bom/</link><pubDate>Sat, 03 Sep 2022 09:19:59 +0800</pubDate><guid>https://www.diguage.com/post/specification-for-maven-bom/</guid><description>&lt;div class="paragraph">
&lt;p>在 &lt;a href="https://www.diguage.com/post/experience-about-upgrading-java-dependencies/" target="_blank" rel="noopener">关于升级 Spring 等依赖的一些经验&lt;/a> 中介绍了 D瓜哥在升级项目依赖时，遇到的一些问题以及一些需要注意的地方。但是，这里还存在一个问题：&lt;strong>各个依赖的版本依然散落在各个项目中；升级依赖，需要在所有项目中，把所有相关项目的依赖都巴拉一下，费时费力。&lt;/strong>解决这个问题的一个比较好的办法是&lt;strong>制定一个组织内部的 Maven BOM，集中管理相关依赖的版本。&lt;/strong>这样升级的时候，还需要修改 BOM 的版本号即可。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_maven_bom_介绍">Maven BOM 介绍&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>BOM（Bill of Materials）是由 Maven 提供的功能,它通过定义一整套相互兼容的 jar 包版本集合，使用时只需要依赖该BOM文件，即可放心的使用需要的依赖 jar 包，且无需再指定版本号。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_一些基本原则">一些基本原则&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>Spring &amp;amp; Spring Boot 是 Java 生态中，全世界广泛使用的开发框架，在各种场景中都经受过考验。所以，Spring &amp;amp; Spring Boot 选择的 Jar 在稳定性和兼容性方面都有保证。另外，Spring Boot 本身就集成了非常非常多的依赖，并为此创建了一个网页 &lt;a href="https://docs.spring.io/spring-boot/docs/current/reference/html/dependency-versions.html" target="_blank" rel="noopener">Spring Boot Dependency versions&lt;/a> 来说明它集成的依赖及版本。故而，可以选择以 Spring Boot 为底本，来制作自己的 BOM。&lt;/p>
&lt;div class="olist loweralpha">
&lt;ol class="loweralpha" type="a">
&lt;li>
&lt;p>如果不需要 Spring 相关依赖，可以将 Spring 相关依赖删除掉，然后在其之上增加组织内部依赖而创建自己的 BOM。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果需要 Spring 相关依赖，那么直接继承&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>在稳定性方面，经过更多人检验的版本，则稳定性更有保障。所以，选择最近两年下载次数比较多的版本。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>更新的版本，更容易获得技术升级带来的红利。所以，在可能的情况下，优先选择高版本。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>优先考虑目标 JDK 的支持情况。例如，一些依赖的高版本或低版本不支持 Java 8，但是 Java 8 是生产环境部署的主要版本，那么太高的版本和低版本都不适合。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_外部_jar_包选择标准">外部 Jar 包选择标准&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>尽量将外部中间件统一到同一种依赖的同一个版本上。例如：数据库连接池全部使用 HikariCP；JSON 处理统一使用 Jackson。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>选择最近两年发布的版本中，下载次数最多的版本为准。如果有发布的小版本升级，则在该版本基础上，该版本的最新修订版。例如，1.2.3 是最近两年下载最多的版本，但是 1.2.4 已经发布，则优先选择使用 1.2.4。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果有两个大版本，高版本符合条件的情况下，优先选择高版本。低版本大概率是先淘汰的，高版本相对来说维护时间更长，另外高版本的代码优化得更佳。例如，Ehcache 的选择。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果传递依赖造成依赖 Jar 包版本冲突，则尽可能选择高版本的 Jar。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>持续演进的项目的依赖优先级更高；相反，临近淘汰的项目优先级降低，甚至不予考虑。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>两年以上未更新的依赖，在 API 兼容的情况下，直接升级到最新版。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>没有显示使用而是间接引入的依赖，不再单独声明，由直接依赖来引入。如果需要解决冲突，则按照上面的原则来处理。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Avro、ProtoBuf、Thrift 的模式演进之法【翻译】</title><link>https://www.diguage.com/post/schema-evolution-in-avro-protobuf-thrift/</link><pubDate>Sat, 27 Aug 2022 08:30:43 +0800</pubDate><guid>https://www.diguage.com/post/schema-evolution-in-avro-protobuf-thrift/</guid><description>&lt;div class="sidebarblock">
&lt;div class="content">
&lt;div class="paragraph">
&lt;p>前面系统研究了 Hessian 序列化协议。并以此为契机，顺带实例对比了 Hessian、MessagePack 和 JSON 的序列化。早在 2012 年，Martin Kleppmann 就写了一篇文章 &lt;a href="https://martin.kleppmann.com/2012/12/05/schema-evolution-in-avro-protocol-buffers-thrift.html" target="_blank" rel="noopener">《Schema evolution in Avro, Protocol Buffers and Thrift》&lt;/a>，也是基于实例，对比了 Avro、ProtoBuf、Thrift 的差别。现在翻译出来，方便做系列研究。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>整个“序列化系列”目录如下：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a> — Hessian 序列化协议的中文翻译版。根据后面的“协议解释与实战”系列文章，增加了协议内容错误提示。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/" target="_blank" rel="noopener">Hessian 协议解释与实战（一）：布尔、日期、浮点数与整数&lt;/a> — 介绍布尔型数据、日期类型、浮点类型数据和整数类型数据等四种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-2/" target="_blank" rel="noopener">Hessian 协议解释与实战（二）：长整型、二进制数据与 Null&lt;/a> — 介绍长整数类型数据、二进制数据和 &lt;code>null&lt;/code> 等三种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-3/" target="_blank" rel="noopener">Hessian 协议解释与实战（三）：字符串&lt;/a> — 专门介绍了关于字符串的处理。由于字符串需要铺垫的基础知识比较多，处理细节也有繁琐，所以单独成篇来介绍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-source-analysis-for-java/" target="_blank" rel="noopener">Hessian 源码分析（Java）&lt;/a> — 开始第四篇分析之前，先来介绍一下 Hessian 的源码实现。方便后续展开说明。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-4/" target="_blank" rel="noopener">Hessian 协议解释与实战（四）：数组与集合&lt;/a> — 铺垫了一些关于实例对象的处理，重点介绍关于数组和集合的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-5/" target="_blank" rel="noopener">Hessian 协议解释与实战（五）：对象与映射&lt;/a> — 重点介绍关于对象与映射的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-vs-msgpack-vs-json/" target="_blank" rel="noopener">Hessian、Msgpack 和 JSON 实例对比&lt;/a> — 用实例对比 JSON、Hessian 和 MessagePack 的区别。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/schema-evolution-in-avro-protobuf-thrift" target="_blank" rel="noopener">Avro、ProtoBuf、Thrift 的模式演进之路&lt;/a> — 翻译的 Martin Kleppmann 的文章，重点对比了 Avro、ProtoBuf、Thrift 的序列化处理思路。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Hessian、Msgpack 和 JSON 实例对比</title><link>https://www.diguage.com/post/hessian-vs-msgpack-vs-json/</link><pubDate>Fri, 05 Aug 2022 11:28:03 +0800</pubDate><guid>https://www.diguage.com/post/hessian-vs-msgpack-vs-json/</guid><description>&lt;div class="paragraph">
&lt;p>前段时间，翻译了 Hessian 2.0 的序列化协议，发布在了 &lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a>。但是，其中有很多言语不详之处。所以，接下来会用几篇文章来详细解释并实践一下 Hessian 序列化协议，以求做到知其然知其所以然。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>目录如下：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a> — Hessian 序列化协议的中文翻译版。根据后面的“协议解释与实战”系列文章，增加了协议内容错误提示。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/" target="_blank" rel="noopener">Hessian 协议解释与实战（一）：布尔、日期、浮点数与整数&lt;/a> — 介绍布尔型数据、日期类型、浮点类型数据和整数类型数据等四种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-2/" target="_blank" rel="noopener">Hessian 协议解释与实战（二）：长整型、二进制数据与 Null&lt;/a> — 介绍长整数类型数据、二进制数据和 &lt;code>null&lt;/code> 等三种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-3/" target="_blank" rel="noopener">Hessian 协议解释与实战（三）：字符串&lt;/a> — 专门介绍了关于字符串的处理。由于字符串需要铺垫的基础知识比较多，处理细节也有繁琐，所以单独成篇来介绍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-source-analysis-for-java/" target="_blank" rel="noopener">Hessian 源码分析（Java）&lt;/a> — 开始第四篇分析之前，先来介绍一下 Hessian 的源码实现。方便后续展开说明。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-4/" target="_blank" rel="noopener">Hessian 协议解释与实战（四）：数组与集合&lt;/a> — 铺垫了一些关于实例对象的处理，重点介绍关于数组和集合的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-5/" target="_blank" rel="noopener">Hessian 协议解释与实战（五）：对象与映射&lt;/a> — 重点介绍关于对象与映射的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-vs-msgpack-vs-json/" target="_blank" rel="noopener">Hessian、Msgpack 和 JSON 实例对比&lt;/a> — 用实例对比 JSON、Hessian 和 MessagePack 的区别。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/schema-evolution-in-avro-protobuf-thrift" target="_blank" rel="noopener">Avro、ProtoBuf、Thrift 的模式演进之路&lt;/a> — 翻译的 Martin Kleppmann 的文章，重点对比了 Avro、ProtoBuf、Thrift 的序列化处理思路。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;hr/>
&lt;div class="paragraph">
&lt;p>本文用实际来对比一下 JSON、Hessian 和 MessagePack 的区别。&lt;/p>
&lt;/div></description></item><item><title>Hessian 协议解释与实战（五）：对象与映射</title><link>https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-5/</link><pubDate>Tue, 31 May 2022 16:02:13 +0800</pubDate><guid>https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-5/</guid><description>&lt;div class="paragraph">
&lt;p>前段时间，翻译了 Hessian 2.0 的序列化协议，发布在了 &lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a>。但是，其中有很多言语不详之处。所以，接下来会用几篇文章来详细解释并实践一下 Hessian 序列化协议，以求做到知其然知其所以然。目录如下：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a> — Hessian 序列化协议的中文翻译版。根据后面的“协议解释与实战”系列文章，增加了协议内容错误提示。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/" target="_blank" rel="noopener">Hessian 协议解释与实战（一）：布尔、日期、浮点数与整数&lt;/a> — 介绍布尔型数据、日期类型、浮点类型数据和整数类型数据等四种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-2/" target="_blank" rel="noopener">Hessian 协议解释与实战（二）：长整型、二进制数据与 Null&lt;/a> — 介绍长整数类型数据、二进制数据和 &lt;code>null&lt;/code> 等三种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-3/" target="_blank" rel="noopener">Hessian 协议解释与实战（三）：字符串&lt;/a> — 专门介绍了关于字符串的处理。由于字符串需要铺垫的基础知识比较多，处理细节也有繁琐，所以单独成篇来介绍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-source-analysis-for-java/" target="_blank" rel="noopener">Hessian 源码分析（Java）&lt;/a> — 开始第四篇分析之前，先来介绍一下 Hessian 的源码实现。方便后续展开说明。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-4/" target="_blank" rel="noopener">Hessian 协议解释与实战（四）：数组与集合&lt;/a> — 铺垫了一些关于实例对象的处理，重点介绍关于数组和集合的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-5/" target="_blank" rel="noopener">Hessian 协议解释与实战（五）：对象与映射&lt;/a> — 重点介绍关于对象与映射的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-vs-msgpack-vs-json/" target="_blank" rel="noopener">Hessian、Msgpack 和 JSON 实例对比&lt;/a> — 用实例对比 JSON、Hessian 和 MessagePack 的区别。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/schema-evolution-in-avro-protobuf-thrift" target="_blank" rel="noopener">Avro、ProtoBuf、Thrift 的模式演进之路&lt;/a> — 翻译的 Martin Kleppmann 的文章，重点对比了 Avro、ProtoBuf、Thrift 的序列化处理思路。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;hr/>
&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-4/" target="_blank" rel="noopener">Hessian 协议解释与实战（四）：数组与集合&lt;/a> 中研究了数组和集合的处理方式。接下来介绍对象和映射的处理。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_基础工具方法">基础工具方法&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>基础工具方法就不再赘述，请直接参考 &lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/#helper-methods" target="_blank" rel="noopener">Hessian 协议解释与实战（一）：基础工具方法&lt;/a> 中提到的几个方法。&lt;/p>
&lt;/div></description></item><item><title>Hessian 协议解释与实战（四）：数组与集合</title><link>https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-4/</link><pubDate>Thu, 26 May 2022 18:01:43 +0800</pubDate><guid>https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-4/</guid><description>&lt;div class="paragraph">
&lt;p>前段时间，翻译了 Hessian 2.0 的序列化协议，发布在了 &lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a>。但是，其中有很多言语不详之处。所以，接下来会用几篇文章来详细解释并实践一下 Hessian 序列化协议，以求做到知其然知其所以然。目录如下：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a> — Hessian 序列化协议的中文翻译版。根据后面的“协议解释与实战”系列文章，增加了协议内容错误提示。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/" target="_blank" rel="noopener">Hessian 协议解释与实战（一）：布尔、日期、浮点数与整数&lt;/a> — 介绍布尔型数据、日期类型、浮点类型数据和整数类型数据等四种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-2/" target="_blank" rel="noopener">Hessian 协议解释与实战（二）：长整型、二进制数据与 Null&lt;/a> — 介绍长整数类型数据、二进制数据和 &lt;code>null&lt;/code> 等三种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-3/" target="_blank" rel="noopener">Hessian 协议解释与实战（三）：字符串&lt;/a> — 专门介绍了关于字符串的处理。由于字符串需要铺垫的基础知识比较多，处理细节也有繁琐，所以单独成篇来介绍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-source-analysis-for-java/" target="_blank" rel="noopener">Hessian 源码分析（Java）&lt;/a> — 开始第四篇分析之前，先来介绍一下 Hessian 的源码实现。方便后续展开说明。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-4/" target="_blank" rel="noopener">Hessian 协议解释与实战（四）：数组与集合&lt;/a> — 铺垫了一些关于实例对象的处理，重点介绍关于数组和集合的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-5/" target="_blank" rel="noopener">Hessian 协议解释与实战（五）：对象与映射&lt;/a> — 重点介绍关于对象与映射的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-vs-msgpack-vs-json/" target="_blank" rel="noopener">Hessian、Msgpack 和 JSON 实例对比&lt;/a> — 用实例对比 JSON、Hessian 和 MessagePack 的区别。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/schema-evolution-in-avro-protobuf-thrift" target="_blank" rel="noopener">Avro、ProtoBuf、Thrift 的模式演进之路&lt;/a> — 翻译的 Martin Kleppmann 的文章，重点对比了 Avro、ProtoBuf、Thrift 的序列化处理思路。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;hr/>
&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/hessian-source-analysis-for-java/" target="_blank" rel="noopener">Hessian 源码分析（Java）&lt;/a> 对 Hessian 的 Java 实现做了一个概要的分析，对处理流程以及整体架构做了一个简单的分析。接下来，回到主题，继续来解释 Hessian 序列化协议。这篇文章，我们来重点分析一下数组与集合相关的操作。&lt;/p>
&lt;/div></description></item><item><title>Hessian 源码分析（Java）</title><link>https://www.diguage.com/post/hessian-source-analysis-for-java/</link><pubDate>Sat, 21 May 2022 09:39:44 +0800</pubDate><guid>https://www.diguage.com/post/hessian-source-analysis-for-java/</guid><description>&lt;div class="paragraph">
&lt;p>前面通过几篇文章，解释并实践了一下 Hessian 的序列化协议。文章目录如下：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a> — Hessian 序列化协议的中文翻译版。根据后面的“协议解释与实战”系列文章，增加了协议内容错误提示。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/" target="_blank" rel="noopener">Hessian 协议解释与实战（一）：布尔、日期、浮点数与整数&lt;/a> — 介绍布尔型数据、日期类型、浮点类型数据和整数类型数据等四种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-2/" target="_blank" rel="noopener">Hessian 协议解释与实战（二）：长整型、二进制数据与 Null&lt;/a> — 介绍长整数类型数据、二进制数据和 &lt;code>null&lt;/code> 等三种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-3/" target="_blank" rel="noopener">Hessian 协议解释与实战（三）：字符串&lt;/a> — 专门介绍了关于字符串的处理。由于字符串需要铺垫的基础知识比较多，处理细节也有繁琐，所以单独成篇来介绍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-source-analysis-for-java/" target="_blank" rel="noopener">Hessian 源码分析（Java）&lt;/a> — 开始第四篇分析之前，先来介绍一下 Hessian 的源码实现。方便后续展开说明。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-4/" target="_blank" rel="noopener">Hessian 协议解释与实战（四）：数组与集合&lt;/a> — 铺垫了一些关于实例对象的处理，重点介绍关于数组和集合的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-5/" target="_blank" rel="noopener">Hessian 协议解释与实战（五）：对象与映射&lt;/a> — 重点介绍关于对象与映射的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-vs-msgpack-vs-json/" target="_blank" rel="noopener">Hessian、Msgpack 和 JSON 实例对比&lt;/a> — 用实例对比 JSON、Hessian 和 MessagePack 的区别。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/schema-evolution-in-avro-protobuf-thrift" target="_blank" rel="noopener">Avro、ProtoBuf、Thrift 的模式演进之路&lt;/a> — 翻译的 Martin Kleppmann 的文章，重点对比了 Avro、ProtoBuf、Thrift 的序列化处理思路。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;hr/>
&lt;div class="paragraph">
&lt;p>该系列第四篇文章准备详细介绍一下 Hessian 对对象、链表以及 &lt;code>Map&lt;/code> 等处理。但是，越调试代码，越发觉得应该先对 Hessian 的实现做一个源码分析。于是，就有了本文。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>这里有几点需要声明一下：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>在上面“解释与实战”系列文章中提到的代码就不再重复说明。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过“解释与实战”系列文章，大家应该可以领略到，处理序列化有大量的细节。但是，本文并不打算涉及。本文重点是介绍 Hessian 的 Java 实现的架构蓝图。相当于给指明一条路，沿着这条路，大家就可以探索 Hessian 的各种细节。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>本文的介绍，全部基于 Hessian 4.0.60 的源码。由于没有找到 Hessian 的仓库，D瓜哥从 Hessian 的网站下，下载了源码包，解压后发布在了 GitHub 上： &lt;a href="https://github.com/diguage/hessian" target="_blank" rel="noopener">Hessian — The source code of Hessian Library.&lt;/a>。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Hessian 协议解释与实战（三）：字符串</title><link>https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-3/</link><pubDate>Wed, 04 May 2022 16:09:05 +0000</pubDate><guid>https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-3/</guid><description>&lt;div class="paragraph">
&lt;p>前段时间，翻译了 Hessian 2.0 的序列化协议，发布在了 &lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a>。但是，其中有很多言语不详之处。所以，接下来会用几篇文章来详细解释并实践一下 Hessian 序列化协议，以求做到知其然知其所以然。目录如下：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a> — Hessian 序列化协议的中文翻译版。根据后面的“协议解释与实战”系列文章，增加了协议内容错误提示。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/" target="_blank" rel="noopener">Hessian 协议解释与实战（一）：布尔、日期、浮点数与整数&lt;/a> — 介绍布尔型数据、日期类型、浮点类型数据和整数类型数据等四种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-2/" target="_blank" rel="noopener">Hessian 协议解释与实战（二）：长整型、二进制数据与 Null&lt;/a> — 介绍长整数类型数据、二进制数据和 &lt;code>null&lt;/code> 等三种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-3/" target="_blank" rel="noopener">Hessian 协议解释与实战（三）：字符串&lt;/a> — 专门介绍了关于字符串的处理。由于字符串需要铺垫的基础知识比较多，处理细节也有繁琐，所以单独成篇来介绍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-source-analysis-for-java/" target="_blank" rel="noopener">Hessian 源码分析（Java）&lt;/a> — 开始第四篇分析之前，先来介绍一下 Hessian 的源码实现。方便后续展开说明。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-4/" target="_blank" rel="noopener">Hessian 协议解释与实战（四）：数组与集合&lt;/a> — 铺垫了一些关于实例对象的处理，重点介绍关于数组和集合的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-5/" target="_blank" rel="noopener">Hessian 协议解释与实战（五）：对象与映射&lt;/a> — 重点介绍关于对象与映射的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-vs-msgpack-vs-json/" target="_blank" rel="noopener">Hessian、Msgpack 和 JSON 实例对比&lt;/a> — 用实例对比 JSON、Hessian 和 MessagePack 的区别。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/schema-evolution-in-avro-protobuf-thrift" target="_blank" rel="noopener">Avro、ProtoBuf、Thrift 的模式演进之路&lt;/a> — 翻译的 Martin Kleppmann 的文章，重点对比了 Avro、ProtoBuf、Thrift 的序列化处理思路。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;hr/>
&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-2/" target="_blank" rel="noopener">Hessian 协议解释与实战（二）：长整型、二进制数据与 Null&lt;/a> 中研究了长整型、二进制数据与 &lt;code>null&lt;/code> 等三种数据类型的处理方式。接下来，我们再来介绍字符串的处理情况。&lt;/p>
&lt;/div></description></item><item><title>Hessian 协议解释与实战（二）：长整型、二进制数据与 Null</title><link>https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-2/</link><pubDate>Tue, 03 May 2022 16:09:15 +0800</pubDate><guid>https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-2/</guid><description>&lt;div class="paragraph">
&lt;p>前段时间，翻译了 Hessian 2.0 的序列化协议，发布在了 &lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a>。但是，其中有很多言语不详之处。所以，接下来会用几篇文章来详细解释并实践一下 Hessian 序列化协议，以求做到知其然知其所以然。目录如下：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a> — Hessian 序列化协议的中文翻译版。根据后面的“协议解释与实战”系列文章，增加了协议内容错误提示。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/" target="_blank" rel="noopener">Hessian 协议解释与实战（一）：布尔、日期、浮点数与整数&lt;/a> — 介绍布尔型数据、日期类型、浮点类型数据和整数类型数据等四种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-2/" target="_blank" rel="noopener">Hessian 协议解释与实战（二）：长整型、二进制数据与 Null&lt;/a> — 介绍长整数类型数据、二进制数据和 &lt;code>null&lt;/code> 等三种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-3/" target="_blank" rel="noopener">Hessian 协议解释与实战（三）：字符串&lt;/a> — 专门介绍了关于字符串的处理。由于字符串需要铺垫的基础知识比较多，处理细节也有繁琐，所以单独成篇来介绍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-source-analysis-for-java/" target="_blank" rel="noopener">Hessian 源码分析（Java）&lt;/a> — 开始第四篇分析之前，先来介绍一下 Hessian 的源码实现。方便后续展开说明。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-4/" target="_blank" rel="noopener">Hessian 协议解释与实战（四）：数组与集合&lt;/a> — 铺垫了一些关于实例对象的处理，重点介绍关于数组和集合的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-5/" target="_blank" rel="noopener">Hessian 协议解释与实战（五）：对象与映射&lt;/a> — 重点介绍关于对象与映射的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-vs-msgpack-vs-json/" target="_blank" rel="noopener">Hessian、Msgpack 和 JSON 实例对比&lt;/a> — 用实例对比 JSON、Hessian 和 MessagePack 的区别。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/schema-evolution-in-avro-protobuf-thrift" target="_blank" rel="noopener">Avro、ProtoBuf、Thrift 的模式演进之路&lt;/a> — 翻译的 Martin Kleppmann 的文章，重点对比了 Avro、ProtoBuf、Thrift 的序列化处理思路。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;hr/>
&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/" target="_blank" rel="noopener">Hessian 协议解释与实战（一）&lt;/a> 中研究了布尔型数据、日期类型、浮点类型数据、整数类型数据等四种数据类型的处理方式。接下来，我们再来介绍长整数类型数据、二进制数据和 &lt;code>null&lt;/code> 的处理情况。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_基础工具方法">基础工具方法&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>基础工具方法就不再赘述，请直接参考 &lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/#helper-methods" target="_blank" rel="noopener">Hessian 协议解释与实战（一）：布尔、日期、浮点数与整数：基础工具方法&lt;/a> 中提到的几个方法。&lt;/p>
&lt;/div></description></item><item><title>Hessian 协议解释与实战（一）：布尔、日期、浮点数与整数</title><link>https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/</link><pubDate>Mon, 02 May 2022 17:22:01 +0800</pubDate><guid>https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/</guid><description>&lt;div class="paragraph">
&lt;p>前段时间，翻译了 Hessian 2.0 的序列化协议，发布在了 &lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a>。但是，其中有很多言语不详之处。所以，接下来会用几篇文章来详细解释并实践一下 Hessian 序列化协议，以求做到知其然知其所以然。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>目录如下：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a> — Hessian 序列化协议的中文翻译版。根据后面的“协议解释与实战”系列文章，增加了协议内容错误提示。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/" target="_blank" rel="noopener">Hessian 协议解释与实战（一）：布尔、日期、浮点数与整数&lt;/a> — 介绍布尔型数据、日期类型、浮点类型数据和整数类型数据等四种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-2/" target="_blank" rel="noopener">Hessian 协议解释与实战（二）：长整型、二进制数据与 Null&lt;/a> — 介绍长整数类型数据、二进制数据和 &lt;code>null&lt;/code> 等三种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-3/" target="_blank" rel="noopener">Hessian 协议解释与实战（三）：字符串&lt;/a> — 专门介绍了关于字符串的处理。由于字符串需要铺垫的基础知识比较多，处理细节也有繁琐，所以单独成篇来介绍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-source-analysis-for-java/" target="_blank" rel="noopener">Hessian 源码分析（Java）&lt;/a> — 开始第四篇分析之前，先来介绍一下 Hessian 的源码实现。方便后续展开说明。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-4/" target="_blank" rel="noopener">Hessian 协议解释与实战（四）：数组与集合&lt;/a> — 铺垫了一些关于实例对象的处理，重点介绍关于数组和集合的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-5/" target="_blank" rel="noopener">Hessian 协议解释与实战（五）：对象与映射&lt;/a> — 重点介绍关于对象与映射的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-vs-msgpack-vs-json/" target="_blank" rel="noopener">Hessian、Msgpack 和 JSON 实例对比&lt;/a> — 用实例对比 JSON、Hessian 和 MessagePack 的区别。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/schema-evolution-in-avro-protobuf-thrift" target="_blank" rel="noopener">Avro、ProtoBuf、Thrift 的模式演进之路&lt;/a> — 翻译的 Martin Kleppmann 的文章，重点对比了 Avro、ProtoBuf、Thrift 的序列化处理思路。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;hr/>
&lt;div class="sect1">
&lt;h2 id="helper-methods">基础工具方法&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Hessian 序列化之后的数据，都是字节数组，为了方便查看字节数组的二进制形式和十六进制形式，在正式开始之前，先介绍一下期间用到的辅助工具方法。闲言少叙，直接上代码：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="java">&lt;span class="cm">/**
 * 创建 Hessian2Output 对象，以便用于序列化
 *
 * @author D瓜哥 · &lt;a href="https://www.diguage.com/" target="_blank">https://www.diguage.com/&lt;/a>
 */&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="nc">Hessian2Output&lt;/span> &lt;span class="nf">getHessian2Output&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">OutputStream&lt;/span> &lt;span class="n">stream&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">SerializerFactory&lt;/span> &lt;span class="n">serializerFactory&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">SerializerFactory&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="n">serializerFactory&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setAllowNonSerializable&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="nc">Hessian2Output&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">Hessian2Output&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">stream&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">result&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setSerializerFactory&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">serializerFactory&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>

&lt;span class="cm">/**
 * 打印字节数组
 *
 * @author D瓜哥 · &lt;a href="https://www.diguage.com/" target="_blank">https://www.diguage.com/&lt;/a>
 */&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">printBytes&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">byte&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">String&lt;/span> &lt;span class="n">bitx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nc">Integer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">toBinaryString&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">Byte&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">toUnsignedInt&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="o">));&lt;/span>
 &lt;span class="nc">String&lt;/span> &lt;span class="n">zbits&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nc">String&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">format&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;%8s&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">bitx&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">replace&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="sc">&amp;#39; &amp;#39;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="sc">&amp;#39;0&amp;#39;&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;%4d 0x%02X %8s %c %n&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">zbits&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;%4d 0x%02X %8s %n&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">zbits&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>

&lt;span class="cm">/**
 * 将 long 转化成二进制字符串（前面补0）
 *
 * @author D瓜哥 · &lt;a href="https://www.diguage.com/" target="_blank">https://www.diguage.com/&lt;/a>
 */&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="nc">String&lt;/span> &lt;span class="nf">getBinaryString&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">long&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">String&lt;/span> &lt;span class="n">bits&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nc">Long&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">toBinaryString&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="kt">char&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">chars&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nc">String&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">format&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;%64s&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">bits&lt;/span>&lt;span class="o">)&lt;/span>
 &lt;span class="o">.&lt;/span>&lt;span class="na">replace&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="sc">&amp;#39; &amp;#39;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="sc">&amp;#39;0&amp;#39;&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">toCharArray&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="nc">StringBuilder&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">StringBuilder&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">64&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">chars&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">result&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">append&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">chars&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]);&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="mi">8&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">7&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">chars&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">result&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">append&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;,&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">toString&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>

&lt;span class="cm">/**
 * 将 int 转化成二进制字符串（前面补0）
 *
 * @author D瓜哥 · &lt;a href="https://www.diguage.com/" target="_blank">https://www.diguage.com/&lt;/a>
 */&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="nc">String&lt;/span> &lt;span class="nf">getBinaryString&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">String&lt;/span> &lt;span class="n">bits&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nc">Integer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">toBinaryString&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="kt">char&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">chars&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nc">String&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">format&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;%32s&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">bits&lt;/span>&lt;span class="o">)&lt;/span>
 &lt;span class="o">.&lt;/span>&lt;span class="na">replace&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="sc">&amp;#39; &amp;#39;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="sc">&amp;#39;0&amp;#39;&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">toCharArray&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="nc">StringBuilder&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">StringBuilder&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">64&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">chars&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">result&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">append&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">chars&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]);&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="mi">8&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">7&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">chars&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">result&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">append&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;,&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">toString&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div></description></item><item><title>Hessian 2.0 序列化协议（中文版）</title><link>https://www.diguage.com/post/hessian-serialization-protocol/</link><pubDate>Wed, 20 Apr 2022 17:30:08 +0800</pubDate><guid>https://www.diguage.com/post/hessian-serialization-protocol/</guid><description>&lt;div class="paragraph">
&lt;p>公司在微服务系统中，序列化协议大多数使用 &lt;a href="https://msgpack.org/" target="_blank" rel="noopener">MessagePack&lt;/a>。但是，由于 MessagePack 设计限制，导致微服务接口在增减参数时，只能在最后操作。但是，由于个人操作，难免失误，结果造成因为增减字段导致的事故层出不穷。最近，一些条件成熟，准备推动部门将序列化协议切换到 Hessian。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>原以为，切换到 Hessian 就可以万事大吉。但是，在和同事的沟通中发现，同事反馈，Hessian 本身也有一些限制。为了对 Hessian 有一个更深入的了解，干脆就把 Hessian 序列化协议读一遍。看协议，文字不多，干脆就把协议完整翻译一遍。闲言少叙，正文开始。&lt;/p>
&lt;/div>
&lt;hr/>
&lt;div class="sect1 text-center">
&lt;h2 id="_hessian_2_0_序列化协议">&lt;span class="big">&lt;strong>Hessian 2.0 序列化协议&lt;/strong>&lt;/span>&lt;/h2>
&lt;div class="sectionbody">

&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_协议解释">协议解释&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>针对该协议有很多言语不详，甚至模糊不清之处，专门做了一些解释和实践，叙述系列文章，用于辅助消化理解。目录如下：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a> — Hessian 序列化协议的中文翻译版。根据后面的“协议解释与实战”系列文章，增加了协议内容错误提示。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/" target="_blank" rel="noopener">Hessian 协议解释与实战（一）：布尔、日期、浮点数与整数&lt;/a> — 介绍布尔型数据、日期类型、浮点类型数据和整数类型数据等四种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-2/" target="_blank" rel="noopener">Hessian 协议解释与实战（二）：长整型、二进制数据与 Null&lt;/a> — 介绍长整数类型数据、二进制数据和 &lt;code>null&lt;/code> 等三种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-3/" target="_blank" rel="noopener">Hessian 协议解释与实战（三）：字符串&lt;/a> — 专门介绍了关于字符串的处理。由于字符串需要铺垫的基础知识比较多，处理细节也有繁琐，所以单独成篇来介绍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-source-analysis-for-java/" target="_blank" rel="noopener">Hessian 源码分析（Java）&lt;/a> — 开始第四篇分析之前，先来介绍一下 Hessian 的源码实现。方便后续展开说明。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-4/" target="_blank" rel="noopener">Hessian 协议解释与实战（四）：数组与集合&lt;/a> — 铺垫了一些关于实例对象的处理，重点介绍关于数组和集合的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-5/" target="_blank" rel="noopener">Hessian 协议解释与实战（五）：对象与映射&lt;/a> — 重点介绍关于对象与映射的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-vs-msgpack-vs-json/" target="_blank" rel="noopener">Hessian、Msgpack 和 JSON 实例对比&lt;/a> — 用实例对比 JSON、Hessian 和 MessagePack 的区别。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/schema-evolution-in-avro-protobuf-thrift" target="_blank" rel="noopener">Avro、ProtoBuf、Thrift 的模式演进之路&lt;/a> — 翻译的 Martin Kleppmann 的文章，重点对比了 Avro、ProtoBuf、Thrift 的序列化处理思路。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>从 Spring PR 中学习代码技巧</title><link>https://www.diguage.com/post/learn-code-tips-from-spring-pull-requests/</link><pubDate>Sun, 27 Jun 2021 18:20:28 +0800</pubDate><guid>https://www.diguage.com/post/learn-code-tips-from-spring-pull-requests/</guid><description>&lt;div class="paragraph">
&lt;p>D瓜哥经常关注 Spring 的 PR 与 Issue。在众多 Contributor 中，除了 Spring 团队成员之外，我对 &lt;a href="https://github.com/stsypanov" target="_blank" rel="noopener">stsypanov (Сергей Цыпанов)&lt;/a> 印象很深刻。这哥们给 Spring 提了非常多的 PR，请看列表 &lt;a href="https://github.com/spring-projects/spring-framework/pulls?page=1&amp;amp;q=author%3Astsypanov+is%3Aclosed" target="_blank" rel="noopener">Pull requests · spring-projects/spring-framework&lt;/a>，而且这个哥们的 PR 都非常有特点，绝大部分是性能提升方面的 PR，而且还会给出 JMH 的测试结果。不愧是毛熊人，做事细致严谨。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>这周心血来潮，把这哥们的 PR 翻一翻，希望可以学习一些编码技巧。简单记录一下，以备以后回顾学习。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_提高_map_的遍历性能">提高 &lt;code>Map&lt;/code> 的遍历性能&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>请看： &lt;a href="https://github.com/spring-projects/spring-framework/pull/1891/files" target="_blank" rel="noopener">SPR-17074 Replace iteration over Map::keySet with Map::entrySet by stsypanov · Pull Request #1891&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>摘取一个示例如下：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="java">&lt;span class="c1">// --before update------------------------------------------------------&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="nc">String&lt;/span> &lt;span class="n">attributeName&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">attributes&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">keySet&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">Object&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">attributes&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">attributeName&lt;/span>&lt;span class="o">);&lt;/span>

&lt;span class="c1">// --after update-------------------------------------------------------&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="nc">Map&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">Entry&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nc">String&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="nc">Object&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">attributeEntry&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">attributes&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">entrySet&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">String&lt;/span> &lt;span class="n">attributeName&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">attributeEntry&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getKey&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="nc">Object&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">attributeEntry&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getValue&lt;/span>&lt;span class="o">();&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>这个改动很小，但是对性能的改善还是比较显著的。翻看自己项目的代码，还是有不少是改动前的写法。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>针对这点，D瓜哥也给 Spring 发了一个 PR： &lt;a href="https://github.com/spring-projects/spring-framework/pull/27100" target="_blank" rel="noopener">Improve performance of iteration in GroovyBeanDefinitionReader by diguage · Pull Request #27100&lt;/a>。相信不久就会合并到 &lt;code>main&lt;/code> 分支的。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>所以，给 Spring 以及其他开源项目提 PR，其实一点也不难。只要，你花心思去研究，肯定有机会的。不过，也反思一点：我这个 PR 有点东施效颦的感觉，有点刷 KPI 的样子。还是应该脚踏实地去好好研究，提更多更有建设性意见的 PR。&lt;/p>
&lt;/div></description></item><item><title>Spring AOP 源码分析：创建代理（二）</title><link>https://www.diguage.com/post/spring-aop-create-proxy-cglib/</link><pubDate>Tue, 11 Aug 2020 15:00:46 +0800</pubDate><guid>https://www.diguage.com/post/spring-aop-create-proxy-cglib/</guid><description>&lt;div class="paragraph">
&lt;p>&lt;a href="https://www.diguage.com/post/spring-aop-bootstrap/">Spring AOP 源码分析：入门&lt;/a> 中，梳理出来了 Spring AOP 的入口。 &lt;a href="https://www.diguage.com/post/spring-aop-get-advices/">Spring AOP 源码分析：获得通知&lt;/a> 中着重介绍了如何获取通知。上一篇文章 &lt;a href="https://www.diguage.com/post/spring-aop-create-proxy-jdk/">Spring AOP 源码分析：创建代理（一）&lt;/a> 重点介绍了一下切面链的组装和基于 JDK 动态代理的 AOP 的实现，这篇文章介绍一下基于 cglib 的代理类是生成。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_cglib_简介">cglib 简介&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/spring-framework/cglib.png" alt="CGLIB" width="95%"/>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>CGLIB（Code Generator Library）是一个高性能的代码生成库，被广泛应用于 AOP 框架（Spring）中以提供方法拦截功能，主要以继承目标类的方式来进行拦截实现，因此 CGLIB 可以对无接口的类进行代理。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>CGLIB代理主要通过操作字节码的方式为对象引入方法调用时访问操作，底层使用了ASM来操作字节码生成新的类，ASM是一个短小精悍的字节码操作框架。CGLIB的应用栈如下：&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/spring-framework/cglib-architecture.jpg" alt="CGLIB" width="95%"/>
&lt;/div>
&lt;/div>
&lt;div class="sidebarblock">
&lt;div class="content">
&lt;div class="paragraph">
&lt;p>最新版的 Hibernate 已经把字节码库从 cglib 切换为 Byte Buddy。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>JDK 动态代理是通过实现 &lt;code>InvocationHandler&lt;/code> 接口，在其 &lt;code>invoke&lt;/code> 方法中添加切面逻辑。而 cglib 则是通过实现 &lt;code>MethodInterceptor&lt;/code> 接口，在其 &lt;code>invoke&lt;/code> 方法中添加切面逻辑。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>下面看一下在 Spring 中，是如何实现利用 cglib 来实现 AOP 编程的？&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_cglibaopproxy">&lt;code>CglibAopProxy&lt;/code>&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>先看一下创建代理对象的方法：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="title">&lt;code>CglibAopProxy#getProxy(ClassLoader)&lt;/code>&lt;/div>
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="java">&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="nc">Object&lt;/span> &lt;span class="nf">getProxy&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@Nullable&lt;/span> &lt;span class="nc">ClassLoader&lt;/span> &lt;span class="n">classLoader&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">logger&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isTraceEnabled&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">logger&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">trace&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Creating CGLIB proxy: &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">advised&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getTargetSource&lt;/span>&lt;span class="o">());&lt;/span>
 &lt;span class="o">}&lt;/span>

 &lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">Class&lt;/span>&lt;span class="o">&amp;lt;?&amp;gt;&lt;/span> &lt;span class="n">rootClass&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">advised&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getTargetClass&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="nc">Assert&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">state&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">rootClass&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;Target class must be available for creating a CGLIB proxy&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>

 &lt;span class="nc">Class&lt;/span>&lt;span class="o">&amp;lt;?&amp;gt;&lt;/span> &lt;span class="n">proxySuperClass&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">rootClass&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">rootClass&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">contains&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">ClassUtils&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">CGLIB_CLASS_SEPARATOR&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">proxySuperClass&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">rootClass&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getSuperclass&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="nc">Class&lt;/span>&lt;span class="o">&amp;lt;?&amp;gt;[]&lt;/span> &lt;span class="n">additionalInterfaces&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">rootClass&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getInterfaces&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="nc">Class&lt;/span>&lt;span class="o">&amp;lt;?&amp;gt;&lt;/span> &lt;span class="n">additionalInterface&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">additionalInterfaces&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">advised&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">addInterface&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">additionalInterface&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="o">}&lt;/span>

 &lt;span class="c1">// Validate the class, writing log messages as necessary.&lt;/span>
 &lt;span class="c1">// 验证 Class&lt;/span>
 &lt;span class="n">validateClassIfNecessary&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">proxySuperClass&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">classLoader&lt;/span>&lt;span class="o">);&lt;/span>

 &lt;span class="c1">// Configure CGLIB Enhancer...&lt;/span>
 &lt;span class="nc">Enhancer&lt;/span> &lt;span class="n">enhancer&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">createEnhancer&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">classLoader&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">enhancer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setClassLoader&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">classLoader&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">classLoader&lt;/span> &lt;span class="k">instanceof&lt;/span> &lt;span class="nc">SmartClassLoader&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span>
 &lt;span class="o">((&lt;/span>&lt;span class="nc">SmartClassLoader&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="n">classLoader&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">isClassReloadable&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">proxySuperClass&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">enhancer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setUseCache&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="n">enhancer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setSuperclass&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">proxySuperClass&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">enhancer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setInterfaces&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">AopProxyUtils&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">completeProxiedInterfaces&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">advised&lt;/span>&lt;span class="o">));&lt;/span>
 &lt;span class="n">enhancer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setNamingPolicy&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">SpringNamingPolicy&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">INSTANCE&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">enhancer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setStrategy&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="nc">ClassLoaderAwareGeneratorStrategy&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">classLoader&lt;/span>&lt;span class="o">));&lt;/span>

 &lt;span class="c1">// 设置拦截器&lt;/span>
&lt;span class="hll"> &lt;span class="nc">Callback&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">callbacks&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">getCallbacks&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">rootClass&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span> &lt;span class="nc">Class&lt;/span>&lt;span class="o">&amp;lt;?&amp;gt;[]&lt;/span> &lt;span class="n">types&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">Class&lt;/span>&lt;span class="o">&amp;lt;?&amp;gt;[&lt;/span>&lt;span class="n">callbacks&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">];&lt;/span>
 &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">types&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">types&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">callbacks&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">].&lt;/span>&lt;span class="na">getClass&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="c1">// fixedInterceptorMap only populated at this point, after getCallbacks call above&lt;/span>
 &lt;span class="n">enhancer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setCallbackFilter&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">new&lt;/span> &lt;span class="nc">ProxyCallbackFilter&lt;/span>&lt;span class="o">(&lt;/span>
 &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">advised&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getConfigurationOnlyCopy&lt;/span>&lt;span class="o">(),&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">fixedInterceptorMap&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">fixedInterceptorOffset&lt;/span>&lt;span class="o">));&lt;/span>
 &lt;span class="n">enhancer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setCallbackTypes&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">types&lt;/span>&lt;span class="o">);&lt;/span>

 &lt;span class="c1">// Generate the proxy class and create a proxy instance.&lt;/span>
 &lt;span class="c1">// 生成代理类以及创建代理&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="nf">createProxyClassAndInstance&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">enhancer&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">callbacks&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="nc">CodeGenerationException&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="nc">IllegalArgumentException&lt;/span> &lt;span class="n">ex&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nf">AopConfigException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Could not generate CGLIB subclass of &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">advised&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getTargetClass&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">+&lt;/span>
 &lt;span class="s">&amp;#34;: Common causes of this problem include using a final class or a non-visible class&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span>
 &lt;span class="n">ex&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="nc">Throwable&lt;/span> &lt;span class="n">ex&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// TargetSource.getTarget() failed&lt;/span>
 &lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nf">AopConfigException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Unexpected AOP exception&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">ex&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div></description></item><item><title>Spring AOP 源码分析：创建代理（一）</title><link>https://www.diguage.com/post/spring-aop-create-proxy-jdk/</link><pubDate>Mon, 10 Aug 2020 14:10:00 +0800</pubDate><guid>https://www.diguage.com/post/spring-aop-create-proxy-jdk/</guid><description>&lt;div class="paragraph">
&lt;p>&lt;a href="https://www.diguage.com/post/spring-aop-bootstrap/">Spring AOP 源码分析：入门&lt;/a> 中，梳理出来了 Spring AOP 的入口。上一篇文章 &lt;a href="https://www.diguage.com/post/spring-aop-get-advices/">Spring AOP 源码分析：获得通知&lt;/a> 中着重介绍了如何获取通知。接着上一篇文章，这篇文章介绍一下如何创建代理。&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="title">&lt;code>AbstractAutoProxyCreator#createProxy&lt;/code>&lt;/div>
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="java">&lt;span class="kd">protected&lt;/span> &lt;span class="nc">Object&lt;/span> &lt;span class="nf">createProxy&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">Class&lt;/span>&lt;span class="o">&amp;lt;?&amp;gt;&lt;/span> &lt;span class="n">beanClass&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="nd">@Nullable&lt;/span> &lt;span class="nc">String&lt;/span> &lt;span class="n">beanName&lt;/span>&lt;span class="o">,&lt;/span>
 &lt;span class="nd">@Nullable&lt;/span> &lt;span class="nc">Object&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">specificInterceptors&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="nc">TargetSource&lt;/span> &lt;span class="n">targetSource&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>

 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">beanFactory&lt;/span> &lt;span class="k">instanceof&lt;/span> &lt;span class="nc">ConfigurableListableBeanFactory&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">AutoProxyUtils&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">exposeTargetClass&lt;/span>&lt;span class="o">((&lt;/span>&lt;span class="nc">ConfigurableListableBeanFactory&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">beanFactory&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">beanName&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">beanClass&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>


 &lt;span class="c1">// 创建代理工厂对象&lt;/span>
 &lt;span class="nc">ProxyFactory&lt;/span> &lt;span class="n">proxyFactory&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">ProxyFactory&lt;/span>&lt;span class="o">();&lt;/span>

 &lt;span class="c1">// 获取当前类的属性&lt;/span>
 &lt;span class="n">proxyFactory&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">copyFrom&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">);&lt;/span>

 &lt;span class="c1">//如果没有使用CGLib代理&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(!&lt;/span>&lt;span class="n">proxyFactory&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isProxyTargetClass&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 是否可能使用CGLib代理&lt;/span>
 &lt;span class="c1">// 决定对于给定的 Bean 是否应该使用 targetClass 而不是他的接口代理&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">shouldProxyTargetClass&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">beanClass&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">beanName&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">proxyFactory&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setProxyTargetClass&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 查看beanClass对应的类是否含有InitializingBean.class/DisposableBean.class/Aware.class接口&lt;/span>
 &lt;span class="c1">// 无则采用JDK动态代理，有则采用CGLib动态代理&lt;/span>
 &lt;span class="n">evaluateProxyInterfaces&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">beanClass&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">proxyFactory&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="o">}&lt;/span>

 &lt;span class="c1">// 获得所有关联的Advisor集合(该分支待补充)&lt;/span>
 &lt;span class="nc">Advisor&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">advisors&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">buildAdvisors&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">beanName&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">specificInterceptors&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">proxyFactory&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">addAdvisors&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">advisors&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="c1">// 此处的targetSource一般为SingletonTargetSource&lt;/span>
 &lt;span class="n">proxyFactory&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setTargetSource&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">targetSource&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="c1">// 定制代理，扩展点，空实现&lt;/span>
 &lt;span class="n">customizeProxyFactory&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">proxyFactory&lt;/span>&lt;span class="o">);&lt;/span>

 &lt;span class="c1">// 用来控制代理工厂被配置后，是否还允许修改通知&lt;/span>
 &lt;span class="c1">// 缺省为 false&lt;/span>
 &lt;span class="n">proxyFactory&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setFrozen&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">freezeProxy&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="c1">// 是否设置预过滤模式，此处针对本文为true&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">advisorsPreFiltered&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">proxyFactory&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setPreFiltered&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>

 &lt;span class="c1">// 获取使用JDK动态代理或者cglib动态代理产生的对象&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="n">proxyFactory&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getProxy&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">getProxyClassLoader&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="title">&lt;code>ProxyFactory#getProxy(ClassLoader)&lt;/code>&lt;/div>
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="java">&lt;span class="kd">public&lt;/span> &lt;span class="nc">Object&lt;/span> &lt;span class="nf">getProxy&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@Nullable&lt;/span> &lt;span class="nc">ClassLoader&lt;/span> &lt;span class="n">classLoader&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 1、创建JDK方式的AOP代理或者CGLib方式的AOP代理&lt;/span>
 &lt;span class="c1">// 2、调用具体的AopProxy来创建Proxy代理对象&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="nf">createAopProxy&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getProxy&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">classLoader&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>在 &lt;code>createAopProxy()&lt;/code> 方法中就不再列出，因为 &lt;code>AopProxyFactory&lt;/code> 接口只有一个实现类 &lt;code>DefaultAopProxyFactory&lt;/code>。所以，直接来看看 &lt;code>getProxy(classLoader)&lt;/code> 方法：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="title">&lt;code>DefaultAopProxyFactory#createAopProxy&lt;/code>&lt;/div>
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="java">&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="nc">AopProxy&lt;/span> &lt;span class="nf">createAopProxy&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">AdvisedSupport&lt;/span> &lt;span class="n">config&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="nc">AopConfigException&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 如果实现接口，默认采用Java动态代理&lt;/span>
 &lt;span class="c1">// 如果没有接口，或者有接口却强制使用 cglib&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(!&lt;/span>&lt;span class="no">IN_NATIVE_IMAGE&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span>
 &lt;span class="c1">// optimize 是否实用激进的优化策略&lt;/span>
 &lt;span class="c1">// proxyTargetClass 为 true，则代理类本身而不是接口&lt;/span>
 &lt;span class="c1">// 是否存在代理接口&lt;/span>
 &lt;span class="o">(&lt;/span>&lt;span class="n">config&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isOptimize&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">config&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isProxyTargetClass&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">hasNoUserSuppliedProxyInterfaces&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">config&lt;/span>&lt;span class="o">)))&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">Class&lt;/span>&lt;span class="o">&amp;lt;?&amp;gt;&lt;/span> &lt;span class="n">targetClass&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">config&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getTargetClass&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">targetClass&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nf">AopConfigException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;TargetSource cannot determine target class: &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span>
 &lt;span class="s">&amp;#34;Either an interface or a target is required for proxy creation.&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">targetClass&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isInterface&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="nc">Proxy&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isProxyClass&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">targetClass&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nf">JdkDynamicAopProxy&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">config&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nf">ObjenesisCglibAopProxy&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">config&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nf">JdkDynamicAopProxy&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">config&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div></description></item><item><title>Spring AOP 源码分析：获得通知</title><link>https://www.diguage.com/post/spring-aop-get-advices/</link><pubDate>Sun, 09 Aug 2020 15:46:50 +0800</pubDate><guid>https://www.diguage.com/post/spring-aop-get-advices/</guid><description>&lt;div class="paragraph">
&lt;p>在文章 &lt;a href="https://www.diguage.com/post/spring-aop-process-overview/" target="_blank" rel="noopener">Spring AOP 处理流程概述&lt;/a> 中，对 Spring AOP 有了一个整体认识。在文章 &lt;a href="https://www.diguage.com/post/spring-aop-bootstrap/">Spring AOP 源码分析：入门&lt;/a> 中，对 Spring AOP 的相关入口做了分析。这篇文章就带大家看一看，Spring AOP 是如何获取通知的？&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="example-code">示例代码&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>在 &lt;a href="https://www.diguage.com/post/how-to-read-spring-sources/#example-code" target="_blank" rel="noopener">如何阅读 Spring 源码？: 示例代码&lt;/a> 中，已经给出了一个完整的 AOP 示例代码。为了节省篇幅，请直接参考那篇文章的示例代码，这里就不在赘述。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_注册_advice通知增强">注册 Advice(通知/增强)&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>请根据 &lt;a href="https://www.diguage.com/post/spring-aop-bootstrap/">Spring AOP 源码分析：入门&lt;/a> 中提到的关键方法入口处，打上断点，开始调试。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>首先，需要明确一点的是：对于切面（使用 &lt;code>@Aspect&lt;/code> 注解标注过的类）在 Spring 容器中，也是被统一f封装为 &lt;code>BeanDefinition&lt;/code> 实例的，也需要通过一个方式，将其注册到 Spring 容器中。比如，就像 &lt;a href="#example-code">示例代码&lt;/a> 那样，通过 &lt;code>ImportSelector&lt;/code> 方式，使用类名，将其注册到容器中。这样，就可以利用 Spring 容器对 Bean 的 API 来统一处理了。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Advice(通知/增强)几乎是在意想不到的地方完成注册的：在第一次调用 &lt;code>AbstractAutoProxyCreator#postProcessBeforeInstantiation&lt;/code> 方法时，通过 &lt;code>AspectJAwareAdvisorAutoProxyCreator#shouldSkip&lt;/code> 方法，完成了切面的注册。下面，我们对这个过程抽丝剥茧，逐步分析。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>先来看看 &lt;code>findCandidateAdvisors&lt;/code> 方法：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="title">&lt;code>AnnotationAwareAspectJAutoProxyCreator#findCandidateAdvisors&lt;/code>&lt;/div>
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="java">&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">protected&lt;/span> &lt;span class="nc">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nc">Advisor&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">findCandidateAdvisors&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// Add all the Spring advisors found according to superclass rules.&lt;/span>
 &lt;span class="c1">//当使用注解方式配置AOP的时候并不是丢弃了对XML配置的支持&lt;/span>
 &lt;span class="c1">//在这里调用父类方法加载配置文件中的AOP声明&lt;/span>
 &lt;span class="nc">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nc">Advisor&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">advisors&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kd">super&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">findCandidateAdvisors&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="c1">// Build Advisors for all AspectJ aspects in the bean factory.&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">aspectJAdvisorsBuilder&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">advisors&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">addAll&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">aspectJAdvisorsBuilder&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">buildAspectJAdvisors&lt;/span>&lt;span class="o">());&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="n">advisors&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div></description></item><item><title>Spring AOP 源码分析：入门</title><link>https://www.diguage.com/post/spring-aop-bootstrap/</link><pubDate>Fri, 07 Aug 2020 00:00:00 +0800</pubDate><guid>https://www.diguage.com/post/spring-aop-bootstrap/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/spring-aop-process-overview/" target="_blank" rel="noopener">Spring AOP 处理流程概述&lt;/a> 中，对 Spring AOP 有了一个整体认识。这篇文章就带大家做一个细致的源码分析。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_登堂入室">登堂入室&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>使用 Spring AOP 也很简单，只需要在配置类上加上 &lt;code>@EnableAspectJAutoProxy&lt;/code> 注解即可。这个注解处理过程与 &lt;a href="https://www.diguage.com/post/spring-extensions-and-mybatis/#mapper-scan" target="_blank" rel="noopener">Spring 扩展点实践：整合 MyBATIS&lt;/a> 中 “&lt;code>@MapperScan&lt;/code> 处理” 类似，不同的是，Spring AOP 注册了 &lt;code>AnnotationAwareAspectJAutoProxyCreator&lt;/code>，它是一个 &lt;code>InstantiationAwareBeanPostProcessor&lt;/code>。具体的类图如下：&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/spring-framework/AnnotationAwareAspectJAutoProxyCreator.svg" alt="AnnotationAwareAspectJAutoProxyCreator 的继承体系" width="98%"/>
&lt;/div>
&lt;div class="title">图 1. AnnotationAwareAspectJAutoProxyCreator 的继承体系&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>在正式开始源码分析之前，有一点必须强调一下：&lt;strong>Spring AOP 只是借用了 AspectJ 的一些注解和个别关键 API，而整体实现是 Spring 自己完成的，并不是基于 AspectJ 实现的。&lt;/strong>这一点跟很多人的认识是不一样的，需要特别指出。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>D瓜哥在 &lt;a href="https://www.diguage.com/post/spring-bean-lifecycle-overview/" target="_blank" rel="noopener">Spring Bean 生命周期概述&lt;/a> 中指出：创建 AOP 代理对象，有两个时机：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>调用 &lt;code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation&lt;/code> 时，通过调用 &lt;code>AnnotationAwareAspectJAutoProxyCreator&lt;/code> 对象的 &lt;code>postProcessBeforeInstantiation&lt;/code> 方法来创建对象；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用 &lt;code>BeanPostProcessor#postProcessAfterInitialization&lt;/code> 时，通过调用 &lt;code>AnnotationAwareAspectJAutoProxyCreator&lt;/code> 对象的 &lt;code>postProcessAfterInitialization&lt;/code> 方法来创建对象；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>下面分别对这两个方法做更详细的介绍。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_annotationawareaspectjautoproxycreatorpostprocessbeforeinstantiation">&lt;code>AnnotationAwareAspectJAutoProxyCreator#postProcessBeforeInstantiation&lt;/code>&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;code>AnnotationAwareAspectJAutoProxyCreator&lt;/code> 的 &lt;code>postProcessBeforeInstantiation&lt;/code> 方法是从 &lt;code>AbstractAutoProxyCreator&lt;/code> 继承过来的。代码如下：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="java">&lt;span class="nd">@Override&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="nc">Object&lt;/span> &lt;span class="nf">postProcessBeforeInstantiation&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">Class&lt;/span>&lt;span class="o">&amp;lt;?&amp;gt;&lt;/span> &lt;span class="n">beanClass&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="nc">String&lt;/span> &lt;span class="n">beanName&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 1、得到一个缓存的唯一key（根据beanClass和beanName生成唯一key）&lt;/span>
 &lt;span class="nc">Object&lt;/span> &lt;span class="n">cacheKey&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">getCacheKey&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">beanClass&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">beanName&lt;/span>&lt;span class="o">);&lt;/span>

 &lt;span class="c1">// 2、如果当前targetSourcedBeans（通过自定义TargetSourceCreator创建的TargetSource）不包含cacheKey&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(!&lt;/span>&lt;span class="nc">StringUtils&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">hasLength&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">beanName&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">targetSourcedBeans&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">contains&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">beanName&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 2.1、advisedBeans（已经被增强的Bean，即AOP代理对象）中包含当前cacheKey，返回null，即走Spring默认流程&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">advisedBeans&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">containsKey&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">cacheKey&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="c1">// 2.2、如果是基础设施类（如Advisor、Advice、AopInfrastructureBean的实现）不进行处理&lt;/span>
 &lt;span class="c1">// 2.2、shouldSkip 默认false，可以生成子类覆盖，如AspectJAwareAdvisorAutoProxyCreator覆盖（if (((AbstractAspectJAdvice) advisor.getAdvice()).getAspectName().equals(beanName)) return true; 即如果是自己就跳过）&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">isInfrastructureClass&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">beanClass&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">shouldSkip&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">beanClass&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">beanName&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">advisedBeans&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">put&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">cacheKey&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="nc">Boolean&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">FALSE&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="o">}&lt;/span>

 &lt;span class="c1">// Create proxy here if we have a custom TargetSource.&lt;/span>
 &lt;span class="c1">// Suppresses unnecessary default instantiation of the target bean:&lt;/span>
 &lt;span class="c1">// The TargetSource will handle target instances in a custom fashion.&lt;/span>
 &lt;span class="c1">// 3、开始创建AOP代理对象&lt;/span>
 &lt;span class="c1">// 3.1、配置自定义的TargetSourceCreator进行TargetSource创建&lt;/span>
 &lt;span class="nc">TargetSource&lt;/span> &lt;span class="n">targetSource&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">getCustomTargetSource&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">beanClass&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">beanName&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="c1">// 3.2、如果targetSource不为null 添加到targetSourcedBeans缓存，并创建AOP代理对象&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">targetSource&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="nc">StringUtils&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">hasLength&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">beanName&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">targetSourcedBeans&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">beanName&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="c1">// specificInterceptors即增强（包括前置增强、后置增强等等）&lt;/span>
&lt;span class="hll"> &lt;span class="nc">Object&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">specificInterceptors&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">getAdvicesAndAdvisorsForBean&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">beanClass&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">beanName&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">targetSource&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span> &lt;span class="c1">//3.3、创建代理对象&lt;/span>
&lt;span class="hll"> &lt;span class="nc">Object&lt;/span> &lt;span class="n">proxy&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">createProxy&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">beanClass&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">beanName&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">specificInterceptors&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">targetSource&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span> &lt;span class="c1">//3.4、将代理类型放入proxyTypes从而允许后续的predictBeanType()调用获取&lt;/span>
 &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">proxyTypes&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">put&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">cacheKey&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">proxy&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getClass&lt;/span>&lt;span class="o">());&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="n">proxy&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>

 &lt;span class="k">return&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div></description></item><item><title>TCP 三次握手和四次挥手</title><link>https://www.diguage.com/post/tcp-3-way-handshake-and-4-way-handshake/</link><pubDate>Mon, 03 Aug 2020 00:57:26 +0800</pubDate><guid>https://www.diguage.com/post/tcp-3-way-handshake-and-4-way-handshake/</guid><description>&lt;div class="paragraph">
&lt;p>传输控制协议（英语：Transmission Control Protocol，缩写：TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。在简化的计算机网络 OSI 模型中，它完成第四层传输层所指定的功能。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>毫不夸张地说，TCP 协议是目前整个互联网的基础。它解决了一系列的网络问题。带来的结果，就是协议本身非常复杂。考虑到文章篇幅问题，本文着重说明 TCP 建立连接时的三次握手过程和关闭连接时的四次挥手过程。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_三次握手">三次握手&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/tcp/tcp-connection-made-three-way-handshake.png" alt="TCP 三次握手" width="95%"/>
&lt;/div>
&lt;div class="title">图 1. TCP 三次握手&lt;/div>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>第一次握手(&lt;code>SYN=1&lt;/code>, &lt;code>seq=x&lt;/code>):&lt;/p>
&lt;div class="paragraph">
&lt;p>客户端发送一个 TCP 的 &lt;code>SYN&lt;/code> 标志位置 &lt;code>1&lt;/code> 的包，指明客户端打算连接的服务器的端口，以及初始序号 &lt;code>x&lt;/code>，保存在包头的序列号(&lt;code>Sequence Number&lt;/code>)字段里。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>发送完毕后，客户端进入 &lt;code>SYN_SEND&lt;/code> 状态。&lt;/p>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>第二次握手(&lt;code>SYN=1&lt;/code>、&lt;code>seq=y&lt;/code>；&lt;code>ACK=1&lt;/code>、&lt;code>ACKnum=x+1&lt;/code>):&lt;/p>
&lt;div class="paragraph">
&lt;p>服务器发回确认包(&lt;code>ACK&lt;/code>)应答。即 &lt;code>SYN&lt;/code> 标志位和 &lt;code>ACK&lt;/code> 标志位均为 &lt;code>1&lt;/code>。服务器端选择自己 &lt;code>ISN&lt;/code> 序列号，放到包头的序列号(&lt;code>Sequence Number&lt;/code>)字段里，同时将确认序号(&lt;code>Acknowledgement Number&lt;/code>)设置为客户的 &lt;code>ISN&lt;/code> 加 &lt;code>1&lt;/code>，即 &lt;code>x+1&lt;/code>。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>发送完毕后，服务器端进入 &lt;code>SYN_RCVD&lt;/code> 状态。&lt;/p>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>第三次握手(&lt;code>ACK=1&lt;/code>，&lt;code>ACKnum=y+1&lt;/code>)&lt;/p>
&lt;div class="paragraph">
&lt;p>客户端再次发送确认包(&lt;code>ACK&lt;/code>)，SYN 标志位为 &lt;code>0&lt;/code>，&lt;code>ACK&lt;/code> 标志位为 &lt;code>1&lt;/code>，并且把服务器发来 &lt;code>ISN&lt;/code> 的序号字段+1，放在确定字段中发送给对方，即数据段放写 &lt;code>y+1&lt;/code>。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>发送完毕后，客户端进入 &lt;code>ESTABLISHED&lt;/code> 状态，当服务器端接收到这个包时，也进入 &lt;code>ESTABLISHED&lt;/code> 状态，TCP 握手结束。&lt;/p>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_syn_flood_攻击">SYN Flood 攻击&lt;/h3>
&lt;div class="paragraph">
&lt;p>在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 &lt;code>SYN_RCVD&lt;/code> 状态。当收到 ACK 后，服务器才能转入 &lt;code>ESTABLISHED&lt;/code> 状态.&lt;/p>
&lt;/div></description></item><item><title>源码剖析 Spring 循环依赖</title><link>https://www.diguage.com/post/spring-circular-dependence/</link><pubDate>Fri, 31 Jul 2020 18:33:30 +0800</pubDate><guid>https://www.diguage.com/post/spring-circular-dependence/</guid><description>&lt;div class="paragraph">
&lt;p>循环依赖在编程中是一个常见问题（当然，这并不是最佳实践）。并且，Spring 如何解决循环依赖这个问题在面试中也经常见。下面，D瓜哥就从源码的层面深入剖析一下这个问题。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_示例程序">示例程序&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>先展示一下示例程序：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="rouge highlight">&lt;code data-lang="java">&lt;span class="kn">package&lt;/span> &lt;span class="nn">com.diguage.truman.context&lt;/span>&lt;span class="o">;&lt;/span>

&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.apache.commons.logging.Log&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.apache.commons.logging.LogFactory&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.junit.jupiter.api.Test&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.springframework.beans.factory.annotation.Autowired&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.springframework.context.annotation.AnnotationConfigApplicationContext&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.springframework.context.annotation.Configuration&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.springframework.context.annotation.Import&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.springframework.context.annotation.ImportSelector&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.springframework.core.type.AnnotationMetadata&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.springframework.stereotype.Component&lt;/span>&lt;span class="o">;&lt;/span>

&lt;span class="cm">/**
 * @author D瓜哥, &lt;a href="https://www.diguage.com/" target="_blank">https://www.diguage.com/&lt;/a>
 * @since 2020-05-24 13:02
 */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">CircularDependenceSingletonTest&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="nc">Log&lt;/span> &lt;span class="n">log&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nc">LogFactory&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getLog&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">CircularDependenceSingletonTest&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">);&lt;/span>

 &lt;span class="nd">@Test&lt;/span>
 &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">test&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">AnnotationConfigApplicationContext&lt;/span> &lt;span class="n">applicationContext&lt;/span>
 &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">AnnotationConfigApplicationContext&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="n">applicationContext&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">register&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">Config&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">applicationContext&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">refresh&lt;/span>&lt;span class="o">();&lt;/span>

 &lt;span class="n">log&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">info&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">applicationContext&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getBean&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="no">A&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">));&lt;/span>
 &lt;span class="n">log&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">info&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">applicationContext&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getBean&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="no">B&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">));&lt;/span>
 &lt;span class="n">log&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">info&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">applicationContext&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getBean&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="no">C&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">));&lt;/span>

 &lt;span class="n">log&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">info&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;-A--------&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="no">A&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">applicationContext&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getBean&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="no">A&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">log&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">info&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">log&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">info&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">b&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">log&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">info&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;-B--------&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="no">B&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">applicationContext&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getBean&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="no">B&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">log&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">info&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">log&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">info&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">c&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">log&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">info&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;-C--------&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="no">C&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">applicationContext&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getBean&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="no">C&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">log&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">info&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">log&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">info&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">a&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>

 &lt;span class="nd">@Configuration&lt;/span>
 &lt;span class="nd">@Import&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">AbcImportSelector&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">)&lt;/span>
 &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Config&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="o">}&lt;/span>

 &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">AbcImportSelector&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="nc">ImportSelector&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nd">@Override&lt;/span>
 &lt;span class="kd">public&lt;/span> &lt;span class="nc">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="nf">selectImports&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">AnnotationMetadata&lt;/span> &lt;span class="n">importingClassMetadata&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">String&lt;/span>&lt;span class="o">[]{&lt;/span>
 &lt;span class="no">A&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">(),&lt;/span>
 &lt;span class="no">B&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">(),&lt;/span>
 &lt;span class="no">C&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">()};&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="o">}&lt;/span>


 &lt;span class="nd">@Component&lt;/span>
 &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">A&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nd">@Autowired&lt;/span>
 &lt;span class="no">B&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>

 &lt;span class="nd">@Component&lt;/span>
 &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">B&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nd">@Autowired&lt;/span>
 &lt;span class="no">C&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>

 &lt;span class="nd">@Component&lt;/span>
 &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">C&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nd">@Autowired&lt;/span>
 &lt;span class="no">A&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>上述示例代码中的循环依赖情况如下：&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/spring-framework/circular-dependence.jpg" alt="循环依赖" width="98%"/>
&lt;/div>
&lt;div class="title">图 1. 循环依赖&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_源码剖析">源码剖析&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="sect2">
&lt;h3 id="_三级缓存">三级缓存&lt;/h3>
&lt;div class="paragraph">
&lt;p>D瓜哥在 &lt;a href="https://www.diguage.com/post/dive-into-spring-core-data-structure-bean-factory/#registry">深入剖析 Spring 核心数据结构：BeanFactory&lt;/a> 中，概要性地对 &lt;code>BeanFactory&lt;/code> 的属性做了一一说明。
而其中的“三级缓存”属性，则是解决循环依赖问题的关键所在：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;code>Map&amp;lt;String, Object&amp;gt; singletonObjects = new ConcurrentHashMap&amp;lt;&amp;gt;(256)&lt;/code>：Bean 名称到单例 Bean 的映射，用于存放完全初始化好的 Bean。可以理解成，这就是所谓的容器。这是一级缓存。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Map&amp;lt;String, Object&amp;gt; earlySingletonObjects = new HashMap&amp;lt;&amp;gt;(16)&lt;/code>：Bean 到“未成熟”单例 Bean 的映射。该 Bean 对象只是被创建出来，但是还没有注入依赖。在容器解决循环依赖时，用于存储中间状态。这是二级缓存。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Map&amp;lt;String, ObjectFactory&amp;lt;?&amp;gt;&amp;gt; singletonFactories = new HashMap&amp;lt;&amp;gt;(16)&lt;/code>：Bean 名称到 Bean 的 ObjectFactory 对象的映射，存放 Bean 工厂对象。在容器解决循环依赖时，用于存储中间状态。这是三级缓存。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Bean 的获取过程就类似计算机缓存的作用过程：先从一级获取，失败再从二级、三级里面获取。在 &lt;code>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, boolean)&lt;/code> 方法中，可以明确看到整个过程：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="title">&lt;code>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(beanName, allowEarlyReference)&lt;/code>&lt;/div>
&lt;div class="content">
&lt;pre class="rouge highlight">&lt;code data-lang="java">&lt;span class="cm">/**
 * Return the (raw) singleton object registered under the given name.
 * &amp;lt;p&amp;gt;Checks already instantiated singletons and also allows for an early
 * reference to a currently created singleton (resolving a circular reference).
 * @param beanName the name of the bean to look for
 * @param allowEarlyReference whether early references should be created or not
 * @return the registered singleton object, or {@code null} if none found
 */&lt;/span>
&lt;span class="nd">@Nullable&lt;/span>
&lt;span class="kd">protected&lt;/span> &lt;span class="nc">Object&lt;/span> &lt;span class="nf">getSingleton&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">String&lt;/span> &lt;span class="n">beanName&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="n">allowEarlyReference&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">Object&lt;/span> &lt;span class="n">singletonObject&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">singletonObjects&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">beanName&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">singletonObject&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">isSingletonCurrentlyInCreation&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">beanName&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="kd">synchronized&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">singletonObjects&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">singletonObject&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">earlySingletonObjects&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">beanName&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">singletonObject&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">allowEarlyReference&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">ObjectFactory&lt;/span>&lt;span class="o">&amp;lt;?&amp;gt;&lt;/span> &lt;span class="n">singletonFactory&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">singletonFactories&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">get&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">beanName&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">singletonFactory&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">singletonObject&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">singletonFactory&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getObject&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">earlySingletonObjects&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">put&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">beanName&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">singletonObject&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">singletonFactories&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">remove&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">beanName&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="n">singletonObject&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div></description></item><item><title>Spring 扩展点实践：整合 Apache Dubbo（二）</title><link>https://www.diguage.com/post/spring-extensions-and-dubbo-2/</link><pubDate>Sat, 11 Jul 2020 16:20:00 +0800</pubDate><guid>https://www.diguage.com/post/spring-extensions-and-dubbo-2/</guid><description>&lt;div class="paragraph">
&lt;p>在 &lt;a href="https://www.diguage.com/post/spring-extensions-and-dubbo-1/" target="_blank" rel="noopener">Spring 扩展点实践：整合 Apache Dubbo（一）&lt;/a> 中，D瓜哥介绍了 Dubbo 如何使用 Spring 的插件机制与 Spring 整合。限于篇幅原因，上一篇文章只介绍到了服务提供者的注册。本篇文章继续上一篇文章的主题，继续介绍 Spring 与 Dubbo 的整合过程。先来讲解一下服务消费者的生成过程。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_dubbo_生成服务消费者的过程">Dubbo 生成服务消费者的过程&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>先来看看 XML 配置文件：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="title">&lt;code>dubbo-demo/dubbo-demo-xml/dubbo-demo-xml-consumer/src/main/resources/spring/dubbo-consumer.xml&lt;/code>&lt;/div>
&lt;div class="content">
&lt;pre class="rouge highlight">&lt;code data-lang="xml">&lt;span class="cp">&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;beans&lt;/span> &lt;span class="na">xmlns:xsi=&lt;/span>&lt;span class="s">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span>
 &lt;span class="na">xmlns:dubbo=&lt;/span>&lt;span class="s">&amp;#34;http://dubbo.apache.org/schema/dubbo&amp;#34;&lt;/span>
 &lt;span class="na">xmlns=&lt;/span>&lt;span class="s">&amp;#34;http://www.springframework.org/schema/beans&amp;#34;&lt;/span>
 &lt;span class="na">xsi:schemaLocation=&lt;/span>&lt;span class="s">&amp;#34;http://www.springframework.org/schema/beans
 http://www.springframework.org/schema/beans/spring-beans.xsd
 http://dubbo.apache.org/schema/dubbo
 http://dubbo.apache.org/schema/dubbo/dubbo.xsd&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>

 &lt;span class="nt">&amp;lt;dubbo:application&lt;/span> &lt;span class="na">name=&lt;/span>&lt;span class="s">&amp;#34;demo-consumer&amp;#34;&lt;/span>&lt;span class="nt">/&amp;gt;&lt;/span>

 &lt;span class="nt">&amp;lt;dubbo:registry&lt;/span> &lt;span class="na">address=&lt;/span>&lt;span class="s">&amp;#34;zookeeper://127.0.0.1:2181&amp;#34;&lt;/span>&lt;span class="nt">/&amp;gt;&lt;/span>

 &lt;span class="nt">&amp;lt;dubbo:reference&lt;/span> &lt;span class="na">id=&lt;/span>&lt;span class="s">&amp;#34;demoService&amp;#34;&lt;/span> &lt;span class="na">check=&lt;/span>&lt;span class="s">&amp;#34;false&amp;#34;&lt;/span> &lt;span class="na">interface=&lt;/span>&lt;span class="s">&amp;#34;org.apache.dubbo.demo.DemoService&amp;#34;&lt;/span>&lt;span class="nt">/&amp;gt;&lt;/span>

&lt;span class="nt">&amp;lt;/beans&amp;gt;&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>我们先看一下 &lt;code>ReferenceBean&lt;/code> 类的声明：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="title">&lt;code>org.apache.dubbo.config.spring.ReferenceBean&lt;/code>&lt;/div>
&lt;div class="content">
&lt;pre class="rouge highlight">&lt;code data-lang="java">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">ReferenceBean&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="no">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="nc">ReferenceConfig&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="no">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="nc">FactoryBean&lt;/span>&lt;span class="o">,&lt;/span>
 &lt;span class="nc">ApplicationContextAware&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="nc">InitializingBean&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="nc">DisposableBean&lt;/span> &lt;span class="o">{&lt;/span>

 &lt;span class="c1">// 此处省略 N 行代码&lt;/span>

 &lt;span class="nd">@Override&lt;/span>
 &lt;span class="kd">public&lt;/span> &lt;span class="nc">Object&lt;/span> &lt;span class="nf">getObject&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="nf">get&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="o">}&lt;/span>

 &lt;span class="c1">// 此处省略 N 行代码&lt;/span>

 &lt;span class="nd">@Override&lt;/span>
 &lt;span class="nd">@SuppressWarnings&lt;/span>&lt;span class="o">({&lt;/span>&lt;span class="s">&amp;#34;unchecked&amp;#34;&lt;/span>&lt;span class="o">})&lt;/span>
 &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">afterPropertiesSet&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="nc">Exception&lt;/span> &lt;span class="o">{&lt;/span>

 &lt;span class="c1">// Initializes Dubbo&amp;#39;s Config Beans before @Reference bean autowiring&lt;/span>
 &lt;span class="n">prepareDubboConfigBeans&lt;/span>&lt;span class="o">();&lt;/span>

 &lt;span class="c1">// lazy init by default.&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">init&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">init&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>

 &lt;span class="c1">// eager init if necessary.&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">shouldInit&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">getObject&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="o">}&lt;/span>

 &lt;span class="c1">// 此处省略 N 行代码&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>这个类实现了 &lt;code>FactoryBean&lt;/code> 接口，D瓜哥在 &lt;a href="https://www.diguage.com/post/spring-extensions-overview/#factory-bean">Spring 扩展点概览及实践：FactoryBean&lt;/a> 中对 &lt;code>FactoryBean&lt;/code> 介绍。所以，请在上面的 &lt;code>getObject()&lt;/code> 打个断点。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>另外，这个类还实现了 &lt;code>InitializingBean&lt;/code>，D瓜哥在 &lt;a href="https://www.diguage.com/post/spring-bean-lifecycle-overview/">Spring Bean 生命周期概述&lt;/a> 中介绍了这个接口的用途。不了解的，请移步。&lt;/p>
&lt;/div></description></item><item><title>Spring 扩展点实践：整合 Apache Dubbo（一）</title><link>https://www.diguage.com/post/spring-extensions-and-dubbo-1/</link><pubDate>Thu, 09 Jul 2020 16:28:35 +0800</pubDate><guid>https://www.diguage.com/post/spring-extensions-and-dubbo-1/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/spring-extensions-overview/" target="_blank" rel="noopener">Spring 扩展点概览及实践&lt;/a> 中介绍了 Spring 内部存在的扩展点。 &lt;a href="https://www.diguage.com/post/spring-extensions-and-mybatis/" target="_blank" rel="noopener">Spring 扩展点实践：整合 MyBATIS&lt;/a> 中，D瓜哥带大家了解了一下 MyBATIS 如何利用 Spring 的扩展点实现了与 Spring 的完美整合。现在，学以致用，我们继续来分析一下 Spring 与 Apache Dubbo 的整合流程。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_示例程序">示例程序&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Apache Dubbo 仓库中就有很完整的示例。D瓜哥直接拿来使用就不再搭建示例程序了。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>首先，需要启动一个 ZooKeeper 实例。查看 Dubbo 的依赖可以看出，最新版代码依赖的 ZooKeeper 是 3.4.13 版。所以，为了最好的兼容性，就要选用 3.4.X 版的 ZooKeeper 服务器。D瓜哥直接使用 Docker 启动 ZooKeeper 了。命令如下：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="rouge highlight">&lt;code data-lang="bash">docker run &lt;span class="nt">--rm&lt;/span> &lt;span class="nt">--name&lt;/span> zookeeper &lt;span class="nt">-d&lt;/span> &lt;span class="nt">-p&lt;/span> 2181:2181 zookeeper:3.4.14&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>这次我们使用 &lt;a href="https://github.com/apache/dubbo" target="_blank" rel="noopener">Apache Dubbo&lt;/a> 的 &lt;code>dubbo-demo/dubbo-demo-xml&lt;/code> 示例。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>第二步，启动服务提供者程序，找到 &lt;code>DUBBO/dubbo-demo/dubbo-demo-xml/dubbo-demo-xml-provider/src/main/java/org/apache/dubbo/demo/provider/Application.java&lt;/code>，运行该类。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>第三步，运行服务消费者程序，找到 &lt;code>DUBBO/dubbo-demo/dubbo-demo-xml/dubbo-demo-xml-consumer/src/main/java/org/apache/dubbo/demo/consumer/Application.java&lt;/code>，运行该类。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>如果没有任何错误，则在终端可以看到 &lt;code>result: async result&lt;/code> 输出。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>在开始正餐之前，D瓜哥先给大家来个开胃菜。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="spring-plugin">Spring 插件机制简介&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>不知道大家有没有想过一个问题：Spring 框架是如何支持越来越多的功能的？&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>在D瓜哥了解到 Spring 的插件机制后，非常叹服 Spring 精巧的设计和灵活的扩展性。闲言少叙，好戏上演。&lt;/p>
&lt;/div></description></item><item><title>Redis 核心数据结构（二）</title><link>https://www.diguage.com/post/redis-core-data-structure-2/</link><pubDate>Fri, 03 Jul 2020 00:39:43 +0800</pubDate><guid>https://www.diguage.com/post/redis-core-data-structure-2/</guid><description>&lt;div class="sidebarblock">
&lt;div class="content">
&lt;div class="paragraph">
&lt;p>本文内容对于 Redis 7+ 来说已经过时，最新实现请看下面两篇文章：&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/redis-core-data-structure-3/">Redis 核心数据结构（3）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/redis-core-data-structure-4/">Redis 核心数据结构（4）&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>在上一篇文章： &lt;a href="https://www.diguage.com/post/redis-core-data-structure-1/">Redis 核心数据结构（1）&lt;/a> 中，介绍了链表、ziplist、quicklist 数据结构。这篇文章，来介绍一下 skiplist、dict。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="skiplist">skiplist&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>跳跃表是一种有序数据结构，支持平均 O(logN)、最坏 O(N) 复杂度的节点查找；大部分情况效率可以和平衡树相媲美，实现却比平衡树简单。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>跳跃表就是 Redis 中有序集合键的底层实现之一。&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="title">server.h&lt;/div>
&lt;div class="content">
&lt;pre class="rouge highlight">&lt;code data-lang="c">&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">zskiplistNode&lt;/span> &lt;span class="p">{&lt;/span>
 &lt;span class="n">sds&lt;/span> &lt;span class="n">ele&lt;/span>&lt;span class="p">;&lt;/span>
 &lt;span class="kt">double&lt;/span> &lt;span class="n">score&lt;/span>&lt;span class="p">;&lt;/span>
 &lt;span class="k">struct&lt;/span> &lt;span class="n">zskiplistNode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">backward&lt;/span>&lt;span class="p">;&lt;/span>
 &lt;span class="k">struct&lt;/span> &lt;span class="n">zskiplistLevel&lt;/span> &lt;span class="p">{&lt;/span>
 &lt;span class="k">struct&lt;/span> &lt;span class="n">zskiplistNode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">forward&lt;/span>&lt;span class="p">;&lt;/span>
 &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">span&lt;/span>&lt;span class="p">;&lt;/span>
 &lt;span class="p">}&lt;/span> &lt;span class="n">level&lt;/span>&lt;span class="p">[];&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">zskiplistNode&lt;/span>&lt;span class="p">;&lt;/span>

&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">zskiplist&lt;/span> &lt;span class="p">{&lt;/span>
 &lt;span class="k">struct&lt;/span> &lt;span class="n">zskiplistNode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">header&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">tail&lt;/span>&lt;span class="p">;&lt;/span>
 &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">length&lt;/span>&lt;span class="p">;&lt;/span>
 &lt;span class="kt">int&lt;/span> &lt;span class="n">level&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">zskiplist&lt;/span>&lt;span class="p">;&lt;/span>

&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">zset&lt;/span> &lt;span class="p">{&lt;/span>
 &lt;span class="n">dict&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">dict&lt;/span>&lt;span class="p">;&lt;/span>
 &lt;span class="n">zskiplist&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">zsl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">zset&lt;/span>&lt;span class="p">;&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>skiplist，顾名思义，首先它是一个list。实际上，它是在有序链表的基础上发展起来的。&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/redis/skiplist.png" alt="skiplist" width="95%"/>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>当我们想查找数据的时候，可以先沿着跨度大的链进行查找。当碰到比待查数据大的节点时，再回到跨度小的链表中进行查找。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>skiplist正是受这种多层链表的想法的启发而设计出来的。按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到 O(logN)。但是，存在的一个问题是：如果插入新节点后就会打乱上下相邻两层节点是 2:1 的对应关系。如果要维持，则需要调整后面所有的节点。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>skiplist为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)。&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/redis/redis-skiplist-insertions.png" alt="redis skiplist insertions" width="95%"/>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>插入操作只需要修改插入节点前后的指针，而不需要对很多节点都进行调整。这就降低了插入操作的复杂度。实际上，这是 skiplist 的一个很重要的特性，这让它在插入性能上明显优于平衡树的方案。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>skiplist，翻译成中文，可以翻译成“跳表”或“跳跃表”，指的就是除了最下面第1层链表之外，它会产生若干层稀疏的链表，这些链表里面的指针故意跳过了一些节点（而且越高层的链表跳过的节点越多）。这就使得我们在查找数据的时候能够先在高层的链表中进行查找，然后逐层降低，最终降到第1层链表来精确地确定数据位置。在这个过程中，我们跳过了一些节点，从而也就加快了查找速度。&lt;/p>
&lt;/div>
&lt;div class="sidebarblock">
&lt;div class="content">
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>在中间插入一个有比较高 Level 的节点，如何维护前面节点到这个节点的这些链接？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在平衡树种，如何做范围查找？先确定边界，然后其他节点怎么查找？&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/redis/redis_skiplist_example.png" alt="redis skiplist example" width="95%"/>
&lt;/div>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>skiplist 中 key 允许重复。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在比较时，不仅比较分数（即key），还要比较数据自身。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第一层链表是双向链表，并且反向指针只有一个。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 skiplist 中可以很方便计算每个元素的排名。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Redis 中的有序集合（sorted set），是在 skiplist, dict 和 ziplist 基础上构建起来的:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>当数据较少时，sorted set是由一个 ziplist 来实现的。其中集合元素按照分值从小到大排序。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当数据多的时候，sorted set 是由一个叫 zset 的数据结构来实现的，这个 zset 包含一个 dict + 一个 skiplist。dict 用来查询数据到分数(score)的对应关系，而 skiplist 用来根据分数查询数据（可能是范围查找）。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Redis 核心数据结构（一）</title><link>https://www.diguage.com/post/redis-core-data-structure-1/</link><pubDate>Thu, 02 Jul 2020 10:13:16 +0800</pubDate><guid>https://www.diguage.com/post/redis-core-data-structure-1/</guid><description>&lt;div class="sidebarblock">
&lt;div class="content">
&lt;div class="paragraph">
&lt;p>本文内容对于 Redis 7+ 来说已经过时，最新实现请看下面两篇文章：&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/redis-core-data-structure-3/">Redis 核心数据结构（3）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/redis-core-data-structure-4/">Redis 核心数据结构（4）&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Redis 目前是使用最广泛的缓存中间件。其突出特点就是支持多种常见的数据结构。对比 JDK 集合类的实现，Redis 的实现表现出很多独到之处，很多地方设计得别具匠心。下面就来简要介绍一下。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_linkedlist">linkedlist&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Redis 底层也有很多地方使用到 linkedlist，并且也是双向链表。&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="title">adlist.h&lt;/div>
&lt;div class="content">
&lt;pre class="rouge highlight">&lt;code data-lang="c">&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">listNode&lt;/span> &lt;span class="p">{&lt;/span>
 &lt;span class="k">struct&lt;/span> &lt;span class="n">listNode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">prev&lt;/span>&lt;span class="p">;&lt;/span>
 &lt;span class="k">struct&lt;/span> &lt;span class="n">listNode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">next&lt;/span>&lt;span class="p">;&lt;/span>
 &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">listNode&lt;/span>&lt;span class="p">;&lt;/span>

&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">listIter&lt;/span> &lt;span class="p">{&lt;/span>
 &lt;span class="n">listNode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">next&lt;/span>&lt;span class="p">;&lt;/span>
 &lt;span class="kt">int&lt;/span> &lt;span class="n">direction&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">listIter&lt;/span>&lt;span class="p">;&lt;/span>

&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">list&lt;/span> &lt;span class="p">{&lt;/span>
 &lt;span class="n">listNode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">head&lt;/span>&lt;span class="p">;&lt;/span>
 &lt;span class="n">listNode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">tail&lt;/span>&lt;span class="p">;&lt;/span>
 &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">dup&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="p">);&lt;/span>
 &lt;span class="kt">void&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">free&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="p">);&lt;/span>
 &lt;span class="kt">int&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">match&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>
 &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">len&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="p">;&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Redis 的 linkedlist 实现特点是：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>双向：节点带有前后指针；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>无环：首尾没有相连，所以没有构成环状；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>链表保存了首尾指针；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>多态：可以保存不同类型的值，这里成为泛型也许更符合 Java 中的语义。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Redis 在 2014 年实现了 &lt;a href="#quicklist">quicklist&lt;/a>，并使用 quicklist 代替了 linkedlist。所以，现在 linkedlist 几乎已经是废弃状态。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_ziplist">ziplist&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Redis 官方在 ziplist.c 文件的注释中对 ziplist 进行了定义：&lt;/p>
&lt;/div>
&lt;div class="quoteblock">
&lt;blockquote>
&lt;div class="paragraph">
&lt;p>The ziplist is a specially encoded dually linked list that is designed
to be very memory efficient. It stores both strings and integer values,
where integers are encoded as actual integers instead of a series of
characters. It allows push and pop operations on either side of the list
in O(1) time. However, because every operation requires a reallocation of
the memory used by the ziplist, the actual complexity is related to the
amount of memory used by the ziplist.&lt;/p>
&lt;/div></description></item><item><title>Kafka 常见面试题</title><link>https://www.diguage.com/post/kafka-interview-questions/</link><pubDate>Wed, 01 Jul 2020 18:08:51 +0800</pubDate><guid>https://www.diguage.com/post/kafka-interview-questions/</guid><description>&lt;div class="paragraph">
&lt;p>Kafka 是由 LinkedIn 开发的一个分布式的消息系统，使用 Scala 编写，它以可水平扩展和高吞吐率而被广泛使用。Kafka 本身设计也非常精巧，有很多关键的知识点需要注意。在面试中，也常常被问到。整理篇文章，梳理一下自己的知识点。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_架构设计问题">架构设计问题&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Kafka 整体架构如下：&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/kafka/kafka-architecture.png" alt="Kafka 架构" width="98%"/>
&lt;/div>
&lt;div class="title">图 1. Kafka 架构&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Kafka 架构分为以下几个部分&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Producer&lt;/strong>：消息生产者，就是向 Kafka Broker 发消息的客户端。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Consumer&lt;/strong>：消息消费者，向 Kafka Broker 取消息的客户端。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Topic&lt;/strong>：可以理解为一个队列，一个 Topic 又分为一个或多个分区。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Consumer Group&lt;/strong>：这是 Kafka 用来实现一个 Topic 消息的广播（发给所有的 Consumer）和单播（发给任意一个 Consumer）的手段。一个 Topic 可以有多个 Consumer Group。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Broker&lt;/strong>：一台 Kafka 服务器就是一个 Broker。一个集群由多个 Broker 组成。一个 Broker 可以容纳多个 Topic。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Partition&lt;/strong>：为了实现扩展性，一个非常大的 Topic 可以分布到多个 Broker上，每个 Partition 是一个有序的队列。Partition 中的每条消息都会被分配一个有序的id（offset）。将消息发给 Consumer，Kafka 只保证按一个 Partition 中的消息的顺序，不保证一个 Topic 的整体（多个 Partition 间）的顺序。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Offset&lt;/strong>：Kafka 的存储文件都是按照 offset.Kafka 来命名，用 offset 做名字的好处是方便查找。例如你想找位于 2049 的位置，只要找到 2048.Kafka 的文件即可。当然 the first offset 就是 00000000000.Kafka。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div></description></item><item><title>Spring AOP 处理流程概述</title><link>https://www.diguage.com/post/spring-aop-process-overview/</link><pubDate>Sat, 20 Jun 2020 19:16:35 +0800</pubDate><guid>https://www.diguage.com/post/spring-aop-process-overview/</guid><description>&lt;div class="paragraph">
&lt;p>AOP 是 Spring 框架的最核心的两个功能之一，在前面的 &lt;a href="https://www.diguage.com/post/spring-startup-process-overview/" target="_blank" rel="noopener">Spring 启动流程概述&lt;/a> 和 &lt;a href="https://www.diguage.com/post/spring-bean-lifecycle-overview/" target="_blank" rel="noopener">Spring Bean 生命周期概述&lt;/a> 两篇文章中，分别介绍了 Spring 启动过程和 Spring Bean 的生命周期，对 IoC 有了一个细致介绍。这里来细致分析一下 Spring AOP 的实现原理和处理流程。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_基本概念">基本概念&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>先来了解几个基本概念，D瓜哥私以为这些概念是 AOP 中最核心的内容，了解了基本概念，可以说基本上掌握了一半的 AOP 内容。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>学习概念最权威的地方，当然就是官方文档。所以，这些概念可以在 &lt;a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-introduction-defn" target="_blank" rel="noopener">Spring Framework Documentation: AOP Concepts&lt;/a> 中看到最权威的介绍。&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;strong>Join point(连接点)&lt;/strong>: 所谓的连接点是指那些被拦截到的点。在 Spring 中，连接点指的是方法，因为 Spring 只支持方法类型的连接点。在 Spring 中，使用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Pointcut(切入点)&lt;/strong>: 所谓的切入点，是指要对哪些 &lt;strong>Join point(连接点)&lt;/strong> 进行拦截的定义。如果 Join point(连接点) 是全集，那么 Pointcut(切入点) 就是被选中的子集。写 AOP 代码的时候，一般是用 Pointcut(切入点) 表达式进行对 Join point(连接点) 进行选择。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Advice(通知/增强)&lt;/strong>: 所谓的通知就是指拦截到 Join point(连接点) 之后所要做的事情。通知根据作用位置不同，又细分为：&lt;/p>
&lt;div class="olist loweralpha">
&lt;ol class="loweralpha" type="a">
&lt;li>
&lt;p>&lt;strong>Before advice(前置通知)&lt;/strong>: 在 Join point(连接点) 之前运行的通知。这种通知，不能阻止执行流程继续到 Join point(连接点)。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>After returning advice(后置通知)&lt;/strong>: 在 Join point(连接点) 之后运行的通知。当然，如果在 Join point(连接点) 执行过程中，抛出异常，则可能就不执行了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>After throwing advice(异常通知)&lt;/strong>: 方法抛出异常后，将会执行的通知。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>After (finally) advice(最终通知)&lt;/strong>: 无论如何都会执行的通知，即使抛出异常。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Around advice(环绕通知)&lt;/strong>: 围绕在 Join point(连接点) 的通知，方法执行前和执行后，都可以执行自定义行为。同时，也可以决定是返回 Join point(连接点) 的返回值，还是返回自定义的返回值。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Spring Bean 生命周期概述</title><link>https://www.diguage.com/post/spring-bean-lifecycle-overview/</link><pubDate>Sat, 20 Jun 2020 17:33:07 +0800</pubDate><guid>https://www.diguage.com/post/spring-bean-lifecycle-overview/</guid><description>&lt;div class="paragraph">
&lt;p>在 &lt;a href="https://www.diguage.com/post/spring-startup-process-overview/" target="_blank" rel="noopener">Spring 启动流程概述&lt;/a> 中，分析了 Spring 的启动流程。本文就来说明一下 Spring Bean 整个生命周期。如果有不清楚的地方，可以参考上文的“附录：启动日志”。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>直接上图：Spring Bean 生命周期流程图。内容较多，图片文字偏小，请放大看（矢量图，可以任意放大）：&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/spring-framework/spring-bean-lifecycle.svg" alt="Spring Bean 生命周期流程图" width="98%"/>
&lt;/div>
&lt;div class="title">图 1. Spring Bean 生命周期流程图&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>下面是文字说明。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_bean_生命周期简述">Bean 生命周期简述&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>调用 &lt;code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation&lt;/code>，主要是判断 &lt;code>AnnotationAwareAspectJAutoProxyCreator&lt;/code> 是否可以生成代理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用构造函数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用 &lt;code>MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition&lt;/code>，主要是通过 &lt;code>CommonAnnotationBeanPostProcessor&lt;/code>、 &lt;code>AutowiredAnnotationBeanPostProcessor&lt;/code> 收集依赖信息。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;span class="line-through">&lt;code>InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation&lt;/code>，这步什么也没做。&lt;/span>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用 &lt;code>InstantiationAwareBeanPostProcessor#postProcessProperties&lt;/code>，主要是完成依赖注入。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用 &lt;code>AutowiredAnnotationBeanPostProcessor#setBeanFactory&lt;/code>，注入 &lt;code>BeanFactory&lt;/code> 等相关信息。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用 &lt;code>BeanPostProcessor#postProcessBeforeInitialization&lt;/code>，主要是注入 &lt;code>ApplicationContext&lt;/code> 等相关信息。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用 &lt;code>InitializingBean#afterPropertiesSet&lt;/code>、 &lt;code>init-method&lt;/code> 方法&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用 &lt;code>BeanPostProcessor#postProcessAfterInitialization&lt;/code>，主要是生成 AOP 代理类。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_bean_生命周期详解">Bean 生命周期详解&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>从 &lt;code>getBean()&lt;/code> 方法获取 Bean 时，如果缓存中没有对应的 Bean，则会创建 Bean，整个流程如下：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation&lt;/code> — 目前有如下四个：&lt;/p>
&lt;div class="olist loweralpha">
&lt;ol class="loweralpha" type="a">
&lt;li>
&lt;p>&lt;code>ImportAwareBeanPostProcessor&lt;/code> — 继承父类实现，无所事事。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>AnnotationAwareAspectJAutoProxyCreator&lt;/code> — 继承父类实现，判断是否属于基础切面类，如果有指定的 Target 则生成代理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>CommonAnnotationBeanPostProcessor&lt;/code> — 无所事事。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>AutowiredAnnotationBeanPostProcessor&lt;/code> — 继承父类实现，无所事事。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Spring 启动流程概述</title><link>https://www.diguage.com/post/spring-startup-process-overview/</link><pubDate>Sat, 13 Jun 2020 00:31:25 +0800</pubDate><guid>https://www.diguage.com/post/spring-startup-process-overview/</guid><description>&lt;div class="paragraph">
&lt;p>对于 Spring 启动流程和 Bean 的生命周期，总有一些小地方搞的不是很清楚，干脆直接通过修改代码增加日志输出，使用断点单步调试，把整个流程捋顺了一点点的。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>除了加载配置文件或者基础配置类外，Spring 的启动过程几乎都被封装在 &lt;code>AbstractApplicationContext#refresh&lt;/code> 方法中，可以说弄清楚了这个方法的执行过程，就摸清楚了 Spring 启动全流程，下面的流程分析也是以这个方法为骨架来展开的。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_流程概要">流程概要&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>下面完整流程有些太复杂，所以，提炼一个简要的过程，方便糊弄面试官，哈哈哈😆&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>创建容器，读取 &lt;code>applicationContext.register(Config.class)&lt;/code> 指定的配置。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>准备 &lt;code>BeanFactory&lt;/code>，注册容器本身和 &lt;code>BeanFactory&lt;/code> 实例，以及注册环境配置信息等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>执行 &lt;code>BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry&lt;/code> 注册 &lt;code>BeanDefinition&lt;/code>。有三点需要注意：&lt;/p>
&lt;div class="olist loweralpha">
&lt;ol class="loweralpha" type="a">
&lt;li>
&lt;p>目前只有一个 &lt;code>ConfigurationClassPostProcessor&lt;/code> 实现类，Spring 中大量的 Bean 都是在这一步被该类注册到容器中的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>执行顺序是 ① &lt;code>PriorityOrdered&lt;/code> ② &lt;code>Ordered&lt;/code> ③ 普通的顺序来执行&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在执行上一步时，如果发现注册了 &lt;code>BeanDefinitionRegistryPostProcessor&lt;/code> 类型的 Bean，就会在循环里继续调用 &lt;code>postProcessBeanDefinitionRegistry&lt;/code> 方法。MyBATIS 和 Spring 整合的 &lt;code>MapperScannerConfigurer&lt;/code> 类就是在这一步执行的。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>执行 &lt;code>BeanFactoryPostProcessor#postProcessBeanFactory&lt;/code> 方法。目前只有一个 &lt;code>ConfigurationClassPostProcessor&lt;/code> 实现类。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>注册 &lt;code>CommonAnnotationBeanPostProcessor&lt;/code> 和 &lt;code>AutowiredAnnotationBeanPostProcessor&lt;/code> 为 &lt;code>BeanPostProcessor&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>注册 &lt;code>ApplicationEventMulticaster&lt;/code>，用于广播事件的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>注册 &lt;code>ApplicationListener&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>预加载以及注册所有非懒加载的 Bean&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_启动时序图">启动时序图&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Spring 启动流程的时序图如下：&lt;/p>
&lt;/div></description></item><item><title>Spring 扩展点实践：整合 MyBATIS</title><link>https://www.diguage.com/post/spring-extensions-and-mybatis/</link><pubDate>Thu, 28 May 2020 20:06:46 +0800</pubDate><guid>https://www.diguage.com/post/spring-extensions-and-mybatis/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/spring-extensions-overview/" target="_blank" rel="noopener">Spring 扩展点概览及实践&lt;/a> 中介绍了 Spring 内部存在的扩展点。学以致用，现在来分析一下 Spring 与 MyBATIS 的整合流程。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_示例程序">示例程序&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>为了方便分析源码，先根据官方文档 &lt;a href="https://mybatis.org/spring/getting-started.html" target="_blank" rel="noopener">mybatis-spring – MyBatis-Spring | Getting Started&lt;/a> 搭建起一个简单实例。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>数据库方面，直接使用功能了 MySQL 示例数据库： &lt;a href="https://dev.mysql.com/doc/employee/en/" target="_blank" rel="noopener">MySQL : Employees Sample Database&lt;/a>，需要的话，自行下载。&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="rouge highlight">&lt;code data-lang="java">&lt;span class="kn">package&lt;/span> &lt;span class="nn">com.diguage.truman.mybatis&lt;/span>&lt;span class="o">;&lt;/span>

&lt;span class="kn">import&lt;/span> &lt;span class="nn">com.mysql.cj.jdbc.Driver&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">com.zaxxer.hikari.HikariDataSource&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.apache.ibatis.session.Configuration&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.junit.jupiter.api.Test&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.mybatis.spring.SqlSessionFactoryBean&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.mybatis.spring.annotation.MapperScan&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.springframework.beans.factory.annotation.Autowired&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.springframework.context.annotation.AnnotationConfigApplicationContext&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.springframework.context.annotation.Bean&lt;/span>&lt;span class="o">;&lt;/span>

&lt;span class="kn">import&lt;/span> &lt;span class="nn">javax.sql.DataSource&lt;/span>&lt;span class="o">;&lt;/span>

&lt;span class="cm">/**
 * @author D瓜哥, &lt;a href="https://www.diguage.com/" target="_blank">https://www.diguage.com/&lt;/a>
 * @since 2020-05-29 17:11
 */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">MybatisTest&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nd">@Test&lt;/span>
 &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">test&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">AnnotationConfigApplicationContext&lt;/span> &lt;span class="n">context&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">AnnotationConfigApplicationContext&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="n">context&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">register&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">Config&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">context&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">refresh&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="nc">EmployeesMapper&lt;/span> &lt;span class="n">employeesMapper&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">context&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getBean&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">EmployeesMapper&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="nc">Employees&lt;/span> &lt;span class="n">employees&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">employeesMapper&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getById&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">10001&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="nc">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">employees&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>

 &lt;span class="nd">@org&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">springframework&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">context&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">annotation&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">Configuration&lt;/span>
 &lt;span class="nd">@MapperScan&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">basePackages&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;com.diguage.truman.mybatis&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
 &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Config&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nd">@Bean&lt;/span>
 &lt;span class="kd">public&lt;/span> &lt;span class="nc">DataSource&lt;/span> &lt;span class="nf">dataSource&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">HikariDataSource&lt;/span> &lt;span class="n">dataSource&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">HikariDataSource&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="n">dataSource&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setUsername&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;root&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">dataSource&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setPassword&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;123456&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">dataSource&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setDriverClassName&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">Driver&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">());&lt;/span>
 &lt;span class="n">dataSource&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setJdbcUrl&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;jdbc:mysql://localhost:3306/employees?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;autoReconnectForPools=true&amp;amp;autoReconnect=true&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="n">dataSource&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>

 &lt;span class="nd">@Bean&lt;/span>
 &lt;span class="kd">public&lt;/span> &lt;span class="nc">SqlSessionFactoryBean&lt;/span> &lt;span class="nf">sqlSessionFactory&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@Autowired&lt;/span> &lt;span class="nc">DataSource&lt;/span> &lt;span class="n">dataSource&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">SqlSessionFactoryBean&lt;/span> &lt;span class="n">factoryBean&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">SqlSessionFactoryBean&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="n">factoryBean&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setDataSource&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">dataSource&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="nc">Configuration&lt;/span> &lt;span class="n">configuration&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">Configuration&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="n">configuration&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setMapUnderscoreToCamelCase&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">factoryBean&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setConfiguration&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">configuration&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="n">factoryBean&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="title">EmployeesMapper&lt;/div>
&lt;div class="content">
&lt;pre class="rouge highlight">&lt;code data-lang="java">&lt;span class="kn">package&lt;/span> &lt;span class="nn">com.diguage.truman.mybatis&lt;/span>&lt;span class="o">;&lt;/span>

&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.apache.ibatis.annotations.Param&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">org.apache.ibatis.annotations.Select&lt;/span>&lt;span class="o">;&lt;/span>

&lt;span class="cm">/**
 * @author D瓜哥, &lt;a href="https://www.diguage.com/" target="_blank">https://www.diguage.com/&lt;/a>
 * @since 2020-05-29 17:23
 */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">EmployeesMapper&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nd">@Select&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;SELECT * FROM employees WHERE emp_no = #{id}&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
 &lt;span class="nc">Employees&lt;/span> &lt;span class="nf">getById&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nd">@Param&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;id&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="nc">Integer&lt;/span> &lt;span class="n">id&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="title">Employees&lt;/div>
&lt;div class="content">
&lt;pre class="rouge highlight">&lt;code data-lang="java">&lt;span class="kn">package&lt;/span> &lt;span class="nn">com.diguage.truman.mybatis&lt;/span>&lt;span class="o">;&lt;/span>

&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.util.Date&lt;/span>&lt;span class="o">;&lt;/span>

&lt;span class="cm">/**
 * @author D瓜哥, &lt;a href="https://www.diguage.com/" target="_blank">https://www.diguage.com/&lt;/a>
 * @since 2020-05-29 17:24
 */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Employees&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">Integer&lt;/span> &lt;span class="n">empNo&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="nc">Date&lt;/span> &lt;span class="n">birthDate&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="nc">String&lt;/span> &lt;span class="n">firstName&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="nc">String&lt;/span> &lt;span class="n">lastName&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="nc">String&lt;/span> &lt;span class="n">gender&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="nc">Date&lt;/span> &lt;span class="n">hireDate&lt;/span>&lt;span class="o">;&lt;/span>

 &lt;span class="nd">@Override&lt;/span>
 &lt;span class="kd">public&lt;/span> &lt;span class="nc">String&lt;/span> &lt;span class="nf">toString&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;Employees{&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span>
 &lt;span class="s">&amp;#34;empNo=&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">empNo&lt;/span> &lt;span class="o">+&lt;/span>
 &lt;span class="s">&amp;#34;, birthDate=&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">birthDate&lt;/span> &lt;span class="o">+&lt;/span>
 &lt;span class="s">&amp;#34;, firstName=&amp;#39;&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">firstName&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="sc">&amp;#39;\&amp;#39;&amp;#39;&lt;/span> &lt;span class="o">+&lt;/span>
 &lt;span class="s">&amp;#34;, lastName=&amp;#39;&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">lastName&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="sc">&amp;#39;\&amp;#39;&amp;#39;&lt;/span> &lt;span class="o">+&lt;/span>
 &lt;span class="s">&amp;#34;, gender=&amp;#39;&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">gender&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="sc">&amp;#39;\&amp;#39;&amp;#39;&lt;/span> &lt;span class="o">+&lt;/span>
 &lt;span class="s">&amp;#34;, hireDate=&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">hireDate&lt;/span> &lt;span class="o">+&lt;/span>
 &lt;span class="sc">&amp;#39;}&amp;#39;&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>整个实例代码中，只有 &lt;code>@MapperScan(basePackages = &amp;#34;com.diguage.truman.mybatis&amp;#34;)&lt;/code> 这个注解和 MyBATIS 的配置相关，我们就从这里开始吧。&lt;/p>
&lt;/div></description></item><item><title>Spring 扩展点概览及实践</title><link>https://www.diguage.com/post/spring-extensions-overview/</link><pubDate>Tue, 26 May 2020 17:14:20 +0800</pubDate><guid>https://www.diguage.com/post/spring-extensions-overview/</guid><description>&lt;div class="paragraph">
&lt;p>学习 Spring 代码，最重要的是掌握 Spring 有哪些扩展点，可以利用这些扩展点对 Spring 做什么扩展操作。说得更具体一点，如果自己开发一个框架，如何与 Spring 进行整合，如果对 Spring 的扩展点有一个比较清晰的认识，势必会事半功倍。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_import">&lt;code>@Import&lt;/code>&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>先来看一下 &lt;code>@Import&lt;/code> 注解的定义：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="rouge highlight">&lt;code data-lang="java">&lt;span class="nd">@Target&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">ElementType&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">TYPE&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Retention&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">RetentionPolicy&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">RUNTIME&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="nd">@Documented&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="nd">@interface&lt;/span> &lt;span class="nc">Import&lt;/span> &lt;span class="o">{&lt;/span>

 &lt;span class="cm">/**
 * {@link Configuration @Configuration}, {@link ImportSelector},
 * {@link ImportBeanDefinitionRegistrar}, or regular component classes to import.
 */&lt;/span>
 &lt;span class="nc">Class&lt;/span>&lt;span class="o">&amp;lt;?&amp;gt;[]&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">();&lt;/span>

&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>从声明可以看出，使用时，只需要指定 &lt;code>Class&lt;/code> 实例即可；从方法的文档中可以看出，&lt;code>Class&lt;/code> 实例可以分为三种：&lt;code>ImportSelector&lt;/code>、&lt;code>ImportBeanDefinitionRegistrar&lt;/code> 和常规组件类。示例如下：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="rouge highlight">&lt;code data-lang="java">&lt;span class="nd">@Configuration&lt;/span>
&lt;span class="nd">@Import&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">LogImportSelector&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Config&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>在 &lt;code>org.springframework.context.annotation.ConfigurationClassParser#processImports&lt;/code> 方法中，集中了对 &lt;code>@Import&lt;/code> 注解的处理。从代码可以非常清晰地看出，分了三种情况进行处理：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;code>ImportSelector&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>ImportBeanDefinitionRegistrar&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>常规组件 &lt;code>Class&lt;/code>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>下面分别对其进行介绍。&lt;/p>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_importselector">&lt;code>ImportSelector&lt;/code>&lt;/h3>
&lt;div class="paragraph">
&lt;p>先来看一下 &lt;code>ImportSelector&lt;/code> 接口的定义：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="rouge highlight">&lt;code data-lang="java">&lt;span class="cm">/**
 * Interface to be implemented by types that determine which @{@link Configuration}
 * class(es) should be imported based on a given selection criteria, usually one or
 * more annotation attributes.
 *
 * &amp;lt;p&amp;gt;{@code ImportSelector} implementations are usually processed in the same way
 * as regular {@code @Import} annotations, however, it is also possible to defer
 * selection of imports until all {@code @Configuration} classes have been processed
 * (see {@link DeferredImportSelector} for details).
 *
 * @since 3.1
 * @see DeferredImportSelector
 * @see Import
 * @see ImportBeanDefinitionRegistrar
 * @see Configuration
 */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">ImportSelector&lt;/span> &lt;span class="o">{&lt;/span>

 &lt;span class="cm">/**
 * Select and return the names of which class(es) should be imported based on
 * the {@link AnnotationMetadata} of the importing @{@link Configuration} class.
 * @return the class names, or an empty array if none
 */&lt;/span>
 &lt;span class="nc">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="nf">selectImports&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">AnnotationMetadata&lt;/span> &lt;span class="n">importingClassMetadata&lt;/span>&lt;span class="o">);&lt;/span>

 &lt;span class="cm">/**
 * Return a predicate for excluding classes from the import candidates, to be
 * transitively applied to all classes found through this selector&amp;#39;s imports.
 * &amp;lt;p&amp;gt;If this predicate returns {@code true} for a given fully-qualified
 * class name, said class will not be considered as an imported configuration
 * class, bypassing class file loading as well as metadata introspection.
 * @return the filter predicate for fully-qualified candidate class names
 * of transitively imported configuration classes, or {@code null} if none
 * @since 5.2.4
 */&lt;/span>
 &lt;span class="nd">@Nullable&lt;/span>
 &lt;span class="k">default&lt;/span> &lt;span class="nc">Predicate&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nc">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="nf">getExclusionFilter&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>

&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div></description></item><item><title>负载均衡算法及实践</title><link>https://www.diguage.com/post/load-balancing-algorithm/</link><pubDate>Fri, 15 May 2020 11:37:25 +0800</pubDate><guid>https://www.diguage.com/post/load-balancing-algorithm/</guid><description>&lt;div class="paragraph">
&lt;p>前几天在看一个资料时，看到关于负载均衡算法的介绍。最近也在研究 Spring Cloud 和 Apache Dubbo 等微服务框架。正好负载均衡是微服务框架中一个很重要的知识点。就动手做个整理和总结。方便后续学习。&lt;/p>
&lt;/div>
&lt;div class="sidebarblock">
&lt;div class="content">
&lt;div class="paragraph">
&lt;p>听朋友建议，这篇文章还可以在算法对比，客户端负载均衡与服务端负载均衡区分等两方面做些补充。这些内容后续再补充加入进来。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_常见的负载均衡算法">常见的负载均衡算法&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="sect2">
&lt;h3 id="round-robin">轮询(Round Robin)法&lt;/h3>
&lt;div class="paragraph">
&lt;p>轮询选择指的是从已有的后端节点列表中按顺序依次选择一个节点出来提供服务。&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/load-balancing-algorithm/round-robin.png" alt="round robin"/>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>优点：试图做到请求转移的绝对均衡。实现简单，使用广泛。&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="weighted-round-robin">加权轮询(Weighted Round Robin)法&lt;/h3>
&lt;div class="paragraph">
&lt;p>实际使用中各个节点往往都带有不同的权重，所以一般都需要实现带权重的轮询选择。 权重高的被选中的次数多，权重低的被选中的次数少。&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/load-balancing-algorithm/weighted-round_robin.jpg" alt="weighted round robin"/>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>优点：是 &lt;a href="#round-robin">轮询(Round Robin)法&lt;/a> 改良版。适用于服务器配置不一致时，可以将配置好的服务器多干活，配置差的服务器少干活以使机器的负载达到相同的水平。&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="static-round-robin">静态轮询(Static Round Robin)法&lt;/h3>
&lt;div class="paragraph">
&lt;p>HAProxy 中实现的一个负载均衡算法。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>没有后台服务器的限制，服务器启动时，修改权重也不会生效。增删服务器时，服务器准备就绪后，会立即加入到服务队列中。&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="random">随机(Random)法&lt;/h3>
&lt;div class="paragraph">
&lt;p>通过随机函数，根据后端服务器列表的大小值来随机选择其中一台进行访问。由概率统计理论可以得知，随着调用量的增大，其实际效果越来越接近于平均分配流量到每一台后端服务器，也就是轮询的效果。&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="weighted-random">加权随机(Weighted Random)法&lt;/h3>
&lt;div class="paragraph">
&lt;p>与加权轮询法类似，加权随机法也是根据后端服务器不同的配置和负载情况来配置不同的权重。不同的是，它是按照权重来随机选择服务器的，而不是顺序。&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="ip-hash">原地址哈希(IP Hashing)法&lt;/h3>
&lt;div class="paragraph">
&lt;p>源地址哈希的思想是获取客户端访问的IP地址值，通过哈希函数计算得到一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是要访问的服务器的序号。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>优点：保证了相同客户端 IP 地址将会被哈希到同一台后端服务器，直到后端服务器列表变更。根据此特性可以在服务消费者与服务提供者之间建立有状态的 Session 会话。&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="uri-hash">URI 哈希(URI Hashing)法&lt;/h3>
&lt;div class="paragraph">
&lt;p>HAProxy 中实现的一个负载均衡算法。支持部分 URI（问号之前）和完整 URI 两种模式。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>这个算法可以把同一个 URI 的访问发送到同一台服务器上，以最大程度提高缓存命中率。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>该算法支持两个可选参数 &lt;code>len&lt;/code> 和 &lt;code>depth&lt;/code>，后跟一个正整数。仅在需要基于URI的开头来平衡服务器时，这些选项可能会很有用。 &lt;code>len&lt;/code> 参数指示算法仅应考虑URI开头的许多字符来计算哈希。请注意，将 &lt;code>len&lt;/code> 设置为 &lt;code>1&lt;/code> 几乎没有意义，因为大多数URI都以前导 &lt;code>/&lt;/code> 开头。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;code>depth&lt;/code> 参数指示用于计算哈希的最大目录深度。请求中的每个斜杠都计为一个级别。如果同时指定了两个参数，则在达到任意一个参数时都将停止评估。&lt;/p>
&lt;/div></description></item><item><title>推荐几本 Java 并发编程的书</title><link>https://www.diguage.com/post/java-concurrent-books/</link><pubDate>Wed, 25 Mar 2020 16:32:12 +0800</pubDate><guid>https://www.diguage.com/post/java-concurrent-books/</guid><description>&lt;div class="paragraph">
&lt;p>最近，D瓜哥的一个小伙伴向我抱怨，Java 并发是个大坑，问我怎么看？我回答，当然是用眼睛看啊…&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>D瓜哥觉得，想学好 Java 并发，最重要的还是啃书。幸运的是，Java 中还是有不少关于并发的优秀书籍可以看。正好利用这个机会，把看过的、个人认为还不错的书推荐一波。没有看过的就不多言了。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_java并发编程实战">Java并发编程实战&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>如果只选一本书来深入研究并发，那肯定是这本书。&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/java-concurrent-books/java-concurrency-in-practice.jpg" alt="java concurrency in practice" width="60%"/>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;a href="https://book.douban.com/subject/10484692/" target="_blank" rel="noopener">Java并发编程实战 (豆瓣)&lt;/a> — 这本书是必看的。JDK 中 JUC 就是这本书的作者们写的。虽然书名含有 &lt;code>Java&lt;/code> 一次，但是，里面更多是原理性的东西，各种语言都适用。只是例子少了一些。这本书需要多读几遍。（据说翻译不行，推荐看英文版）&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>放个英文版图片镇楼：&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/java-concurrent-books/java-concurrency-in-practice-en.jpg" alt="java concurrency in practice en" width="60%"/>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_java并发编程的艺术">Java并发编程的艺术&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/java-concurrent-books/art-of-java-concurrency-programming.jpg" alt="art of java concurrency programming" width="60%"/>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;a href="https://book.douban.com/subject/26591326/" target="_blank" rel="noopener">Java并发编程的艺术 (豆瓣)&lt;/a> — 这本书也不错，讲了很多源码方面的内容，非常棒。另外，在讲解 Double Lock 方面的知识时，涉及了很多 Java Memory Model 方面的知识，可以先看看 &lt;a href="https://book.douban.com/subject/34907497/" target="_blank" rel="noopener">深入理解Java虚拟机（第3版）(豆瓣)&lt;/a> 最后两章的内容，来提前补充一下这么方面的知识。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_实战java高并发程序设计">实战Java高并发程序设计&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/java-concurrent-books/java-concurrency-in-action.jpg" alt="java concurrency in action" width="60%"/>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;a href="https://book.douban.com/subject/30358019/" target="_blank" rel="noopener">实战Java高并发程序设计（第2版） (豆瓣)&lt;/a> — 这本书也不错，针对 Java 8 写的，Java 8 中的很多新知识都有涉猎，例子也很全面。广度和深度，得到了兼顾，非常棒。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_java编程思想">Java编程思想&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/java-concurrent-books/thinking-in-java.jpg" alt="thinking in java" width="60%"/>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;a href="https://book.douban.com/subject/2130190/" target="_blank" rel="noopener">Java编程思想（第4版）(豆瓣)&lt;/a> — 虽然这本书已经出来十余年了，但是依然经典。第 21 章 并发，用大量的例子和陈述来介绍并发。非常棒。美中不足，是针对 Java 5 编写的，现在已经 Java 8 了。不过，作者又出了一本书，可以理解成升级版。&lt;/p>
&lt;/div></description></item><item><title>Google 三驾马车：MapReduce、GFS、Bigtable</title><link>https://www.diguage.com/post/map-reduce-gfs-bigtable/</link><pubDate>Mon, 23 Mar 2020 10:13:57 +0800</pubDate><guid>https://www.diguage.com/post/map-reduce-gfs-bigtable/</guid><description>&lt;div class="sect1">
&lt;h2 id="_mapreduce">MapReduce&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>MapReduce编程模型来自函数式编程，包含两个最基本的算子：map，reduce&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>将一个运算任务分解成大量独立正交的子任务，每个子任务通过map算子计算，得到中间结果，然后用reduce算子进行聚合，得到最终结果。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>这两个算子有一个很重要的特征：确定性的纯过程调用（pure function），函数既不会修改输入，也不存在中间状态，也没有共享的内存。因此，输入一致的情况下，输出也是一致的，这大大方便了容错性设计。&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/map-reduce-gfs-bigtable/map-reduce-framework.png" alt="map reduce framework"/>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>系统中有两类主要的进程节点：master（单点），worker（多个）。其中，worker根据不同的计算任务，又分为map worker（对应上图中的Map phase）、reduce worker（对应上图中的Reduce phase）。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>master是系统的中心节点，负责计算任务到worker节点的分配，同时监控worker节点的状态。如果某个worker计算太慢，或者宕机，master会将该worker进程负责的计算任务转移到其他进程。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>map worker从GFS（google file system）中读取输入数据，然后将中间结果写到本地文件；reduce worker从master处得知中间结果的问题，通过rpc读取中间文件，计算之后将最终结果写入到可靠存储GFS。生产环境中，一个MapReduce过程的输出通常是另一个MapReduce计算的输入，类似Unix 的 pipeline，只不过unix pipeline通过stdin、stdout连接两个程序，而MapReduce使用GFS连接两个计算过程。&lt;/p>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_scalability">Scalability&lt;/h3>
&lt;div class="paragraph">
&lt;p>由于计算任务的正交性，很容易通过增加map worker、reduce worker来处理计算任务的增长。Input file 到 Map phase这个阶段，使用了基于范围（range based）的分片方法，master作为元数据服务器会记录split到worker的映射关系。&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_availability">Availability&lt;/h3>
&lt;div class="paragraph">
&lt;p>系统对worker的容错性较好，但对master的容错性较差。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>对于map worker，计算结果是写到本地文件，本地文件的位置需要通知到master，即使同一个task被多个map worker执行，单点的master只会采纳一份中间结果。而且上面提到了map function是pure function，所以计算结果也是一样的。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>对于reduce worker，reduce task的计算结果会先写到临时文件（temporary file），task完成之后再重命名写入gfs，那么如果一个reduce task再多个reduce worker上计算，那么会不会有问题呢，答案是不会的&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_performance">Performance&lt;/h3>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>data locality — 将任务调度到数据所在的节点进行计算，减少网络传输；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>backup task — master在发现某个worker上的task进展异常缓慢的时候，会将这个task调度到其他worker，以缩短这个任务（Job）的完成时间。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_gfs">GFS&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>GFS（Google File System）是Google研发的可伸缩、高可用、高可靠的分布式文件系统，提供了类似POSIX的API，按层级目录来组织文件。&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/map-reduce-gfs-bigtable/gfs-architecture.png" alt="gfs architecture"/>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>GFS master、GFS Client、GFS chunkserver。其中，GFS master任意时刻只有一个，而chunkserver和gfs client可能有多个。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>一份文件被分为多个固定大小的chunk（默认64M），每个chunk有全局唯一的文件句柄 －－ 一个64位的chunk ID，每一份chunk会被复制到多个chunkserver（默认值是3)，以此保证可用性与可靠性。chunkserver将chunk当做普通的Linux文件存储在本地磁盘上。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>GFS master是系统的元数据服务器，维护的元数据包括：命令空间（GFS按层级目录管理文件）、文件到chunk的映射，chunk的位置。其中，前两者是会持久化的，而chunk的位置信息来自于Chunkserver的汇报。&lt;/p>
&lt;/div></description></item></channel></rss>