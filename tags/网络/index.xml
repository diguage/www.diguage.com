<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>网络 on "地瓜哥"博客网</title><link>https://www.diguage.com/tags/%E7%BD%91%E7%BB%9C/</link><description>Recent content in 网络 on "地瓜哥"博客网</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sat, 02 Jul 2022 20:24:55 +0800</lastBuildDate><atom:link href="https://www.diguage.com/tags/%E7%BD%91%E7%BB%9C/index.xml" rel="self" type="application/rss+xml"/><item><title>TCP 三次握手和四次挥手</title><link>https://www.diguage.com/post/tcp-3-way-handshake-and-4-way-handshake/</link><pubDate>Mon, 03 Aug 2020 00:57:26 +0800</pubDate><guid>https://www.diguage.com/post/tcp-3-way-handshake-and-4-way-handshake/</guid><description>&lt;div class="paragraph">
&lt;p>传输控制协议（英语：Transmission Control Protocol，缩写：TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。在简化的计算机网络 OSI 模型中，它完成第四层传输层所指定的功能。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>毫不夸张地说，TCP 协议是目前整个互联网的基础。它解决了一系列的网络问题。带来的结果，就是协议本身非常复杂。考虑到文章篇幅问题，本文着重说明 TCP 建立连接时的三次握手过程和关闭连接时的四次挥手过程。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_三次握手">三次握手&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/tcp/tcp-connection-made-three-way-handshake.png" alt="TCP 三次握手" width="95%"/>
&lt;/div>
&lt;div class="title">图 1. TCP 三次握手&lt;/div>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>第一次握手(&lt;code>SYN=1&lt;/code>, &lt;code>seq=x&lt;/code>):&lt;/p>
&lt;div class="paragraph">
&lt;p>客户端发送一个 TCP 的 &lt;code>SYN&lt;/code> 标志位置 &lt;code>1&lt;/code> 的包，指明客户端打算连接的服务器的端口，以及初始序号 &lt;code>x&lt;/code>，保存在包头的序列号(&lt;code>Sequence Number&lt;/code>)字段里。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>发送完毕后，客户端进入 &lt;code>SYN_SEND&lt;/code> 状态。&lt;/p>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>第二次握手(&lt;code>SYN=1&lt;/code>、&lt;code>seq=y&lt;/code>；&lt;code>ACK=1&lt;/code>、&lt;code>ACKnum=x+1&lt;/code>):&lt;/p>
&lt;div class="paragraph">
&lt;p>服务器发回确认包(&lt;code>ACK&lt;/code>)应答。即 &lt;code>SYN&lt;/code> 标志位和 &lt;code>ACK&lt;/code> 标志位均为 &lt;code>1&lt;/code>。服务器端选择自己 &lt;code>ISN&lt;/code> 序列号，放到包头的序列号(&lt;code>Sequence Number&lt;/code>)字段里，同时将确认序号(&lt;code>Acknowledgement Number&lt;/code>)设置为客户的 &lt;code>ISN&lt;/code> 加 &lt;code>1&lt;/code>，即 &lt;code>x+1&lt;/code>。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>发送完毕后，服务器端进入 &lt;code>SYN_RCVD&lt;/code> 状态。&lt;/p>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>第三次握手(&lt;code>ACK=1&lt;/code>，&lt;code>ACKnum=y+1&lt;/code>)&lt;/p>
&lt;div class="paragraph">
&lt;p>客户端再次发送确认包(&lt;code>ACK&lt;/code>)，SYN 标志位为 &lt;code>0&lt;/code>，&lt;code>ACK&lt;/code> 标志位为 &lt;code>1&lt;/code>，并且把服务器发来 &lt;code>ISN&lt;/code> 的序号字段+1，放在确定字段中发送给对方，即数据段放写 &lt;code>y+1&lt;/code>。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>发送完毕后，客户端进入 &lt;code>ESTABLISHED&lt;/code> 状态，当服务器端接收到这个包时，也进入 &lt;code>ESTABLISHED&lt;/code> 状态，TCP 握手结束。&lt;/p>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_syn_flood_攻击">SYN Flood 攻击&lt;/h3>
&lt;div class="paragraph">
&lt;p>在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 &lt;code>SYN_RCVD&lt;/code> 状态。当收到 ACK 后，服务器才能转入 &lt;code>ESTABLISHED&lt;/code> 状态.&lt;/p>
&lt;/div></description></item><item><title>HTTP 123</title><link>https://www.diguage.com/post/http-123/</link><pubDate>Thu, 05 Mar 2020 08:08:44 +0800</pubDate><guid>https://www.diguage.com/post/http-123/</guid><description>&lt;div class="sect1">
&lt;h2 id="_http1_0">HTTP1.0&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>根据谷歌的调查， 现在请求一个网页，平均涉及到 80 个资源，30 多个域名。考虑最原始的情况，每请求一个资源都需要建立一次 TCP 请求，显然不可接受。HTTP 协议规定了一个字段 &lt;code>Connection&lt;/code>，不过默认的值是 &lt;code>close&lt;/code>，也就是不开启。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_http1_1">HTTP1.1&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Pipeline 是为了减少不必要的 TCP 连接，但依然存在队头阻塞(HOC)的缺点，一种解决思路是利用并发连接减少某一个 HOC 的影响，另一个是共享(注意与复用的区别) TCP 连接，直接避免 HOC 问题的发生。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>HTTP1.1 的缺陷&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>高延迟 — 队头阻塞(Head-Of-Line Blocking)&lt;/p>
&lt;div class="paragraph">
&lt;p>当有多个串行请求执行时，如果第一个请求不执行完，后续的请求也无法执行。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>支持并发请求是解决解决 HOC 问题的一种方案，并发请求并非是直接解决了 HOC 的问题，而是尽可能减少 HOC 造成的影响。&lt;/p>
&lt;/div>
&lt;div class="olist loweralpha">
&lt;ol class="loweralpha" type="a">
&lt;li>
&lt;p>将同一页面的资源分散到不同域名下，提升连接上限。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>减少请求数量&lt;/p>
&lt;/li>
&lt;li>
&lt;p>内联一些资源：css、base64 图片等&lt;/p>
&lt;/li>
&lt;li>
&lt;p>合并小文件减少资源数&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>无状态特性 — 阻碍交互&lt;/p>
&lt;/li>
&lt;li>
&lt;p>明文传输 — 不安全性&lt;/p>
&lt;div class="paragraph">
&lt;p>HTTP 1.x 也可以配合 TLS 进行安全传输，只是不是强制的。&lt;/p>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>不支持服务端推送&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_spdy">SPDY&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>SPDY 是由 Google 推行的改进版本的 HTTP1.1。&lt;/p>
&lt;/div>
&lt;div class="imageblock">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/http123/spdy.webp" alt="SPDY"/>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>针对 HTTP1.1 的缺陷，SPDY 提供了如下特性：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>多路复用 — 解决队头阻塞&lt;/p>
&lt;div class="paragraph">
&lt;p>SPDY 允许在一个连接上无限制并发流。因为请求在一个通道上，TCP 效率更高。&lt;/p>
&lt;/div></description></item></channel></rss>