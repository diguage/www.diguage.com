<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>序列化 on "地瓜哥"博客网</title><link>https://www.diguage.com/tags/%E5%BA%8F%E5%88%97%E5%8C%96/</link><description>Recent content in 序列化 on "地瓜哥"博客网</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Tue, 17 Jun 2025 14:22:38 +0800</lastBuildDate><atom:link href="https://www.diguage.com/tags/%E5%BA%8F%E5%88%97%E5%8C%96/index.xml" rel="self" type="application/rss+xml"/><item><title>细说编码与字符集</title><link>https://www.diguage.com/post/dive-into-encoding-and-character-set/</link><pubDate>Sat, 29 Oct 2022 09:09:12 +0800</pubDate><guid>https://www.diguage.com/post/dive-into-encoding-and-character-set/</guid><description>&lt;div class="paragraph">
&lt;p>&lt;strong>文章还没写完，提前放出防止出现 404。稍后慢慢更新，敬请期待： &lt;a href="https://www.diguage.com/post/dive-into-encoding-and-character-set/" target="_blank" rel="noopener">细说编码与字符集 - &amp;#34;地瓜哥&amp;#34;博客网&lt;/a>&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>文章还没写完，提前放出防止出现 404。稍后慢慢更新，敬请期待： &lt;a href="https://www.diguage.com/post/dive-into-encoding-and-character-set/" target="_blank" rel="noopener">细说编码与字符集 - &amp;#34;地瓜哥&amp;#34;博客网&lt;/a>&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>文章还没写完，提前放出防止出现 404。稍后慢慢更新，敬请期待： &lt;a href="https://www.diguage.com/post/dive-into-encoding-and-character-set/" target="_blank" rel="noopener">细说编码与字符集 - &amp;#34;地瓜哥&amp;#34;博客网&lt;/a>&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>前段时间要研究 Hessian 编码格式，为了搞清楚 Hessian 对字符串的编码，就顺路查了好多编码和字符集的工作，理清了很多以前模糊的知识点。下面整理一下笔记，也梳理一下自己的思路和理解。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_ascii_码">ASCII 码&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>计算机起源于美国，他们对英语字符与二进制位之间的对应关系做了统一规定，并制定了一套字符编码规则，这套编码规则被称为 American Standard Code for Information Interchange，简称为 ASCII 编码&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>其实，ASCII 最早起源于电报码。最早的商业应用是贝尔公司的七位电传打字机。后来于 1963 年发布了该标准的第一版。在网络交换中使用的 ASCII 格式是在 1969 年发布的，该格式在 2015 年发展成为互联网标准。点击 &lt;a href="https://www.rfc-editor.org/rfc/rfc20.pdf" target="_blank" rel="noopener">RFC 20: ASCII format for network interchange&lt;/a>，感受一下 1969 年的古香古色。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>ASCII 编码一共定义了128个字符的编码规则，用七位二进制表示（&lt;code>0x00&lt;/code> - &lt;code>0x7F&lt;/code>）, 这些字符组成的集合就叫做 ASCII 字符集。完整列表如下：&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/encoding/ascii-table.svg" alt="ASCII Table" width="95%"/>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>ASCII 码可以说是现在所有编码的鼻祖。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_编码乱战及_unicode_应运而生">编码乱战及 Unicode 应运而生&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>ASCII 编码是为专门英语指定的编码标准，但是却不能编码英语外来词。比如 &lt;code>résumé&lt;/code>，其中 &lt;code>é&lt;/code> 就不在 ASCII 编码范围内。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>随着计算机的发展，各个国家或地区，甚至不同公司都推出了不同的编码标准，比如中国推出了 GB2312、GBK 以及 GB18030；微软推出了 Windows character sets 。&lt;/p>
&lt;/div></description></item><item><title>Avro、ProtoBuf、Thrift 的模式演进之法【翻译】</title><link>https://www.diguage.com/post/schema-evolution-in-avro-protobuf-thrift/</link><pubDate>Sat, 27 Aug 2022 08:30:43 +0800</pubDate><guid>https://www.diguage.com/post/schema-evolution-in-avro-protobuf-thrift/</guid><description>&lt;div class="sidebarblock">
&lt;div class="content">
&lt;div class="paragraph">
&lt;p>前面系统研究了 Hessian 序列化协议。并以此为契机，顺带实例对比了 Hessian、MessagePack 和 JSON 的序列化。早在 2012 年，Martin Kleppmann 就写了一篇文章 &lt;a href="https://martin.kleppmann.com/2012/12/05/schema-evolution-in-avro-protocol-buffers-thrift.html" target="_blank" rel="noopener">《Schema evolution in Avro, Protocol Buffers and Thrift》&lt;/a>，也是基于实例，对比了 Avro、ProtoBuf、Thrift 的差别。现在翻译出来，方便做系列研究。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>整个“序列化系列”目录如下：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a> — Hessian 序列化协议的中文翻译版。根据后面的“协议解释与实战”系列文章，增加了协议内容错误提示。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/" target="_blank" rel="noopener">Hessian 协议解释与实战（一）：布尔、日期、浮点数与整数&lt;/a> — 介绍布尔型数据、日期类型、浮点类型数据和整数类型数据等四种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-2/" target="_blank" rel="noopener">Hessian 协议解释与实战（二）：长整型、二进制数据与 Null&lt;/a> — 介绍长整数类型数据、二进制数据和 &lt;code>null&lt;/code> 等三种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-3/" target="_blank" rel="noopener">Hessian 协议解释与实战（三）：字符串&lt;/a> — 专门介绍了关于字符串的处理。由于字符串需要铺垫的基础知识比较多，处理细节也有繁琐，所以单独成篇来介绍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-source-analysis-for-java/" target="_blank" rel="noopener">Hessian 源码分析（Java）&lt;/a> — 开始第四篇分析之前，先来介绍一下 Hessian 的源码实现。方便后续展开说明。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-4/" target="_blank" rel="noopener">Hessian 协议解释与实战（四）：数组与集合&lt;/a> — 铺垫了一些关于实例对象的处理，重点介绍关于数组和集合的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-5/" target="_blank" rel="noopener">Hessian 协议解释与实战（五）：对象与映射&lt;/a> — 重点介绍关于对象与映射的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-vs-msgpack-vs-json/" target="_blank" rel="noopener">Hessian、Msgpack 和 JSON 实例对比&lt;/a> — 用实例对比 JSON、Hessian 和 MessagePack 的区别。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/schema-evolution-in-avro-protobuf-thrift" target="_blank" rel="noopener">Avro、ProtoBuf、Thrift 的模式演进之路&lt;/a> — 翻译的 Martin Kleppmann 的文章，重点对比了 Avro、ProtoBuf、Thrift 的序列化处理思路。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Hessian、Msgpack 和 JSON 实例对比</title><link>https://www.diguage.com/post/hessian-vs-msgpack-vs-json/</link><pubDate>Fri, 05 Aug 2022 11:28:03 +0800</pubDate><guid>https://www.diguage.com/post/hessian-vs-msgpack-vs-json/</guid><description>&lt;div class="paragraph">
&lt;p>前段时间，翻译了 Hessian 2.0 的序列化协议，发布在了 &lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a>。但是，其中有很多言语不详之处。所以，接下来会用几篇文章来详细解释并实践一下 Hessian 序列化协议，以求做到知其然知其所以然。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>目录如下：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a> — Hessian 序列化协议的中文翻译版。根据后面的“协议解释与实战”系列文章，增加了协议内容错误提示。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/" target="_blank" rel="noopener">Hessian 协议解释与实战（一）：布尔、日期、浮点数与整数&lt;/a> — 介绍布尔型数据、日期类型、浮点类型数据和整数类型数据等四种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-2/" target="_blank" rel="noopener">Hessian 协议解释与实战（二）：长整型、二进制数据与 Null&lt;/a> — 介绍长整数类型数据、二进制数据和 &lt;code>null&lt;/code> 等三种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-3/" target="_blank" rel="noopener">Hessian 协议解释与实战（三）：字符串&lt;/a> — 专门介绍了关于字符串的处理。由于字符串需要铺垫的基础知识比较多，处理细节也有繁琐，所以单独成篇来介绍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-source-analysis-for-java/" target="_blank" rel="noopener">Hessian 源码分析（Java）&lt;/a> — 开始第四篇分析之前，先来介绍一下 Hessian 的源码实现。方便后续展开说明。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-4/" target="_blank" rel="noopener">Hessian 协议解释与实战（四）：数组与集合&lt;/a> — 铺垫了一些关于实例对象的处理，重点介绍关于数组和集合的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-5/" target="_blank" rel="noopener">Hessian 协议解释与实战（五）：对象与映射&lt;/a> — 重点介绍关于对象与映射的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-vs-msgpack-vs-json/" target="_blank" rel="noopener">Hessian、Msgpack 和 JSON 实例对比&lt;/a> — 用实例对比 JSON、Hessian 和 MessagePack 的区别。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/schema-evolution-in-avro-protobuf-thrift" target="_blank" rel="noopener">Avro、ProtoBuf、Thrift 的模式演进之路&lt;/a> — 翻译的 Martin Kleppmann 的文章，重点对比了 Avro、ProtoBuf、Thrift 的序列化处理思路。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;hr/>
&lt;div class="paragraph">
&lt;p>本文用实际来对比一下 JSON、Hessian 和 MessagePack 的区别。&lt;/p>
&lt;/div></description></item><item><title>Hessian 协议解释与实战（五）：对象与映射</title><link>https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-5/</link><pubDate>Tue, 31 May 2022 16:02:13 +0800</pubDate><guid>https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-5/</guid><description>&lt;div class="paragraph">
&lt;p>前段时间，翻译了 Hessian 2.0 的序列化协议，发布在了 &lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a>。但是，其中有很多言语不详之处。所以，接下来会用几篇文章来详细解释并实践一下 Hessian 序列化协议，以求做到知其然知其所以然。目录如下：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a> — Hessian 序列化协议的中文翻译版。根据后面的“协议解释与实战”系列文章，增加了协议内容错误提示。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/" target="_blank" rel="noopener">Hessian 协议解释与实战（一）：布尔、日期、浮点数与整数&lt;/a> — 介绍布尔型数据、日期类型、浮点类型数据和整数类型数据等四种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-2/" target="_blank" rel="noopener">Hessian 协议解释与实战（二）：长整型、二进制数据与 Null&lt;/a> — 介绍长整数类型数据、二进制数据和 &lt;code>null&lt;/code> 等三种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-3/" target="_blank" rel="noopener">Hessian 协议解释与实战（三）：字符串&lt;/a> — 专门介绍了关于字符串的处理。由于字符串需要铺垫的基础知识比较多，处理细节也有繁琐，所以单独成篇来介绍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-source-analysis-for-java/" target="_blank" rel="noopener">Hessian 源码分析（Java）&lt;/a> — 开始第四篇分析之前，先来介绍一下 Hessian 的源码实现。方便后续展开说明。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-4/" target="_blank" rel="noopener">Hessian 协议解释与实战（四）：数组与集合&lt;/a> — 铺垫了一些关于实例对象的处理，重点介绍关于数组和集合的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-5/" target="_blank" rel="noopener">Hessian 协议解释与实战（五）：对象与映射&lt;/a> — 重点介绍关于对象与映射的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-vs-msgpack-vs-json/" target="_blank" rel="noopener">Hessian、Msgpack 和 JSON 实例对比&lt;/a> — 用实例对比 JSON、Hessian 和 MessagePack 的区别。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/schema-evolution-in-avro-protobuf-thrift" target="_blank" rel="noopener">Avro、ProtoBuf、Thrift 的模式演进之路&lt;/a> — 翻译的 Martin Kleppmann 的文章，重点对比了 Avro、ProtoBuf、Thrift 的序列化处理思路。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;hr/>
&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-4/" target="_blank" rel="noopener">Hessian 协议解释与实战（四）：数组与集合&lt;/a> 中研究了数组和集合的处理方式。接下来介绍对象和映射的处理。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_基础工具方法">基础工具方法&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>基础工具方法就不再赘述，请直接参考 &lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/#helper-methods" target="_blank" rel="noopener">Hessian 协议解释与实战（一）：基础工具方法&lt;/a> 中提到的几个方法。&lt;/p>
&lt;/div></description></item><item><title>Hessian 协议解释与实战（四）：数组与集合</title><link>https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-4/</link><pubDate>Thu, 26 May 2022 18:01:43 +0800</pubDate><guid>https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-4/</guid><description>&lt;div class="paragraph">
&lt;p>前段时间，翻译了 Hessian 2.0 的序列化协议，发布在了 &lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a>。但是，其中有很多言语不详之处。所以，接下来会用几篇文章来详细解释并实践一下 Hessian 序列化协议，以求做到知其然知其所以然。目录如下：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a> — Hessian 序列化协议的中文翻译版。根据后面的“协议解释与实战”系列文章，增加了协议内容错误提示。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/" target="_blank" rel="noopener">Hessian 协议解释与实战（一）：布尔、日期、浮点数与整数&lt;/a> — 介绍布尔型数据、日期类型、浮点类型数据和整数类型数据等四种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-2/" target="_blank" rel="noopener">Hessian 协议解释与实战（二）：长整型、二进制数据与 Null&lt;/a> — 介绍长整数类型数据、二进制数据和 &lt;code>null&lt;/code> 等三种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-3/" target="_blank" rel="noopener">Hessian 协议解释与实战（三）：字符串&lt;/a> — 专门介绍了关于字符串的处理。由于字符串需要铺垫的基础知识比较多，处理细节也有繁琐，所以单独成篇来介绍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-source-analysis-for-java/" target="_blank" rel="noopener">Hessian 源码分析（Java）&lt;/a> — 开始第四篇分析之前，先来介绍一下 Hessian 的源码实现。方便后续展开说明。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-4/" target="_blank" rel="noopener">Hessian 协议解释与实战（四）：数组与集合&lt;/a> — 铺垫了一些关于实例对象的处理，重点介绍关于数组和集合的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-5/" target="_blank" rel="noopener">Hessian 协议解释与实战（五）：对象与映射&lt;/a> — 重点介绍关于对象与映射的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-vs-msgpack-vs-json/" target="_blank" rel="noopener">Hessian、Msgpack 和 JSON 实例对比&lt;/a> — 用实例对比 JSON、Hessian 和 MessagePack 的区别。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/schema-evolution-in-avro-protobuf-thrift" target="_blank" rel="noopener">Avro、ProtoBuf、Thrift 的模式演进之路&lt;/a> — 翻译的 Martin Kleppmann 的文章，重点对比了 Avro、ProtoBuf、Thrift 的序列化处理思路。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;hr/>
&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/hessian-source-analysis-for-java/" target="_blank" rel="noopener">Hessian 源码分析（Java）&lt;/a> 对 Hessian 的 Java 实现做了一个概要的分析，对处理流程以及整体架构做了一个简单的分析。接下来，回到主题，继续来解释 Hessian 序列化协议。这篇文章，我们来重点分析一下数组与集合相关的操作。&lt;/p>
&lt;/div></description></item><item><title>Hessian 源码分析（Java）</title><link>https://www.diguage.com/post/hessian-source-analysis-for-java/</link><pubDate>Sat, 21 May 2022 09:39:44 +0800</pubDate><guid>https://www.diguage.com/post/hessian-source-analysis-for-java/</guid><description>&lt;div class="paragraph">
&lt;p>前面通过几篇文章，解释并实践了一下 Hessian 的序列化协议。文章目录如下：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a> — Hessian 序列化协议的中文翻译版。根据后面的“协议解释与实战”系列文章，增加了协议内容错误提示。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/" target="_blank" rel="noopener">Hessian 协议解释与实战（一）：布尔、日期、浮点数与整数&lt;/a> — 介绍布尔型数据、日期类型、浮点类型数据和整数类型数据等四种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-2/" target="_blank" rel="noopener">Hessian 协议解释与实战（二）：长整型、二进制数据与 Null&lt;/a> — 介绍长整数类型数据、二进制数据和 &lt;code>null&lt;/code> 等三种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-3/" target="_blank" rel="noopener">Hessian 协议解释与实战（三）：字符串&lt;/a> — 专门介绍了关于字符串的处理。由于字符串需要铺垫的基础知识比较多，处理细节也有繁琐，所以单独成篇来介绍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-source-analysis-for-java/" target="_blank" rel="noopener">Hessian 源码分析（Java）&lt;/a> — 开始第四篇分析之前，先来介绍一下 Hessian 的源码实现。方便后续展开说明。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-4/" target="_blank" rel="noopener">Hessian 协议解释与实战（四）：数组与集合&lt;/a> — 铺垫了一些关于实例对象的处理，重点介绍关于数组和集合的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-5/" target="_blank" rel="noopener">Hessian 协议解释与实战（五）：对象与映射&lt;/a> — 重点介绍关于对象与映射的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-vs-msgpack-vs-json/" target="_blank" rel="noopener">Hessian、Msgpack 和 JSON 实例对比&lt;/a> — 用实例对比 JSON、Hessian 和 MessagePack 的区别。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/schema-evolution-in-avro-protobuf-thrift" target="_blank" rel="noopener">Avro、ProtoBuf、Thrift 的模式演进之路&lt;/a> — 翻译的 Martin Kleppmann 的文章，重点对比了 Avro、ProtoBuf、Thrift 的序列化处理思路。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;hr/>
&lt;div class="paragraph">
&lt;p>该系列第四篇文章准备详细介绍一下 Hessian 对对象、链表以及 &lt;code>Map&lt;/code> 等处理。但是，越调试代码，越发觉得应该先对 Hessian 的实现做一个源码分析。于是，就有了本文。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>这里有几点需要声明一下：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>在上面“解释与实战”系列文章中提到的代码就不再重复说明。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过“解释与实战”系列文章，大家应该可以领略到，处理序列化有大量的细节。但是，本文并不打算涉及。本文重点是介绍 Hessian 的 Java 实现的架构蓝图。相当于给指明一条路，沿着这条路，大家就可以探索 Hessian 的各种细节。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>本文的介绍，全部基于 Hessian 4.0.60 的源码。由于没有找到 Hessian 的仓库，D瓜哥从 Hessian 的网站下，下载了源码包，解压后发布在了 GitHub 上： &lt;a href="https://github.com/diguage/hessian" target="_blank" rel="noopener">Hessian — The source code of Hessian Library.&lt;/a>。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Hessian 协议解释与实战（三）：字符串</title><link>https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-3/</link><pubDate>Wed, 04 May 2022 16:09:05 +0000</pubDate><guid>https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-3/</guid><description>&lt;div class="paragraph">
&lt;p>前段时间，翻译了 Hessian 2.0 的序列化协议，发布在了 &lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a>。但是，其中有很多言语不详之处。所以，接下来会用几篇文章来详细解释并实践一下 Hessian 序列化协议，以求做到知其然知其所以然。目录如下：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a> — Hessian 序列化协议的中文翻译版。根据后面的“协议解释与实战”系列文章，增加了协议内容错误提示。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/" target="_blank" rel="noopener">Hessian 协议解释与实战（一）：布尔、日期、浮点数与整数&lt;/a> — 介绍布尔型数据、日期类型、浮点类型数据和整数类型数据等四种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-2/" target="_blank" rel="noopener">Hessian 协议解释与实战（二）：长整型、二进制数据与 Null&lt;/a> — 介绍长整数类型数据、二进制数据和 &lt;code>null&lt;/code> 等三种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-3/" target="_blank" rel="noopener">Hessian 协议解释与实战（三）：字符串&lt;/a> — 专门介绍了关于字符串的处理。由于字符串需要铺垫的基础知识比较多，处理细节也有繁琐，所以单独成篇来介绍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-source-analysis-for-java/" target="_blank" rel="noopener">Hessian 源码分析（Java）&lt;/a> — 开始第四篇分析之前，先来介绍一下 Hessian 的源码实现。方便后续展开说明。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-4/" target="_blank" rel="noopener">Hessian 协议解释与实战（四）：数组与集合&lt;/a> — 铺垫了一些关于实例对象的处理，重点介绍关于数组和集合的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-5/" target="_blank" rel="noopener">Hessian 协议解释与实战（五）：对象与映射&lt;/a> — 重点介绍关于对象与映射的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-vs-msgpack-vs-json/" target="_blank" rel="noopener">Hessian、Msgpack 和 JSON 实例对比&lt;/a> — 用实例对比 JSON、Hessian 和 MessagePack 的区别。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/schema-evolution-in-avro-protobuf-thrift" target="_blank" rel="noopener">Avro、ProtoBuf、Thrift 的模式演进之路&lt;/a> — 翻译的 Martin Kleppmann 的文章，重点对比了 Avro、ProtoBuf、Thrift 的序列化处理思路。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;hr/>
&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-2/" target="_blank" rel="noopener">Hessian 协议解释与实战（二）：长整型、二进制数据与 Null&lt;/a> 中研究了长整型、二进制数据与 &lt;code>null&lt;/code> 等三种数据类型的处理方式。接下来，我们再来介绍字符串的处理情况。&lt;/p>
&lt;/div></description></item><item><title>Hessian 协议解释与实战（二）：长整型、二进制数据与 Null</title><link>https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-2/</link><pubDate>Tue, 03 May 2022 16:09:15 +0800</pubDate><guid>https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-2/</guid><description>&lt;div class="paragraph">
&lt;p>前段时间，翻译了 Hessian 2.0 的序列化协议，发布在了 &lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a>。但是，其中有很多言语不详之处。所以，接下来会用几篇文章来详细解释并实践一下 Hessian 序列化协议，以求做到知其然知其所以然。目录如下：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a> — Hessian 序列化协议的中文翻译版。根据后面的“协议解释与实战”系列文章，增加了协议内容错误提示。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/" target="_blank" rel="noopener">Hessian 协议解释与实战（一）：布尔、日期、浮点数与整数&lt;/a> — 介绍布尔型数据、日期类型、浮点类型数据和整数类型数据等四种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-2/" target="_blank" rel="noopener">Hessian 协议解释与实战（二）：长整型、二进制数据与 Null&lt;/a> — 介绍长整数类型数据、二进制数据和 &lt;code>null&lt;/code> 等三种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-3/" target="_blank" rel="noopener">Hessian 协议解释与实战（三）：字符串&lt;/a> — 专门介绍了关于字符串的处理。由于字符串需要铺垫的基础知识比较多，处理细节也有繁琐，所以单独成篇来介绍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-source-analysis-for-java/" target="_blank" rel="noopener">Hessian 源码分析（Java）&lt;/a> — 开始第四篇分析之前，先来介绍一下 Hessian 的源码实现。方便后续展开说明。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-4/" target="_blank" rel="noopener">Hessian 协议解释与实战（四）：数组与集合&lt;/a> — 铺垫了一些关于实例对象的处理，重点介绍关于数组和集合的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-5/" target="_blank" rel="noopener">Hessian 协议解释与实战（五）：对象与映射&lt;/a> — 重点介绍关于对象与映射的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-vs-msgpack-vs-json/" target="_blank" rel="noopener">Hessian、Msgpack 和 JSON 实例对比&lt;/a> — 用实例对比 JSON、Hessian 和 MessagePack 的区别。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/schema-evolution-in-avro-protobuf-thrift" target="_blank" rel="noopener">Avro、ProtoBuf、Thrift 的模式演进之路&lt;/a> — 翻译的 Martin Kleppmann 的文章，重点对比了 Avro、ProtoBuf、Thrift 的序列化处理思路。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;hr/>
&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/" target="_blank" rel="noopener">Hessian 协议解释与实战（一）&lt;/a> 中研究了布尔型数据、日期类型、浮点类型数据、整数类型数据等四种数据类型的处理方式。接下来，我们再来介绍长整数类型数据、二进制数据和 &lt;code>null&lt;/code> 的处理情况。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_基础工具方法">基础工具方法&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>基础工具方法就不再赘述，请直接参考 &lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/#helper-methods" target="_blank" rel="noopener">Hessian 协议解释与实战（一）：布尔、日期、浮点数与整数：基础工具方法&lt;/a> 中提到的几个方法。&lt;/p>
&lt;/div></description></item><item><title>Hessian 协议解释与实战（一）：布尔、日期、浮点数与整数</title><link>https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/</link><pubDate>Mon, 02 May 2022 17:22:01 +0800</pubDate><guid>https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/</guid><description>&lt;div class="paragraph">
&lt;p>前段时间，翻译了 Hessian 2.0 的序列化协议，发布在了 &lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a>。但是，其中有很多言语不详之处。所以，接下来会用几篇文章来详细解释并实践一下 Hessian 序列化协议，以求做到知其然知其所以然。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>目录如下：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a> — Hessian 序列化协议的中文翻译版。根据后面的“协议解释与实战”系列文章，增加了协议内容错误提示。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/" target="_blank" rel="noopener">Hessian 协议解释与实战（一）：布尔、日期、浮点数与整数&lt;/a> — 介绍布尔型数据、日期类型、浮点类型数据和整数类型数据等四种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-2/" target="_blank" rel="noopener">Hessian 协议解释与实战（二）：长整型、二进制数据与 Null&lt;/a> — 介绍长整数类型数据、二进制数据和 &lt;code>null&lt;/code> 等三种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-3/" target="_blank" rel="noopener">Hessian 协议解释与实战（三）：字符串&lt;/a> — 专门介绍了关于字符串的处理。由于字符串需要铺垫的基础知识比较多，处理细节也有繁琐，所以单独成篇来介绍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-source-analysis-for-java/" target="_blank" rel="noopener">Hessian 源码分析（Java）&lt;/a> — 开始第四篇分析之前，先来介绍一下 Hessian 的源码实现。方便后续展开说明。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-4/" target="_blank" rel="noopener">Hessian 协议解释与实战（四）：数组与集合&lt;/a> — 铺垫了一些关于实例对象的处理，重点介绍关于数组和集合的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-5/" target="_blank" rel="noopener">Hessian 协议解释与实战（五）：对象与映射&lt;/a> — 重点介绍关于对象与映射的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-vs-msgpack-vs-json/" target="_blank" rel="noopener">Hessian、Msgpack 和 JSON 实例对比&lt;/a> — 用实例对比 JSON、Hessian 和 MessagePack 的区别。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/schema-evolution-in-avro-protobuf-thrift" target="_blank" rel="noopener">Avro、ProtoBuf、Thrift 的模式演进之路&lt;/a> — 翻译的 Martin Kleppmann 的文章，重点对比了 Avro、ProtoBuf、Thrift 的序列化处理思路。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;hr/>
&lt;div class="sect1">
&lt;h2 id="helper-methods">基础工具方法&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Hessian 序列化之后的数据，都是字节数组，为了方便查看字节数组的二进制形式和十六进制形式，在正式开始之前，先介绍一下期间用到的辅助工具方法。闲言少叙，直接上代码：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="java">&lt;span class="cm">/**
 * 创建 Hessian2Output 对象，以便用于序列化
 *
 * @author D瓜哥 · &lt;a href="https://www.diguage.com/" target="_blank">https://www.diguage.com/&lt;/a>
 */&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="nc">Hessian2Output&lt;/span> &lt;span class="nf">getHessian2Output&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">OutputStream&lt;/span> &lt;span class="n">stream&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">SerializerFactory&lt;/span> &lt;span class="n">serializerFactory&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">SerializerFactory&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="n">serializerFactory&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setAllowNonSerializable&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="nc">Hessian2Output&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">Hessian2Output&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">stream&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">result&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">setSerializerFactory&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">serializerFactory&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>

&lt;span class="cm">/**
 * 打印字节数组
 *
 * @author D瓜哥 · &lt;a href="https://www.diguage.com/" target="_blank">https://www.diguage.com/&lt;/a>
 */&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">printBytes&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">byte&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">String&lt;/span> &lt;span class="n">bitx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nc">Integer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">toBinaryString&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">Byte&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">toUnsignedInt&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="o">));&lt;/span>
 &lt;span class="nc">String&lt;/span> &lt;span class="n">zbits&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nc">String&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">format&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;%8s&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">bitx&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">replace&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="sc">&amp;#39; &amp;#39;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="sc">&amp;#39;0&amp;#39;&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;%4d 0x%02X %8s %c %n&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">zbits&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;%4d 0x%02X %8s %n&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">zbits&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>

&lt;span class="cm">/**
 * 将 long 转化成二进制字符串（前面补0）
 *
 * @author D瓜哥 · &lt;a href="https://www.diguage.com/" target="_blank">https://www.diguage.com/&lt;/a>
 */&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="nc">String&lt;/span> &lt;span class="nf">getBinaryString&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">long&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">String&lt;/span> &lt;span class="n">bits&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nc">Long&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">toBinaryString&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="kt">char&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">chars&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nc">String&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">format&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;%64s&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">bits&lt;/span>&lt;span class="o">)&lt;/span>
 &lt;span class="o">.&lt;/span>&lt;span class="na">replace&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="sc">&amp;#39; &amp;#39;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="sc">&amp;#39;0&amp;#39;&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">toCharArray&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="nc">StringBuilder&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">StringBuilder&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">64&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">chars&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">result&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">append&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">chars&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]);&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="mi">8&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">7&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">chars&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">result&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">append&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;,&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">toString&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>

&lt;span class="cm">/**
 * 将 int 转化成二进制字符串（前面补0）
 *
 * @author D瓜哥 · &lt;a href="https://www.diguage.com/" target="_blank">https://www.diguage.com/&lt;/a>
 */&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="nc">String&lt;/span> &lt;span class="nf">getBinaryString&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">String&lt;/span> &lt;span class="n">bits&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nc">Integer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">toBinaryString&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="kt">char&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">chars&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nc">String&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">format&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;%32s&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">bits&lt;/span>&lt;span class="o">)&lt;/span>
 &lt;span class="o">.&lt;/span>&lt;span class="na">replace&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="sc">&amp;#39; &amp;#39;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="sc">&amp;#39;0&amp;#39;&lt;/span>&lt;span class="o">).&lt;/span>&lt;span class="na">toCharArray&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="nc">StringBuilder&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">StringBuilder&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">64&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">chars&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">result&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">append&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">chars&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]);&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="mi">8&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">7&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">chars&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">result&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">append&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;,&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">toString&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div></description></item><item><title>Hessian 2.0 序列化协议（中文版）</title><link>https://www.diguage.com/post/hessian-serialization-protocol/</link><pubDate>Wed, 20 Apr 2022 17:30:08 +0800</pubDate><guid>https://www.diguage.com/post/hessian-serialization-protocol/</guid><description>&lt;div class="paragraph">
&lt;p>公司在微服务系统中，序列化协议大多数使用 &lt;a href="https://msgpack.org/" target="_blank" rel="noopener">MessagePack&lt;/a>。但是，由于 MessagePack 设计限制，导致微服务接口在增减参数时，只能在最后操作。但是，由于个人操作，难免失误，结果造成因为增减字段导致的事故层出不穷。最近，一些条件成熟，准备推动部门将序列化协议切换到 Hessian。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>原以为，切换到 Hessian 就可以万事大吉。但是，在和同事的沟通中发现，同事反馈，Hessian 本身也有一些限制。为了对 Hessian 有一个更深入的了解，干脆就把 Hessian 序列化协议读一遍。看协议，文字不多，干脆就把协议完整翻译一遍。闲言少叙，正文开始。&lt;/p>
&lt;/div>
&lt;hr/>
&lt;div class="sect1 text-center">
&lt;h2 id="_hessian_2_0_序列化协议">&lt;span class="big">&lt;strong>Hessian 2.0 序列化协议&lt;/strong>&lt;/span>&lt;/h2>
&lt;div class="sectionbody">

&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_协议解释">协议解释&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>针对该协议有很多言语不详，甚至模糊不清之处，专门做了一些解释和实践，叙述系列文章，用于辅助消化理解。目录如下：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-serialization-protocol/" target="_blank" rel="noopener">Hessian 2.0 序列化协议（中文版）&lt;/a> — Hessian 序列化协议的中文翻译版。根据后面的“协议解释与实战”系列文章，增加了协议内容错误提示。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/" target="_blank" rel="noopener">Hessian 协议解释与实战（一）：布尔、日期、浮点数与整数&lt;/a> — 介绍布尔型数据、日期类型、浮点类型数据和整数类型数据等四种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-2/" target="_blank" rel="noopener">Hessian 协议解释与实战（二）：长整型、二进制数据与 Null&lt;/a> — 介绍长整数类型数据、二进制数据和 &lt;code>null&lt;/code> 等三种类型的数据的处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-3/" target="_blank" rel="noopener">Hessian 协议解释与实战（三）：字符串&lt;/a> — 专门介绍了关于字符串的处理。由于字符串需要铺垫的基础知识比较多，处理细节也有繁琐，所以单独成篇来介绍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-source-analysis-for-java/" target="_blank" rel="noopener">Hessian 源码分析（Java）&lt;/a> — 开始第四篇分析之前，先来介绍一下 Hessian 的源码实现。方便后续展开说明。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-4/" target="_blank" rel="noopener">Hessian 协议解释与实战（四）：数组与集合&lt;/a> — 铺垫了一些关于实例对象的处理，重点介绍关于数组和集合的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-5/" target="_blank" rel="noopener">Hessian 协议解释与实战（五）：对象与映射&lt;/a> — 重点介绍关于对象与映射的相关处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/hessian-vs-msgpack-vs-json/" target="_blank" rel="noopener">Hessian、Msgpack 和 JSON 实例对比&lt;/a> — 用实例对比 JSON、Hessian 和 MessagePack 的区别。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/schema-evolution-in-avro-protobuf-thrift" target="_blank" rel="noopener">Avro、ProtoBuf、Thrift 的模式演进之路&lt;/a> — 翻译的 Martin Kleppmann 的文章，重点对比了 Avro、ProtoBuf、Thrift 的序列化处理思路。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item></channel></rss>