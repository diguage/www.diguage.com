<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>栈 on "地瓜哥"博客网</title><link>https://www.diguage.com/tags/%E6%A0%88/</link><description>Recent content in 栈 on "地瓜哥"博客网</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Mon, 31 Mar 2025 07:22:56 +0800</lastBuildDate><atom:link href="https://www.diguage.com/tags/%E6%A0%88/index.xml" rel="self" type="application/rss+xml"/><item><title>算法模式：单调栈</title><link>https://www.diguage.com/post/algorithm-pattern-monotonic-stack/</link><pubDate>Mon, 24 Mar 2025 20:26:12 +0800</pubDate><guid>https://www.diguage.com/post/algorithm-pattern-monotonic-stack/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/algorithm-pattern-sliding-window/" target="_blank" rel="noopener">算法模式：滑动窗口&lt;/a> 介绍了滑动窗口的算法模式。本篇文章，介绍一种堆栈相关的算法模式：单调栈。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_单调栈">单调栈&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>所谓单调栈，就是在栈的基础上，增加了一个附加条件：栈内元素单调递增或者递减，如果不符合要求，则将元素出栈，直到符合条件为止。当需要给当前的元素，找右边/左边第一个比它大/小的位置时，就特别适合使用单调栈。&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/monotonically-increasing-stack.svg" alt="单调递增栈" width="95%"/>
&lt;/div>
&lt;div class="title">图 1. 单调递增栈&lt;/div>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/monotonically-decreasing-stack.svg" alt="单调递减栈" width="95%"/>
&lt;/div>
&lt;div class="title">图 2. 单调递减栈&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>一般会用到 &lt;code>Deque&lt;/code> 的以下四个方法：&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;code>stack.isEmpty()&lt;/code>：如果 &lt;code>deque&lt;/code> 不包含任何元素，则返回 &lt;code>true&lt;/code>，否则返回 &lt;code>false&lt;/code>。因为要栈顶元素在满足要求的时候要弹出，所以需要进行空栈判断。有些场景，可能栈一定不会空的时候，就不需要该方法进行空栈判断。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>stack.push(e)&lt;/code>：将元素 &lt;code>e&lt;/code> 入栈。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>stack.pop()&lt;/code>：将栈顶元素弹出，并返回当前弹出的栈顶元素。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>stack.peek()&lt;/code>：获取栈顶元素，不弹出。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="java">&lt;span class="c1">// 定义一个单调栈&lt;/span>
&lt;span class="nc">Deque&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nc">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">stack&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">LinkedList&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
&lt;span class="c1">// 第一个元素，直接添加&lt;/span>
&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">);&lt;/span> &lt;span class="c1">// 注意：栈内存的是数组下标&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 如果是单调递增栈，那么这里就是大于，即 nums[i] &amp;gt; nums[deque.peek()]&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">peek&lt;/span>&lt;span class="o">()])&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">peek&lt;/span>&lt;span class="o">()])&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="c1">// 此处除了入栈，在有些场景下，还有可能有其他操作&lt;/span>
 &lt;span class="c1">// ..............&lt;/span>
 &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 循环比较，直到遇到当前元素小于栈顶的元素情况，跳出循环&lt;/span>
 &lt;span class="c1">// 单调递增栈，这里是小于，即nums[i] &amp;lt; nums[deque.peek()]&lt;/span>
 &lt;span class="k">while&lt;/span> &lt;span class="o">(!&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isEmpty&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">peek&lt;/span>&lt;span class="o">()])&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">//主要逻辑&lt;/span>
 &lt;span class="c1">// ............&lt;/span>
 &lt;span class="c1">// ............&lt;/span>
 &lt;span class="c1">// 弹出栈顶元素&lt;/span>
 &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pop&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>记住这两句话：&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>单调递增栈，利用波谷剔除栈中的波峰，留下波谷；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>单调递减栈，利用波峰剔除栈中的波谷，留下波峰。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_leetcode_316_去除重复字母">LeetCode 316. 去除重复字母&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://leetcode.cn/problems/remove-duplicate-letters/" target="_blank" rel="noopener">LeetCode - 316. 去除重复字母 &lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>给你一个字符串 &lt;code>s&lt;/code>，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 &lt;strong>返回结果的字典序最小&lt;/strong>（要求不能打乱其他字符的相对位置）。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入：s = &amp;#34;bcabc&amp;#34;
输出：&amp;#34;abc&amp;#34;&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入：s = &amp;#34;cbacdcbc&amp;#34;
输出：&amp;#34;acdb&amp;#34;&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>提示：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;code>1 &amp;lt;= s.length &amp;lt;= 10&lt;sup>4&lt;/sup>&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>s&lt;/code> 由小写英文字母组成&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div></description></item><item><title>单调栈实践（二）：应用</title><link>https://www.diguage.com/post/monotonic-stack-in-practice-2/</link><pubDate>Fri, 02 Aug 2024 22:57:10 +0800</pubDate><guid>https://www.diguage.com/post/monotonic-stack-in-practice-2/</guid><description>&lt;div class="paragraph">
&lt;p>在 &lt;a href="https://www.diguage.com/post/monotonic-stack-in-practice-1/" target="_blank" rel="noopener">单调栈实践（一）：入门&lt;/a> 中对单调栈做了一个初步介绍，同时使用一个类似单调栈的题目做了入门的尝试。在本文中，将分析正式单调栈的使用案例。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_实践_leetcode_503_下一个更大元素_ii">实践： LeetCode 503. 下一个更大元素 II&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>单调栈主要就是为了解决选择下一个更大或者更小元素的相关问题。来看一下 &lt;a href="https://leetcode.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">LeetCode 503. 下一个更大元素 II&lt;/a>。&lt;/p>
&lt;/div>
&lt;div class="quoteblock">
&lt;blockquote>
&lt;div class="paragraph">
&lt;p>给定一个循环数组 &lt;code>nums&lt;/code> （ &lt;code>nums[nums.length - 1]&lt;/code> 的下一个元素是 &lt;code>nums[0]&lt;/code> ），返回 &lt;code>nums&lt;/code> 中每个元素的下一个更大元素。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>数字 &lt;code>x&lt;/code> 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 &lt;code>-1&lt;/code> 。&lt;/p>
&lt;/div>
&lt;/blockquote>
&lt;/div>
&lt;div class="paragraph">
&lt;p>如果熟悉单调栈，这道题的解法就一目了然：&lt;strong>将数组从后向前遍历，如果单调栈栈顶元素比当前元素小，就将栈顶元素弹出；重复上述操作，直到栈顶元素大于当前元素，或者栈为空。如果栈不为空，则栈顶元素就是当前元素的后继更大元素。&lt;/strong>代码如下：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="java">&lt;span class="cm">/**
 * LeetCode 503. 下一个更大元素 II
 *
 * @author D瓜哥 · &lt;a href="https://www.diguage.com" target="_blank">https://www.diguage.com&lt;/a>
 * @since 2024-07-05 23:08:39
 */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="nf">nextGreaterElements&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">nums&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">];&lt;/span>
 &lt;span class="nc">Deque&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nc">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">stack&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">LinkedList&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
 &lt;span class="c1">// 只需要将数组“拼接”，遍历两遍数组，就可以解决所有元素后继更大元素的问题&lt;/span>
 &lt;span class="c1">// 从后向前遍历，再加上单调递增栈，就是时间复杂度为 O(n) 的解决方案&lt;/span>
 &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">--)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 取余即可获取当前需要处理的元素&lt;/span>
 &lt;span class="kt">int&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="c1">// 在单调栈不为空的情况下，将栈中小于等于当前元素的值都弹出&lt;/span>
 &lt;span class="k">while&lt;/span> &lt;span class="o">(!&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isEmpty&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">peek&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pop&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="c1">// 剩下元素既是比当前元素大的后继元素。为空则是没有更大元素&lt;/span>
 &lt;span class="c1">// 这里还有一个隐含变量：&lt;/span>
 &lt;span class="c1">// 由于栈是从后向前添加，则栈顶元素距离当前元素更近。&lt;/span>
 &lt;span class="c1">// 如果栈不为空，则栈顶元素就是符合条件的元素。&lt;/span>
 &lt;span class="n">result&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isEmpty&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">peek&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="o">]);&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock tip">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-tip" title="Tip">&lt;/i>
&lt;/td>
&lt;td class="content">
使用单调栈，一个关键点是确定使用的是单调递增栈，还是单调递减栈。
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre>这里给大家留一个思考题：本文提供的答案是从后向前遍历数组。尝试一下从前向后遍历数组的解决方案。&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_实践_leetcode_42_接雨水">实践： LeetCode 42. 接雨水&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>下面再来看一下： &lt;a href="https://leetcode.com/problems/trapping-rain-water/description/" target="_blank" rel="noopener">LeetCode 42. 接雨水&lt;/a>。&lt;/p>
&lt;/div>
&lt;div class="quoteblock">
&lt;blockquote>
&lt;div class="paragraph">
&lt;p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p>
&lt;/div></description></item><item><title>单调栈实践（一）：入门</title><link>https://www.diguage.com/post/monotonic-stack-in-practice-1/</link><pubDate>Thu, 01 Aug 2024 11:32:47 +0800</pubDate><guid>https://www.diguage.com/post/monotonic-stack-in-practice-1/</guid><description>&lt;div class="paragraph">
&lt;p>最近刷 LeetCode 算法题中，遇到了一些需要单调栈的题目，就顺便学习了一下单调栈。分享出来，以备后续深入学习。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>学习单调栈之前，先了解一些栈。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_栈_stack">栈 Stack&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>栈是一个众所周知的线性数据结构，它遵循先入后出（First In Last Out，简称 FILO）或后入先出（Last In First Out，简称 LIFO）的访问顺序。操作示意图如下：&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/stack.gif" alt="入栈与出栈" width="95%"/>
&lt;/div>
&lt;div class="title">图 1. 入栈与出栈&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_单调栈_monotonic_stack">单调栈 Monotonic Stack&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>单调栈是一种特殊的栈，添加了一些限制条件：内部元素只能是递增或递减的顺序存储；添加元素时，如果新元素不符合单调性，则将其内部元素弹出，直到符合添加时，才添加元素。根据元素顺序，又可分为单调递增栈和单调递减栈。操作示意图如下：&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/monotonically-increasing-stack.svg" alt="单调递增栈" width="95%"/>
&lt;/div>
&lt;div class="title">图 2. 单调递增栈&lt;/div>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/monotonically-decreasing-stack.svg" alt="单调递减栈" width="95%"/>
&lt;/div>
&lt;div class="title">图 3. 单调递减栈&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="monotonic-stack-pseudocode">代码示例&lt;/h3>
&lt;div class="paragraph">
&lt;p>在写代码时，一般基于 &lt;code>Deque&lt;/code> 来实现，通常用到以下四个方法：&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;code>deque.isEmpty()&lt;/code>：如果 &lt;code>deque&lt;/code> 不包含任何元素，则返回 &lt;code>true&lt;/code>，否则返回 &lt;code>false&lt;/code>。因为要栈顶元素在满足要求的时候要弹出，所以需要进行空栈判断。有些场景，可能栈一定不会空的时候，就不需要该方法进行空栈判断。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>deque.push(e)&lt;/code>：将元素 &lt;code>e&lt;/code> 入栈。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>deque.pop()&lt;/code>：将栈顶元素弹出，并返回当前弹出的栈顶元素。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>deque.peek()&lt;/code>：获取栈顶元素，不弹出。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="java">&lt;span class="c1">// 定义一个单调栈&lt;/span>
&lt;span class="nc">Deque&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nc">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">stack&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">LinkedList&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
&lt;span class="c1">// 第一个元素，直接添加&lt;/span>
&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">);&lt;/span> &lt;span class="c1">// 这里存的是数组下标&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 单调递增栈这里就是大于，即 nums[i] &amp;gt; nums[deque.peek()]&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">peek&lt;/span>&lt;span class="o">()])&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">peek&lt;/span>&lt;span class="o">()])&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="c1">// 此处除了入栈，在有些场景下，还有可能有其他操作&lt;/span>
 &lt;span class="c1">// ..............&lt;/span>
 &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 循环比较，直到遇到当前元素小于栈顶的元素情况，跳出循环&lt;/span>
 &lt;span class="c1">// 单调递增栈，这里是小于，即nums[i] &amp;lt; nums[deque.peek()]&lt;/span>
 &lt;span class="k">while&lt;/span> &lt;span class="o">(!&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isEmpty&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">peek&lt;/span>&lt;span class="o">()])&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">//主要逻辑&lt;/span>
 &lt;span class="c1">// ............&lt;/span>
 &lt;span class="c1">// ............&lt;/span>
 &lt;span class="c1">// 弹出栈顶元素&lt;/span>
 &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pop&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_应用_leetcode_155_最小栈">应用： LeetCode 155. 最小栈&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>来看一个 LeetCode 算法提： &lt;a href="https://leetcode.com/problems/min-stack/description/" target="_blank" rel="noopener">LeetCode 155. 最小栈&lt;/a>，D瓜哥愿意称之为单调栈入门最佳试题。&lt;/p>
&lt;/div></description></item></channel></rss>