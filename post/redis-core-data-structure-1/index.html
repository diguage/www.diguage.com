<!doctype html><html class=no-js lang=zh-cn><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Redis 核心数据结构（一） - "地瓜哥"博客网</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=keywords content="Redis,Spring,存储,设计,架构,程序设计,算法,分布式"><meta name=description content><meta property="og:url" content="https://www.diguage.com/post/redis-core-data-structure-1/"><meta property="og:site_name" content='"地瓜哥"博客网'><meta property="og:title" content="Redis 核心数据结构（一）"><meta property="og:description" content=" 本文内容对于 Redis 7+ 来说已经过时，最新实现请看下面两篇文章：
Redis 核心数据结构（3）
Redis 核心数据结构（4）
Redis 目前是使用最广泛的缓存中间件。其突出特点就是支持多种常见的数据结构。对比 JDK 集合类的实现，Redis 的实现表现出很多独到之处，很多地方设计得别具匠心。下面就来简要介绍一下。
linkedlist Redis 底层也有很多地方使用到 linkedlist，并且也是双向链表。
adlist.h typedef struct listNode { struct listNode *prev; struct listNode *next; void *value; } listNode; typedef struct listIter { listNode *next; int direction; } listIter; typedef struct list { listNode *head; listNode *tail; void *(*dup)(void *ptr); void (*free)(void *ptr); int (*match)(void *ptr, void *key); unsigned long len; } list; Redis 的 linkedlist 实现特点是：
双向：节点带有前后指针；
无环：首尾没有相连，所以没有构成环状；
链表保存了首尾指针；
多态：可以保存不同类型的值，这里成为泛型也许更符合 Java 中的语义。
Redis 在 2014 年实现了 quicklist，并使用 quicklist 代替了 linkedlist。所以，现在 linkedlist 几乎已经是废弃状态。
ziplist Redis 官方在 ziplist.c 文件的注释中对 ziplist 进行了定义：
The ziplist is a specially encoded dually linked list that is designed to be very memory efficient. It stores both strings and integer values, where integers are encoded as actual integers instead of a series of characters. It allows push and pop operations on either side of the list in O(1) time. However, because every operation requires a reallocation of the memory used by the ziplist, the actual complexity is related to the amount of memory used by the ziplist."><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-07-02T10:13:16+08:00"><meta property="article:modified_time" content="2025-06-17T11:39:58+08:00"><meta property="article:tag" content="存储"><meta property="article:tag" content="设计"><meta property="article:tag" content="架构"><meta name=twitter:card content="summary"><meta name=twitter:title content="Redis 核心数据结构（一）"><meta name=twitter:description content=" 本文内容对于 Redis 7+ 来说已经过时，最新实现请看下面两篇文章：
Redis 核心数据结构（3）
Redis 核心数据结构（4）
Redis 目前是使用最广泛的缓存中间件。其突出特点就是支持多种常见的数据结构。对比 JDK 集合类的实现，Redis 的实现表现出很多独到之处，很多地方设计得别具匠心。下面就来简要介绍一下。
linkedlist Redis 底层也有很多地方使用到 linkedlist，并且也是双向链表。
adlist.h typedef struct listNode { struct listNode *prev; struct listNode *next; void *value; } listNode; typedef struct listIter { listNode *next; int direction; } listIter; typedef struct list { listNode *head; listNode *tail; void *(*dup)(void *ptr); void (*free)(void *ptr); int (*match)(void *ptr, void *key); unsigned long len; } list; Redis 的 linkedlist 实现特点是：
双向：节点带有前后指针；
无环：首尾没有相连，所以没有构成环状；
链表保存了首尾指针；
多态：可以保存不同类型的值，这里成为泛型也许更符合 Java 中的语义。
Redis 在 2014 年实现了 quicklist，并使用 quicklist 代替了 linkedlist。所以，现在 linkedlist 几乎已经是废弃状态。
ziplist Redis 官方在 ziplist.c 文件的注释中对 ziplist 进行了定义：
The ziplist is a specially encoded dually linked list that is designed to be very memory efficient. It stores both strings and integer values, where integers are encoded as actual integers instead of a series of characters. It allows push and pop operations on either side of the list in O(1) time. However, because every operation requires a reallocation of the memory used by the ziplist, the actual complexity is related to the amount of memory used by the ziplist."><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/css/asciidoctor.css><link rel=stylesheet href=/css/rouge-monokai.css><link rel="shortcut icon" href=/favicon.ico><script async src="https://www.googletagmanager.com/gtag/js?id=G-1MMT2NLEL4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-1MMT2NLEL4")}</script><script id=baidu_analytics>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?e56e7dd0a120b414f5741f4c5e5218ea",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title='"地瓜哥"博客网' rel=home><div class="logo__item logo__text"><div class=logo__title>"地瓜哥"博客网</div><div class=logo__tagline>分享技术带来的喜悦 — https://www.diguage.com/</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>菜单</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>首页</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>分类</span></a></li><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>关于</span></a></li><li class=menu__item><a class=menu__link href=/archives/><span class=menu__text>归档</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Redis 核心数据结构（一）</h1><div class="post__meta meta"><div class="meta__item-author meta__item"><svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2.0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class=meta__text>D瓜哥</span></div><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-07-02T10:13:16+08:00>2020-07-02</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/ rel=category>程序设计</a>, <a class=meta__link href=/categories/%E7%AE%97%E6%B3%95/ rel=category>算法</a>, <a class=meta__link href=/categories/%E5%88%86%E5%B8%83%E5%BC%8F/ rel=category>分布式</a></span></div></div></header><figure class="post__thumbnail thumbnail"><img class=thumbnail__image src=/images/redis/redis-logo.png alt="Redis 核心数据结构（一）"></figure><div class="content post__content clearfix"><div class=sidebarblock><div class=content><div class=paragraph><p>本文内容对于 Redis 7+ 来说已经过时，最新实现请看下面两篇文章：</p></div><div class=ulist><ul><li><p><a href=https://www.diguage.com/post/redis-core-data-structure-3/>Redis 核心数据结构（3）</a></p></li><li><p><a href=https://www.diguage.com/post/redis-core-data-structure-4/>Redis 核心数据结构（4）</a></p></li></ul></div></div></div><div class=paragraph><p>Redis 目前是使用最广泛的缓存中间件。其突出特点就是支持多种常见的数据结构。对比 JDK 集合类的实现，Redis 的实现表现出很多独到之处，很多地方设计得别具匠心。下面就来简要介绍一下。</p></div><div class=sect1><h2 id=_linkedlist>linkedlist</h2><div class=sectionbody><div class=paragraph><p>Redis 底层也有很多地方使用到 linkedlist，并且也是双向链表。</p></div><div class=listingblock><div class=title>adlist.h</div><div class=content><pre class="rouge highlight"><code data-lang=c><span class=k>typedef</span> <span class=k>struct</span> <span class=n>listNode</span> <span class=p>{</span>
    <span class=k>struct</span> <span class=n>listNode</span> <span class=o>*</span><span class=n>prev</span><span class=p>;</span>
    <span class=k>struct</span> <span class=n>listNode</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
    <span class=kt>void</span> <span class=o>*</span><span class=n>value</span><span class=p>;</span>
<span class=p>}</span> <span class=n>listNode</span><span class=p>;</span>

<span class=k>typedef</span> <span class=k>struct</span> <span class=n>listIter</span> <span class=p>{</span>
    <span class=n>listNode</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>direction</span><span class=p>;</span>
<span class=p>}</span> <span class=n>listIter</span><span class=p>;</span>

<span class=k>typedef</span> <span class=k>struct</span> <span class=n>list</span> <span class=p>{</span>
    <span class=n>listNode</span> <span class=o>*</span><span class=n>head</span><span class=p>;</span>
    <span class=n>listNode</span> <span class=o>*</span><span class=n>tail</span><span class=p>;</span>
    <span class=kt>void</span> <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>dup</span><span class=p>)(</span><span class=kt>void</span> <span class=o>*</span><span class=n>ptr</span><span class=p>);</span>
    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>free</span><span class=p>)(</span><span class=kt>void</span> <span class=o>*</span><span class=n>ptr</span><span class=p>);</span>
    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>match</span><span class=p>)(</span><span class=kt>void</span> <span class=o>*</span><span class=n>ptr</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>key</span><span class=p>);</span>
    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>len</span><span class=p>;</span>
<span class=p>}</span> <span class=n>list</span><span class=p>;</span></code></pre></div></div><div class=paragraph><p>Redis 的 linkedlist 实现特点是：</p></div><div class="olist arabic"><ol class=arabic><li><p>双向：节点带有前后指针；</p></li><li><p>无环：首尾没有相连，所以没有构成环状；</p></li><li><p>链表保存了首尾指针；</p></li><li><p>多态：可以保存不同类型的值，这里成为泛型也许更符合 Java 中的语义。</p></li></ol></div><div class=paragraph><p>Redis 在 2014 年实现了 <a href=#quicklist>quicklist</a>，并使用 quicklist 代替了 linkedlist。所以，现在 linkedlist 几乎已经是废弃状态。</p></div></div></div><div class=sect1><h2 id=_ziplist>ziplist</h2><div class=sectionbody><div class=paragraph><p>Redis 官方在 ziplist.c 文件的注释中对 ziplist 进行了定义：</p></div><div class=quoteblock><blockquote><div class=paragraph><p>The ziplist is a specially encoded dually linked list that is designed
to be very memory efficient. It stores both strings and integer values,
where integers are encoded as actual integers instead of a series of
characters. It allows push and pop operations on either side of the list
in O(1) time. However, because every operation requires a reallocation of
the memory used by the ziplist, the actual complexity is related to the
amount of memory used by the ziplist.</p></div></blockquote><div class=attribution>— ziplist.c</div></div><div class=paragraph><p>就是说，ziplist 是一个经过特殊编码的双向链表，它的设计目标就是为了提高存储效率。ziplist 可以用于存储字符串或整数，其中整数是按真正的二进制表示进行编码的，而不是编码成字符串序列。它能以 O(1) 的时间复杂度在表的两端提供 <code>push</code> 和 <code>pop</code> 操作。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code>The general layout of the ziplist is as follows:

&lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt; &lt;entry&gt; ... &lt;entry&gt; &lt;zlend&gt;

NOTE: all fields are stored in little endian, if not specified otherwise.</code></pre></div></div><div class=imageblock><div class=content><img src=/images/redis/redis-ziplist-structure.jpg alt="redis ziplist structure"></div></div><div class="olist arabic"><ol class=arabic><li><p><code>&lt;zlbytes></code>: 32bit，表示ziplist占用的字节总数（也包括&lt;zlbytes>本身占用的4个字节）。</p></li><li><p><code>&lt;zltail></code>: 32bit，表示ziplist表中最后一项（entry）在ziplist中的偏移字节数。</p><div class=paragraph><p><code>&lt;zltail></code> 的存在，使得我们可以很方便地找到最后一项（不用遍历整个ziplist），从而可以在ziplist尾端快速地执行push或pop操作。</p></div></li><li><p><code>&lt;zllen></code>: 16bit， 表示ziplist中数据项（entry）的个数。zllen字段因为只有16bit，所以可以表达的最大值为2<sup>16</sup>-1。<code>&lt;zllen></code> 等于16bit全为1的情况，那么 <code>&lt;zllen></code> 就不表示数据项个数了，这时要想知道 ziplist 中数据项总数，那么必须对ziplist从头到尾遍历各个数据项，才能计数出来。</p></li><li><p><code>&lt;entry></code>: 表示真正存放数据的数据项，长度不定。一个数据项（entry）也有它自己的内部结构，这个稍后再解释。</p></li><li><p><code>&lt;zlend></code>: ziplist 最后 1 个字节，是一个结束标记，值固定等于 255。</p></li></ol></div><div class=paragraph><p>ziplist 将表中每一项存放在前后连续的地址空间内，一个ziplist整体占用一大块内存。它是一个表（list），但其实不是一个链表（linked list）。</p></div><div class=paragraph><p>ziplist 为了在细节上节省内存，对于值的存储采用了变长的编码方式。</p></div><div class=paragraph><p>每一个数据项&lt;entry>的构成：</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code>&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt; <i class=conum data-value=1></i><b>(1)</b></code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td><code>&lt;prevlen></code>: 表示前一个数据项占用的总字节数。<div class="olist arabic"><ol class=arabic><li><p>如果前一个数据项占用字节数小于254，那么 <code>&lt;prevlen></code> 就只用一个字节来表示，这个字节的值就是前一个数据项的占用字节数： <code>&lt;prevlen from 0 to 253> &lt;encoding> &lt;entry></code></p></li><li><p>如果前一个数据项占用字节数大于等于254，那么 <code>&lt;prevlen></code> 就用5个字节来表示，其中第1个字节的值是254（作为这种情况的一个标记），而后面4个字节组成一个整型值，来真正存储前一个数据项的占用字节数</p><div class=listingblock><div class=content><pre class="rouge highlight"><code>0xFE &lt;4 bytes unsigned little endian prevlen&gt; &lt;encoding&gt; &lt;entry&gt;  <i class=conum data-value=2></i><b>(2)</b> <i class=conum data-value=3></i><b>(3)</b></code></pre></div></div></li></ol></div></td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td><code>&lt;encoding></code>: 表示当前数据项的类型，整型或者字符串。</td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td><code>&lt;entry-data></code>: 数据</td></tr></tbody></table></div><div class=paragraph><p>关于 <code>&lt;encoding> &lt;entry-data></code> 的编码，直接引用官方文档：</p></div><div class=listingblock><div class=title>ziplist.c</div><div class=content><pre class="rouge highlight"><code>The encoding field of the entry depends on the content of the
entry. When the entry is a string, the first 2 bits of the encoding first
byte will hold the type of encoding used to store the length of the string,
followed by the actual length of the string. When the entry is an integer
the first 2 bits are both set to 1. The following 2 bits are used to specify
what kind of integer will be stored after this header. An overview of the
different types and encodings is as follows. The first byte is always enough
to determine the kind of entry.

 |00pppppp| - 1 byte
      String value with length less than or equal to 63 bytes (6 bits).
      &#34;pppppp&#34; represents the unsigned 6 bit length.
 |01pppppp|qqqqqqqq| - 2 bytes
      String value with length less than or equal to 16383 bytes (14 bits).
      IMPORTANT: The 14 bit number is stored in big endian.
 |10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 bytes
      String value with length greater than or equal to 16384 bytes.
      Only the 4 bytes following the first byte represents the length
      up to 2^32-1. The 6 lower bits of the first byte are not used and
      are set to zero.
      IMPORTANT: The 32 bit number is stored in big endian.
 |11000000| - 3 bytes
      Integer encoded as int16_t (2 bytes).
 |11010000| - 5 bytes
      Integer encoded as int32_t (4 bytes).
 |11100000| - 9 bytes
      Integer encoded as int64_t (8 bytes).
 |11110000| - 4 bytes
      Integer encoded as 24 bit signed (3 bytes).
 |11111110| - 2 bytes
      Integer encoded as 8 bit signed (1 byte).
 |1111xxxx| - (with xxxx between 0000 and 1101) immediate 4 bit integer.
      Unsigned integer from 0 to 12. The encoded value is actually from
      1 to 13 because 0000 and 1111 can not be used, so 1 should be
      subtracted from the encoded 4 bit value to obtain the right value.
 |11111111| - End of ziplist special entry.</code></pre></div></div><div class=paragraph><p>引用在网上找的例子，来做个说明：</p></div><div class=imageblock><div class=content><img src=/images/redis/redis-ziplist-sample.png alt="redis ziplist sample"></div></div><div class="olist arabic"><ol class=arabic><li><p>这个ziplist一共包含 33 个字节。字节编号从 <code>byte[0]</code> 到 <code>byte[32]</code>。图中每个字节的值使用 16 进制表示。</p></li><li><p>头 4 个字节（<code>0x21000000</code>）是按小端（little endian）模式存储的 <code>&lt;zlbytes></code> 字段。什么是小端呢？就是指数据的低字节保存在内存的低地址中（参见维基百科词条 <a href=https://en.wikipedia.org/wiki/Endianness target=_blank rel=noopener>Endianness</a>）。因此，这里 <code>&lt;zlbytes></code> 的值应该解析成 <code>0x00000021</code>，用十进制表示正好就是33。</p></li><li><p>接下来 4 个字节（<code>byte[4..7]</code>）是 <code>&lt;zltail></code>，用小端存储模式来解释，它的值是 <code>0x0000001D</code>（值为29），表示最后一个数据项在 <code>byte[29]</code> 的位置（那个数据项为 <code>0x05FE14</code>）。</p></li><li><p>再接下来 2 个字节（<code>byte[8..9]</code>），值为 <code>0x0004</code>，表示这个 ziplist 里一共存有4项数据。</p></li><li><p>接下来 6 个字节（<code>byte[10..15]</code>）是第 1 个数据项。其中，<code>prevlen=0</code>，因为它前面没有数据项；<code>len=4</code>，相当于前面定义的9种情况中的第1种，表示后面4个字节按字符串存储数据，数据的值为：<code>name</code>。</p></li><li><p>接下来 8 个字节（<code>byte[16..23]</code>）是第 2 个数据项，与前面数据项存储格式类似，存储 1 个字符串：<code>tielei</code>。</p></li><li><p>接下来 5 个字节（<code>byte[24..28]</code>）是第 3 个数据项，与前面数据项存储格式类似，存储 1 个字符串： <code>age</code>。</p></li><li><p>接下来3个字节（<code>byte[29..31]</code>）是最后一个数据项，它的格式与前面的数据项存储格式不太一样。其中，第 1 个字节 <code>prevlen=5</code>，表示前一个数据项占用 5 个字节；第 2 个字节 = <code>FE</code>，相当于前面定义的9种情况中的第8种，所以后面还有1个字节用来表示真正的数据，并且以整数表示。它的值是20（0x14）。</p></li><li><p>最后1个字节（<code>byte[32]</code>）表示 <code>&lt;zlend></code>，是固定的值255（0xFF）。</p></li></ol></div><div class=paragraph><p>有两个问题需要注意：</p></div><div class="qlist qanda"><ol><li><p><em>如何反向遍历 ziplist ？</em></p><p><code>&lt;prevlen></code>: 表示前一个数据项占用的总字节数。那么就能找到前一个元素的起始位置，就能实现反向遍历。</p></li><li><p><em>如何从 ziplist 中添加/删除数据？删除数据后，对应位置的 Bits 位怎么处理？</em></p><p>在某个/某些节点的前面添加新节点之后， 程序必须沿着路径挨个检查后续的节点，是否满足新长度的编码要求， 直到遇到一个能满足要求的节点（如果有一个能满足，则这个节点之后的其他节点也满足）， 或者到达 ziplist 的末端 zlend 为止， 这种检查操作的复杂度为 O(N<sup>2</sup>) 。</p><div class=paragraph><p>因为只有在新添加节点的后面有连续多个长度接近 254 的节点时， 这种连锁更新才会发生， 所以可以普遍地认为， 这种连锁更新发生的概率非常小， 在一般情况下， 将添加操作看成是 O(N) 复杂度也是可以的。</p></div><div class=paragraph><p>删除元素就进行内存移位，覆盖 target 原本的数据，然后通过内存重分配，收缩多余空间。</p></div></li></ol></div><div class=paragraph><p>Redis 在下面这个几个地方使用了 ziplist：</p></div><div class="olist arabic"><ol class=arabic><li><p>列表包含少量的列表项，并且列表项只是整数或者短小的字符串时。（在下面 <a href=#quicklist>quicklist</a> 小节中，在最新版 Redis 中测试，显示的是 quicklist，而 quicklist 内部使用的是 ziplist 来存储数据，只是外面被 quicklist 包裹着。）</p></li><li><p>在哈希键值包含少量键值对，并且每个键值对只包含整数或短小字符串时。</p><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=nv>$ </span>redis-cli <span class=nt>--raw</span>

127.0.0.1:6379&gt; HMSET site domain <span class=s2>&#34;https://www.diguage.com&#34;</span> owner <span class=s2>&#34;D瓜哥&#34;</span>
OK

127.0.0.1:6379&gt; HGET site domain
https://www.diguage.com

127.0.0.1:6379&gt; HGET site owner
D瓜哥

127.0.0.1:6379&gt; TYPE site
<span class=nb>hash

</span>127.0.0.1:6379&gt; OBJECT encoding site
ziplist</code></pre></div></div></li></ol></div></div></div><div class=sect1><h2 id=quicklist>quicklist</h2><div class=sectionbody><div class=paragraph><p>Redis 对外暴露的 list 数据类型，它底层实现所依赖的内部数据结构就是 quicklist。</p></div><div class=paragraph><p>list 是一个能维持数据项先后顺序的列表（各个数据项的先后顺序由插入位置决定），便于在表的两端追加和删除数据，而对于中间位置的存取具有 O(N) 的时间复杂度。</p></div><div class=quoteblock><blockquote><div class=paragraph><p>quicklist.c - A doubly linked list of ziplists</p></div></blockquote><div class=attribution>— redis/quicklist.c</div></div><div class=paragraph><p>Redis 在 <code>quicklist.c</code> 就说明了，quicklist 是一个双向链表，而且是一个 ziplist 的双向链表。quicklist 的每个节点都是一个 ziplist。这样设计大概又是一个空间和时间的折中：</p></div><div class="olist arabic"><ol class=arabic><li><p>双向链表便于在表的两端进行 <code>push</code> 和 <code>pop</code> 操作，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。</p></li><li><p>ziplist 由于是一整块连续内存，所以存储效率很高。但是，它不利于修改操作，每次数据变动都会引发一次内存的 <code>realloc</code> 。特别是当 ziplist 长度很长的时候，一次 <code>realloc</code> 可能会导致大批量的数据拷贝，进一步降低性能。</p></li></ol></div><div class=paragraph><p>于是，结合了双向链表和 ziplist 的优点，quicklist 就应运而生了。</p></div><div class=paragraph><p>新问题：到底一个 quicklist 节点包含多长的 ziplist 合适呢？</p></div><div class="olist arabic"><ol class=arabic><li><p>每个quicklist节点上的ziplist越短，则内存碎片越多。</p></li><li><p>每个quicklist节点上的ziplist越长，则为ziplist分配大块连续内存空间的难度就越大。</p></li></ol></div><div class=paragraph><p>Redis 提供了一个配置参数 <code>list-max-ziplist-size</code> 让使用者可以来根据自己的情况进行调整:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code>list-max-ziplist-size -2</code></pre></div></div><div class=paragraph><p>这个参数可正可负：</p></div><div class=ulist><ul><li><p>当取正值的时候，表示按照数据项个数来限定每个 quicklist 节点上的 ziplist 长度。</p></li><li><p>当取负值的时候，表示按照占用字节数来限定每个 quicklist 节点上的 ziplist 长度。这时，它只能取 <code>-1</code> 到 <code>-5</code> 这五个值，每个值含义如下：</p><div class=ulist><ul><li><p><code>-5</code>: 每个 quicklist 节点上的 ziplist 大小不能超过 64 Kb。（注：1kb ⇒ 1024 bytes）</p></li><li><p><code>-4</code>: 每个 quicklist 节点上的 ziplist 大小不能超过 32 Kb。</p></li><li><p><code>-3</code>: 每个 quicklist 节点上的 ziplist 大小不能超过 16 Kb。</p></li><li><p><code>-2</code>: 每个 quicklist 节点上的 ziplist 大小不能超过 8 Kb。（-2是Redis给出的默认值）</p></li><li><p><code>-1</code>: 每个 quicklist 节点上的 ziplist 大小不能超过 4 Kb。</p></li></ul></div></li></ul></div><div class=paragraph><p>list的设计目标是能够用来存储很长的数据列表的。当列表很长的时候，最容易被访问的很可能是两端的数据，中间的数据被访问的频率比较低。list 还提供了一个选项，能够把中间的数据节点进行压缩，从而进一步节省内存空间。Redis 的配置参数 <code>list-compress-depth</code> 就是用来完成这个设置的。</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code>list-compress-depth 0 // 0 是特殊值，表示都不压缩，默认值。</code></pre></div></div><div class=paragraph><p>这个参数表示一个quicklist两端不被压缩的节点个数。注：这里的节点个数是指quicklist双向链表的节点个数，而不是指ziplist里面的数据项个数。一个 quicklist 节点上的 ziplist，如果被压缩，就是整体被压缩的。</p></div><div class=paragraph><p>Redis 对于 quicklist 内部节点的压缩算法，采用的 <a href=https://en.wikipedia.org/wiki/LZ4_(compression_algorithm) target=_blank rel=noopener>LZF</a> ——一种无损压缩算法。</p></div><div class=sidebarblock><div class=content><div class="olist arabic"><ol class=arabic><li><p>添加过程中，如何处理中间位置的压缩工作？</p></li><li><p>头部或者尾部删除，导致 quicklistNode 的非压缩节点不符合设置，怎么处理？</p></li><li><p>如果中间删除，节点为压缩节点，怎么处理？</p></li></ol></div></div></div><div class=listingblock><div class=title>quicklist.h</div><div class=content><pre class="rouge highlight"><code data-lang=c><span class=cm>/* Node, quicklist, and Iterator are the only data structures used currently. */</span>

<span class=cm>/* quicklistNode is a 32 byte struct describing a ziplist for a quicklist.
 * We use bit fields keep the quicklistNode at 32 bytes.
 * count: 16 bits, max 65536 (max zl bytes is 65k, so max count actually &lt; 32k).
 * encoding: 2 bits, RAW=1, LZF=2.
 * container: 2 bits, NONE=1, ZIPLIST=2.
 * recompress: 1 bit, bool, true if node is temporarry decompressed for usage.
 * attempted_compress: 1 bit, boolean, used for verifying during testing.
 * extra: 10 bits, free for future use; pads out the remainder of 32 bits */</span>
<span class=k>typedef</span> <span class=k>struct</span> <span class=n>quicklistNode</span> <span class=p>{</span>
    <span class=k>struct</span> <span class=n>quicklistNode</span> <span class=o>*</span><span class=n>prev</span><span class=p>;</span>
    <span class=k>struct</span> <span class=n>quicklistNode</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>zl</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>sz</span><span class=p>;</span>             <span class=cm>/* ziplist size in bytes */</span>
    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>count</span> <span class=o>:</span> <span class=mi>16</span><span class=p>;</span>     <span class=cm>/* count of items in ziplist */</span>
    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>encoding</span> <span class=o>:</span> <span class=mi>2</span><span class=p>;</span>   <span class=cm>/* RAW==1 or LZF==2 */</span>
    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>container</span> <span class=o>:</span> <span class=mi>2</span><span class=p>;</span>  <span class=cm>/* NONE==1 or ZIPLIST==2 */</span>
    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>recompress</span> <span class=o>:</span> <span class=mi>1</span><span class=p>;</span> <span class=cm>/* was this node previous compressed? */</span>
    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>attempted_compress</span> <span class=o>:</span> <span class=mi>1</span><span class=p>;</span> <span class=cm>/* node can&#39;t compress; too small */</span>
    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>extra</span> <span class=o>:</span> <span class=mi>10</span><span class=p>;</span> <span class=cm>/* more bits to steal for future usage */</span>
<span class=p>}</span> <span class=n>quicklistNode</span><span class=p>;</span>

<span class=cm>/* quicklistLZF is a 4+N byte struct holding &#39;sz&#39; followed by &#39;compressed&#39;.
 * &#39;sz&#39; is byte length of &#39;compressed&#39; field.
 * &#39;compressed&#39; is LZF data with total (compressed) length &#39;sz&#39;
 * NOTE: uncompressed length is stored in quicklistNode-&gt;sz.
 * When quicklistNode-&gt;zl is compressed, node-&gt;zl points to a quicklistLZF */</span>
<span class=k>typedef</span> <span class=k>struct</span> <span class=n>quicklistLZF</span> <span class=p>{</span>
    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>sz</span><span class=p>;</span> <span class=cm>/* LZF size in bytes*/</span>
    <span class=kt>char</span> <span class=n>compressed</span><span class=p>[];</span>
<span class=p>}</span> <span class=n>quicklistLZF</span><span class=p>;</span>

<span class=cm>/* Bookmarks are padded with realloc at the end of of the quicklist struct.
 * They should only be used for very big lists if thousands of nodes were the
 * excess memory usage is negligible, and there&#39;s a real need to iterate on them
 * in portions.
 * When not used, they don&#39;t add any memory overhead, but when used and then
 * deleted, some overhead remains (to avoid resonance).
 * The number of bookmarks used should be kept to minimum since it also adds
 * overhead on node deletion (searching for a bookmark to update). */</span>
<span class=k>typedef</span> <span class=k>struct</span> <span class=n>quicklistBookmark</span> <span class=p>{</span>
    <span class=n>quicklistNode</span> <span class=o>*</span><span class=n>node</span><span class=p>;</span>
    <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>;</span>
<span class=p>}</span> <span class=n>quicklistBookmark</span><span class=p>;</span>

<span class=cm>/* quicklist is a 40 byte struct (on 64-bit systems) describing a quicklist.
 * &#39;count&#39; is the number of total entries.
 * &#39;len&#39; is the number of quicklist nodes.
 * &#39;compress&#39; is: -1 if compression disabled, otherwise it&#39;s the number
 *                of quicklistNodes to leave uncompressed at ends of quicklist.
 * &#39;fill&#39; is the user-requested (or default) fill factor.
 * &#39;bookmakrs are an optional feature that is used by realloc this struct,
 *      so that they don&#39;t consume memory when not used. */</span>
<span class=k>typedef</span> <span class=k>struct</span> <span class=n>quicklist</span> <span class=p>{</span>
    <span class=n>quicklistNode</span> <span class=o>*</span><span class=n>head</span><span class=p>;</span>
    <span class=n>quicklistNode</span> <span class=o>*</span><span class=n>tail</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>count</span><span class=p>;</span>        <span class=cm>/* total count of all entries in all ziplists */</span>
    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>len</span><span class=p>;</span>          <span class=cm>/* number of quicklistNodes */</span>
    <span class=kt>int</span> <span class=n>fill</span> <span class=o>:</span> <span class=n>QL_FILL_BITS</span><span class=p>;</span>              <span class=cm>/* fill factor for individual nodes */</span>
    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>compress</span> <span class=o>:</span> <span class=n>QL_COMP_BITS</span><span class=p>;</span> <span class=cm>/* depth of end nodes not to compress;0=off */</span>
    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>bookmark_count</span><span class=o>:</span> <span class=n>QL_BM_BITS</span><span class=p>;</span>
    <span class=n>quicklistBookmark</span> <span class=n>bookmarks</span><span class=p>[];</span>
<span class=p>}</span> <span class=n>quicklist</span><span class=p>;</span>

<span class=k>typedef</span> <span class=k>struct</span> <span class=n>quicklistIter</span> <span class=p>{</span>
    <span class=k>const</span> <span class=n>quicklist</span> <span class=o>*</span><span class=n>quicklist</span><span class=p>;</span>
    <span class=n>quicklistNode</span> <span class=o>*</span><span class=n>current</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>zi</span><span class=p>;</span>
    <span class=kt>long</span> <span class=n>offset</span><span class=p>;</span> <span class=cm>/* offset in current ziplist */</span>
    <span class=kt>int</span> <span class=n>direction</span><span class=p>;</span>
<span class=p>}</span> <span class=n>quicklistIter</span><span class=p>;</span>

<span class=k>typedef</span> <span class=k>struct</span> <span class=n>quicklistEntry</span> <span class=p>{</span>
    <span class=k>const</span> <span class=n>quicklist</span> <span class=o>*</span><span class=n>quicklist</span><span class=p>;</span>
    <span class=n>quicklistNode</span> <span class=o>*</span><span class=n>node</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>zi</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>value</span><span class=p>;</span>
    <span class=kt>long</span> <span class=kt>long</span> <span class=n>longval</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>sz</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>offset</span><span class=p>;</span>
<span class=p>}</span> <span class=n>quicklistEntry</span><span class=p>;</span></code></pre></div></div><div class=imageblock><div class=content><img src=/images/redis/redis-quicklist-structure.png alt="redis quicklist structure"></div></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=bash><span class=nv>$ </span>redis-cli <span class=nt>--raw</span>

127.0.0.1:6379&gt; RPUSH names diguage <span class=s2>&#34;D瓜哥&#34;</span> <span class=s2>&#34;https://www.diguage.com/&#34;</span>
2

127.0.0.1:6379&gt; LRANGE names 0 <span class=nt>-1</span>
diguage
D瓜哥
https://www.diguage.com/

127.0.0.1:6379&gt; TYPE names
list

127.0.0.1:6379&gt; OBJECT encoding names
quicklist</code></pre></div></div><div class=paragraph><p>本文篇幅已经很长，其余数据结构，放在下一篇内容来讲解： <a href=https://www.diguage.com/post/redis-core-data-structure-2/>Redis 核心数据结构（2）</a>。</p></div></div></div><div class=sect1><h2 id=_参考资料>参考资料</h2><div class=sectionbody><div class="olist arabic"><ol class=arabic><li><p><a href=https://diguage.github.io/jdk-source-analysis/ target=_blank rel=noopener>JDK 源码分析</a></p></li><li><p><a href=http://zhangtielei.com/posts/blog-redis-ziplist.html target=_blank rel=noopener>Redis内部数据结构详解(4)——ziplist</a></p></li><li><p><a href=http://zhangtielei.com/posts/blog-redis-quicklist.html target=_blank rel=noopener>Redis内部数据结构详解(5)——quicklist</a></p></li><li><p><a href=https://programmer.help/blogs/redis-source-code-day-reading-compressed-list-ziplist.html target=_blank rel=noopener>[redis source code day reading] compressed list (ziplist)</a></p></li><li><p><a href=https://redisbook.readthedocs.io/en/latest/compress-datastruct/ziplist.html target=_blank rel=noopener>压缩列表 — Redis 设计与实现</a></p></li></ol></div></div></div></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E5%AD%98%E5%82%A8/ rel=tag>存储</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E8%AE%BE%E8%AE%A1/ rel=tag>设计</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E6%9E%B6%E6%9E%84/ rel=tag>架构</a></li></ul></div></footer></article></main><div class=clearfix><h3>看在D瓜哥码字的辛苦上，请友情支持一下，D瓜哥感激不尽，😜</h3><table><tr><td><img alt=微信打赏码 src=/images/wxpay.jpg></td><td><img alt=支付宝打赏码 src=/images/alipay.png></td></tr></table></div><br><div class=clearfix><h3>欢迎关注D瓜哥的微信公众号，在公众号可以获取我的微信二维码：</h3><img alt=微信公众号 src=/images/wx-jikerizhi.jpg></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><strong>公众号的微信号是: <code>jikerizhi</code></strong>。如果图片加载不出来，可以直接通过搜索公众号的微信号来查找D瓜哥的公众号。</td></tr></tbody></table></div><div class="authorbox clearfix"><figure class=authorbox__avatar><a target=_blank href=/about/><img alt="D瓜哥 avatar" src=/images/avatar.jpg class=avatar height=110 width=110></a></figure><div class=authorbox__header><span class=authorbox__name>关于 D瓜哥</span></div><div class=authorbox__description>厨艺界最好的码农，挨踢界最棒的厨师。<ul><li><a target=_blank href=https://wordpress.diguage.com/>旧版“地瓜哥”博客网</a></li><li><a target=_blank href=https://notes.diguage.com/mysql/>MySQL 学习笔记<sup>Alpha</sup></a></li><li><a target=_blank href=https://diguage.github.io/jdk-source-analysis/>JDK 源码分析<sup>Alpha</sup></a></li></ul></div></div><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=/post/kafka-interview-questions/ rel=prev><span class=pager__subtitle>«&#8201;上一篇</span><p class=pager__title>Kafka 常见面试题</p></a></div><div class="pager__item pager__item--next"><a class=pager__link href=/post/redis-core-data-structure-2/ rel=next><span class=pager__subtitle>下一篇&#8201;»</span><p class=pager__title>Redis 核心数据结构（二）</p></a></div></nav><section class=comments><div id=SOHUCS sid=/post/redis-core-data-structure-1/></div><script type=text/javascript>(function(){if(window.location.hostname==="localhost")return;var n,e="cyuuTeBp3",t="prod_2906c47c31e735e0ed518282fec489a6",s=window.innerWidth||document.documentElement.clientWidth;s<960?window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id='+e+"&conf="+t+'"><\/script>'):(n=function(e,t){var s=document.getElementsByTagName("head")[0]||document.head||document.documentElement,n=document.createElement("script");n.setAttribute("type","text/javascript"),n.setAttribute("charset","UTF-8"),n.setAttribute("src",e),typeof t=="function"&&(window.attachEvent?n.onreadystatechange=function(){var e=n.readyState;(e==="loaded"||e==="complete")&&(n.onreadystatechange=null,t())}:n.onload=t),s.appendChild(n)},n("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:e,conf:t})}))})()</script></section></div><aside class=sidebar><div class="widget-search widget"><form class=widget-search__form role=search method=get action=https://google.com/search><label><input class=widget-search__field type=search placeholder=搜索… name=q aria-label=搜索…>
</label><input class=widget-search__submit type=submit value=Search>
<input type=hidden name=sitesearch value=https://www.diguage.com/></form></div><div class="widget-wechat widget"><h4 class=widget__title>微信公众号</h4><img alt=微信公众号 class=center src=/images/wx-jikerizhi-qrcode.jpg></div><div class="widget-wechat widget"><h4 class=widget__title>知识星球</h4><img alt=微信公众号 class=center src=/images/zhishixingqiu.png></div><div class="widget-recent widget"><h4 class=widget__title>近期文章</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/post/spring-boot-startup-process-overview/>Spring Boot 启动流程概述</a></li><li class=widget__item><a class=widget__link href=/post/redis-core-data-structure-4/>Redis 核心数据结构（四）</a></li><li class=widget__item><a class=widget__link href=/post/redis-core-data-structure-3/>Redis 核心数据结构（三）</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-subsets/>算法模式：子集</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-backtracking/>算法模式：回溯</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-transform-and-conquer/>算法模式：变治法</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-divide-and-conquer/>算法模式：分治法</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-decrease-and-conquer/>算法模式：减治法</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-topological-sort/>算法模式：拓扑排序</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-union-find/>算法模式：并查集</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-trie/>算法模式：前缀树</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-depth-first-search/>算法模式：深度优先搜索</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-breadth-first-search/>算法模式：广度优先搜索</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-k-way-merge/>算法模式：多路归并</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-two-heaps/>算法模式：双堆</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-cyclic-sort/>算法模式：循环排序</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-quickselect/>算法模式：快速选择</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-top-k-elements/>算法模式：Top K 问题</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-monotonic-stack/>算法模式：单调栈</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-sliding-window/>算法模式：滑动窗口</a></li></ul></div></div><div class="widget-categories widget"><h4 class=widget__title>分类</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/categories/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/>个人成长</a></li><li class=widget__item><a class=widget__link href=/categories/%E5%88%86%E5%B8%83%E5%BC%8F/>分布式</a></li><li class=widget__item><a class=widget__link href=/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/>开发工具</a></li><li class=widget__item><a class=widget__link href=/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/>性能优化</a></li><li class=widget__item><a class=widget__link href=/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a></li><li class=widget__item><a class=widget__link href=/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/>数据存储</a></li><li class=widget__item><a class=widget__link href=/categories/%E6%96%87%E5%AD%A6/>文学</a></li><li class=widget__item><a class=widget__link href=/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/>方法论</a></li><li class=widget__item><a class=widget__link href=/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/>程序设计</a></li><li class=widget__item><a class=widget__link href=/categories/%E7%AE%97%E6%B3%95/>算法</a></li><li class=widget__item><a class=widget__link href=/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/>系统架构</a></li><li class=widget__item><a class=widget__link href=/categories/%E7%BB%8F%E6%B5%8E%E9%87%91%E8%9E%8D/>经济金融</a></li><li class=widget__item><a class=widget__link href=/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/>编程语言</a></li><li class=widget__item><a class=widget__link href=/categories/%E7%BD%91%E7%BB%9C/>网络</a></li><li class=widget__item><a class=widget__link href=/categories/%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95/>职业发展</a></li><li class=widget__item><a class=widget__link href=/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/>软件工程</a></li><li class=widget__item><a class=widget__link href=/categories/%E9%80%B8%E9%97%BB%E8%B6%A3%E4%BA%8B/>逸闻趣事</a></li><li class=widget__item><a class=widget__link href=/categories/%E9%98%85%E8%AF%BB%E6%91%98%E8%A6%81/>阅读摘要</a></li></ul></div></div><div class="widget-taglist widget"><h4 class=widget__title>标签</h4><div class=widget__content><a class="widget-taglist__link widget__link btn" href=/tags/gc/ title=GC>GC (9)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/http/ title=HTTP>HTTP (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/java/ title=Java>Java (64)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/jvm/ title=JVM>JVM (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/kpi/ title=KPI>KPI (4)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/kubernetes/ title=Kubernetes>Kubernetes (10)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/linux/ title=Linux>Linux (12)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/okr/ title=OKR>OKR (5)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/redis/ title=Redis>Redis (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/shell/ title=Shell>Shell (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/spring/ title=Spring>Spring (26)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/tcp/ title=TCP>TCP (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/udp/ title=UDP>UDP (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/zookeeper/ title=ZooKeeper>ZooKeeper (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E4%B8%AA%E4%BA%BA%E6%8F%90%E5%8D%87/ title=个人提升>个人提升 (10)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E4%B9%A6%E7%B1%8D/ title=书籍>书籍 (15)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E4%BA%A7%E5%93%81/ title=产品>产品 (7)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%80%BA%E5%88%B8/ title=债券>债券 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F/ title=分布式>分布式 (15)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%88%86%E6%B2%BB/ title=分治>分治 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/ title=动态规划>动态规划 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%9B%A2%E9%98%9F%E5%BB%BA%E8%AE%BE/ title=团队建设>团队建设 (6)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%9B%A2%E9%98%9F%E6%96%87%E5%8C%96/ title=团队文化>团队文化 (4)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%9B%BE/ title=图>图 (7)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%9F%BA%E9%87%91/ title=基金>基金 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%A0%86/ title=堆>堆 (3)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%AD%98%E5%82%A8/ title=存储>存储 (6)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95/ title=工作方法>工作方法 (5)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%B9%B6%E5%8F%91/ title=并发>并发 (3)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%BA%8F%E5%88%97%E5%8C%96/ title=序列化>序列化 (10)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/ title=微服务>微服务 (17)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%BF%83%E7%90%86%E5%AD%A6/ title=心理学>心理学 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/ title=性能测试>性能测试 (4)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2/ title=投资理财>投资理财 (5)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/ title=数据库>数据库 (10)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ title=数据结构>数据结构 (4)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%95%B0%E7%BB%84/ title=数组>数组 (13)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/ title=方法论>方法论 (13)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%97%85%E8%A1%8C/ title=旅行>旅行 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/ title=最佳实践>最佳实践 (10)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%9E%B6%E6%9E%84/ title=架构>架构 (44)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%A0%88/ title=栈>栈 (3)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%A0%91/ title=树>树 (11)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%B2%9F%E9%80%9A%E6%8A%80%E5%B7%A7/ title=沟通技巧>沟通技巧 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ title=源码分析>源码分析 (8)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E7%90%86%E8%B4%A2/ title=理财>理财 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E7%94%9F%E6%B4%BB/ title=生活>生活 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E7%AC%94%E8%AE%B0/ title=笔记>笔记 (5)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E7%AE%97%E6%B3%95/ title=算法>算法 (8)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%BC%8F/ title=算法模式>算法模式 (23)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E7%BB%8F%E6%B5%8E/ title=经济>经济 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E7%BC%96%E7%A0%81/ title=编码>编码 (3)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E7%BD%91%E7%BB%9C/ title=网络>网络 (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E7%BF%BB%E8%AF%91/ title=翻译>翻译 (7)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E8%82%A1%E7%A5%A8/ title=股票>股票 (5)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E8%84%91%E5%9B%BE/ title=脑图>脑图 (5)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E8%8A%82%E6%97%A5/ title=节日>节日 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E8%8B%B1%E8%AF%AD/ title=英语>英语 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/ title=虚拟机>虚拟机 (9)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E8%AE%BA%E6%96%87/ title=论文>论文 (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E8%AE%BE%E8%AE%A1/ title=设计>设计 (36)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ title=设计模式>设计模式 (3)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E8%AF%97%E6%AD%8C/ title=诗歌>诗歌 (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E8%AF%BB%E4%B9%A6/ title=读书>读书 (5)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E9%80%92%E5%BD%92/ title=递归>递归 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E9%87%91%E8%9E%8D/ title=金融>金融 (5)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E9%93%BE%E8%A1%A8/ title=链表>链表 (5)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/ title=面向对象>面向对象 (5)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/ title=领域驱动设计>领域驱动设计 (5)</a></div></div><div class="widget-social widget"><h4 class="widget-social__title widget__title">社交</h4><div class="widget-social__content widget__content"><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=Twitter rel="noopener noreferrer" href=https://twitter.com/diguage target=_blank><svg class="widget-social__link-icon icon icon-twitter" width="24" height="24" viewBox="0 0 384 312"><path d="m384 36.9c-14.1 6.3-29.3 10.5-45.2 12.4 16.3-9.7 28.8-25.2 34.6-43.6-15.2 9-32.1 15.6-50 19.1-14.4-15.2-34.9-24.8-57.5-24.8-43.5.0-78.8 35.3-78.8 78.8.0 6.2.7 12.2 2 17.9-65.5-3.3-123.5-34.6-162.4-82.3C20 26 16.1 39.6 16.1 54c0 27.3 13.9 51.4 35 65.6-12.9-.4-25.1-4-35.7-9.9v1c0 38.2 27.2 70 63.2 77.2-6.6 1.8-13.6 2.8-20.8 2.8-5.1.0-10-.5-14.8-1.4 10 31.3 39.1 54.1 73.6 54.7-27 21.1-60.9 33.7-97.8 33.7-6.4.0-12.6-.4-18.8-1.1C34.9 299 76.3 312 120.8 312c144.9.0 224.1-120 224.1-224.1.0-3.4-.1-6.8-.2-10.2 15.4-11.1 28.7-25 39.3-40.8z"/></svg>
<span>Twitter</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=GitHub rel="noopener noreferrer" href=https://github.com/diguage target=_blank><svg class="widget-social__link-icon icon icon-github" width="24" height="24" viewBox="0 0 384 374"><path d="m192 0C85.9.0.0 85.8.0 191.7c0 84.7 55 156.6 131.3 181.9 9.6 1.8 13.1-4.2 13.1-9.2.0-4.6-.2-16.6-.3-32.6-53.4 11.6-64.7-25.7-64.7-25.7-8.7-22.1-21.3-28-21.3-28-17.4-11.9 1.3-11.6 1.3-11.6 19.3 1.4 29.4 19.8 29.4 19.8 17.1 29.3 44.9 20.8 55.9 15.9 1.7-12.4 6.7-20.8 12.2-25.6-42.6-4.8-87.5-21.3-87.5-94.8.0-20.9 7.5-38 19.8-51.4-2-4.9-8.6-24.3 1.9-50.7.0.0 16.1-5.2 52.8 19.7 15.3-4.2 31.7-6.4 48.1-6.5 16.3.1 32.7 2.2 48.1 6.5 36.7-24.8 52.8-19.7 52.8-19.7 10.5 26.4 3.9 45.9 1.9 50.7 12.3 13.4 19.7 30.5 19.7 51.4.0 73.7-44.9 89.9-87.7 94.6 6.9 5.9 13 17.6 13 35.5.0 25.6-.2 46.3-.2 52.6.0 5.1 3.5 11.1 13.2 9.2C329 348.2 384 276.4 384 191.7 384 85.8 298 0 192 0z"/></svg>
<span>GitHub</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=Email href=mailto:leejun119@gmail.com><svg class="widget-social__link-icon icon icon-mail" width="24" height="24" viewBox="0 0 416 288"><path d="m0 16v256 16h16 384 16v-16V16 0h-16H16 0zm347 16-139 92.5L69 32zM199 157.5l9 5.5 9-5.5L384 46v210H32V46z"/></svg>
<span>leejun119@gmail.com</span></a></div></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 "地瓜哥"博客网.
<span class=footer__copyright-credits>基于 <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> 引擎和 <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> 主题</span>
<span><a href=https://beian.miit.gov.cn/ target=_target>京ICP备14046450号-4</a></span></div></div></footer></div><script async defer src=/js/menu.js></script><script type=text/x-mathjax-config>
	MathJax.Hub.Config({
	  messageStyle: "none",
	  tex2jax: {
		inlineMath: [["\\(", "\\)"]],
		displayMath: [["\\[", "\\]"]],
		ignoreClass: "nostem|nolatexmath"
	  },
	  asciimath2jax: {
		delimiters: [["\\$", "\\$"]],
		ignoreClass: "nostem|noasciimath"
	  },
	  TeX: { equationNumbers: { autoNumber: "none" } }
	})
	MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
	  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
		if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
		  data.math.root.display = "block"
		}
		return data
	  })
	})
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML" async></script></body></html>