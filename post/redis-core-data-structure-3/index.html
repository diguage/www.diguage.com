<!doctype html><html class=no-js lang=zh-cn><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Redis 核心数据结构（三） - "地瓜哥"博客网</title>
<script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=keywords content="Redis,存储,设计,架构,程序设计,算法,分布式"><meta name=description content><meta property="og:url" content="https://www.diguage.com/post/redis-core-data-structure-3/"><meta property="og:site_name" content='"地瓜哥"博客网'><meta property="og:title" content="Redis 核心数据结构（三）"><meta property="og:description" content=" 在五年前，D瓜哥写了 Redis 核心数据结构（一） 和 Redis 核心数据结构（二） 两篇文章，来对 Redis 内部的数据结构做了深入分析。随着时间的推移，Redis 的实现也在不断进化，现在这些内容已经跟不上最新发展了，推陈出新，现在重写文章，来介绍 Redis 的最新发展。
listpack 从 Redis 7.0 开始，使用 listpack 替换原来的 ziplist。至于替换原因，在 [NEW] listpack migration - replace all usage of ziplist with listpack 做了解释说明：
The reason for using listpack instead of ziplist is that ziplist may cause cascading updates when insert and delete in middle, which is the biggest problem.
— sundb 翻译过来：当在中间进行插入和删除时，ziplist 也许会产生级联更新，这是一个大问题。
编码规范 图 1. listpack 编码格式 相比 ziplist，listpack 更偏向空间换时间。淡化极致的内存使用率，向更快的方向发力。
对整数编码 "><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-06-13T17:36:31+08:00"><meta property="article:modified_time" content="2025-06-17T14:22:38+08:00"><meta property="article:tag" content="存储"><meta property="article:tag" content="设计"><meta property="article:tag" content="架构"><meta name=twitter:card content="summary"><meta name=twitter:title content="Redis 核心数据结构（三）"><meta name=twitter:description content=" 在五年前，D瓜哥写了 Redis 核心数据结构（一） 和 Redis 核心数据结构（二） 两篇文章，来对 Redis 内部的数据结构做了深入分析。随着时间的推移，Redis 的实现也在不断进化，现在这些内容已经跟不上最新发展了，推陈出新，现在重写文章，来介绍 Redis 的最新发展。
listpack 从 Redis 7.0 开始，使用 listpack 替换原来的 ziplist。至于替换原因，在 [NEW] listpack migration - replace all usage of ziplist with listpack 做了解释说明：
The reason for using listpack instead of ziplist is that ziplist may cause cascading updates when insert and delete in middle, which is the biggest problem.
— sundb 翻译过来：当在中间进行插入和删除时，ziplist 也许会产生级联更新，这是一个大问题。
编码规范 图 1. listpack 编码格式 相比 ziplist，listpack 更偏向空间换时间。淡化极致的内存使用率，向更快的方向发力。
对整数编码 "><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/css/asciidoctor.css><link rel=stylesheet href=/css/rouge-monokai.css><link rel="shortcut icon" href=/favicon.ico><script async src="https://www.googletagmanager.com/gtag/js?id=G-1MMT2NLEL4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-1MMT2NLEL4")}</script><script id=baidu_analytics>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?e56e7dd0a120b414f5741f4c5e5218ea",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title='"地瓜哥"博客网' rel=home><div class="logo__item logo__text"><div class=logo__title>"地瓜哥"博客网</div><div class=logo__tagline>分享技术带来的喜悦 — https://www.diguage.com/</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>菜单</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>首页</span></a></li><li class=menu__item><a class=menu__link href=/categories/><span class=menu__text>分类</span></a></li><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>关于</span></a></li><li class=menu__item><a class=menu__link href=/archives/><span class=menu__text>归档</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Redis 核心数据结构（三）</h1><div class="post__meta meta"><div class="meta__item-author meta__item"><svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2.0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class=meta__text>D瓜哥</span></div><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2025-06-13T17:36:31+08:00>2025-06-13</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/ rel=category>程序设计</a>, <a class=meta__link href=/categories/%E7%AE%97%E6%B3%95/ rel=category>算法</a>, <a class=meta__link href=/categories/%E5%88%86%E5%B8%83%E5%BC%8F/ rel=category>分布式</a></span></div></div></header><figure class="post__thumbnail thumbnail"><img class=thumbnail__image src=/images/redis/redis-logo.png alt="Redis 核心数据结构（三）"></figure><div class="content post__content clearfix"><div class=paragraph><p>在五年前，D瓜哥写了 <a href=https://www.diguage.com/post/redis-core-data-structure-1/ target=_blank rel=noopener>Redis 核心数据结构（一）</a> 和 <a href=https://www.diguage.com/post/redis-core-data-structure-2/ target=_blank rel=noopener>Redis 核心数据结构（二）</a> 两篇文章，来对 Redis 内部的数据结构做了深入分析。随着时间的推移，Redis 的实现也在不断进化，现在这些内容已经跟不上最新发展了，推陈出新，现在重写文章，来介绍 Redis 的最新发展。</p></div><div class=sect1><h2 id=_listpack>listpack</h2><div class=sectionbody><div class=paragraph><p>从 Redis 7.0 开始，使用 listpack 替换原来的 ziplist。至于替换原因，在 <a href=https://github.com/redis/redis/issues/8702 target=_blank rel=noopener>[NEW] listpack migration - replace all usage of ziplist with listpack</a> 做了解释说明：</p></div><div class=quoteblock><blockquote><div class=paragraph><p>The reason for using listpack instead of ziplist is that ziplist may cause cascading updates when insert and delete in middle, which is the biggest problem.</p></div></blockquote><div class=attribution>— sundb</div></div><div class=paragraph><p>翻译过来：当在中间进行插入和删除时，ziplist 也许会产生级联更新，这是一个大问题。</p></div><div class=sect2><h3 id=_编码规范>编码规范</h3><div class="imageblock text-center"><div class=content><img src=/images/redis/listpack.png alt="listpack 编码格式" width=95%></div><div class=title>图 1. listpack 编码格式</div></div><div class=paragraph><p>相比 ziplist，listpack 更偏向空间换时间。淡化极致的内存使用率，向更快的方向发力。</p></div><div class=sect3><h4 id=integer>对整数编码</h4><div class="imageblock text-center"><div class=content><img src=/images/redis/listpack-integer.png alt="listpack 整数编码" width=95%></div><div class=title>图 2. listpack 整数编码</div></div><div class=paragraph><p>Redis 对整数以及长整数的编码与 <a href=https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-1/#int target=_blank rel=noopener>Hessian 协议解释与实战（一）：布尔、日期、浮点数与整数：整数类型数据</a> 和 <a href=https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-2/#long target=_blank rel=noopener>Hessian 协议解释与实战（二）：长整型、二进制数据与 Null：长整数类型数据</a> 的编码类似：小数尽可能使用短编码；大数才用长编码。由于小数偏多，所以，可以节省相当一部分内存。</p></div><div class=listingblock><div class=title><code>listpack.c</code></div><div class=content><pre class="rouge highlight nowrap"><code data-lang=c><span class=cp>#define LP_ENCODING_13BIT_INT 0xC0
#define LP_ENCODING_13BIT_INT_MASK 0xE0
#define LP_ENCODING_IS_13BIT_INT(byte) (((byte)&amp;LP_ENCODING_13BIT_INT_MASK)==LP_ENCODING_13BIT_INT)
#define LP_ENCODING_13BIT_INT_ENTRY_SIZE 3
</span>
<span class=cp>#define LP_ENCODING_16BIT_INT 0xF1
#define LP_ENCODING_16BIT_INT_MASK 0xFF
#define LP_ENCODING_IS_16BIT_INT(byte) (((byte)&amp;LP_ENCODING_16BIT_INT_MASK)==LP_ENCODING_16BIT_INT)
#define LP_ENCODING_16BIT_INT_ENTRY_SIZE 4
</span>
<span class=cp>#define LP_ENCODING_24BIT_INT 0xF2
#define LP_ENCODING_24BIT_INT_MASK 0xFF
#define LP_ENCODING_IS_24BIT_INT(byte) (((byte)&amp;LP_ENCODING_24BIT_INT_MASK)==LP_ENCODING_24BIT_INT)
#define LP_ENCODING_24BIT_INT_ENTRY_SIZE 5
</span>
<span class=cp>#define LP_ENCODING_32BIT_INT 0xF3
#define LP_ENCODING_32BIT_INT_MASK 0xFF
#define LP_ENCODING_IS_32BIT_INT(byte) (((byte)&amp;LP_ENCODING_32BIT_INT_MASK)==LP_ENCODING_32BIT_INT)
#define LP_ENCODING_32BIT_INT_ENTRY_SIZE 6
</span>
<span class=cp>#define LP_ENCODING_64BIT_INT 0xF4
#define LP_ENCODING_64BIT_INT_MASK 0xFF
#define LP_ENCODING_IS_64BIT_INT(byte) (((byte)&amp;LP_ENCODING_64BIT_INT_MASK)==LP_ENCODING_64BIT_INT)
#define LP_ENCODING_64BIT_INT_ENTRY_SIZE 10
</span>
<span class=cm>/* Stores the integer encoded representation of &#39;v&#39; in the &#39;intenc&#39; buffer. */</span>
<span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>lpEncodeIntegerGetType</span><span class=p>(</span><span class=kt>int64_t</span> <span class=n>v</span><span class=p>,</span>
        <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>intenc</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=o>*</span><span class=n>enclen</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>v</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>v</span> <span class=o>&lt;=</span> <span class=mi>127</span><span class=p>)</span> <span class=p>{</span>
        <span class=cm>/* Single byte 0-127 integer. */</span>
        <span class=c1>// if (intenc != NULL) intenc[0] = v;</span>
        <span class=c1>// 0 &lt;= num &lt;= 127，则使用一个字节表示</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>enclen</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>*</span><span class=n>enclen</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>v</span> <span class=o>&gt;=</span> <span class=o>-</span><span class=mi>4096</span> <span class=o>&amp;&amp;</span> <span class=n>v</span> <span class=o>&lt;=</span> <span class=mi>4095</span><span class=p>)</span> <span class=p>{</span>
        <span class=cm>/* 13 bit integer. */</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>v</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=n>v</span> <span class=o>=</span> <span class=p>((</span><span class=kt>int64_t</span><span class=p>)</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>13</span><span class=p>)</span><span class=o>+</span><span class=n>v</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>intenc</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// -4096 &lt;= num &lt;= 4095 使用 13 个比特位表示，</span>
            <span class=c1>// LP_ENCODING_13BIT_INT = 0xC0，前三位是类型标识</span>
            <span class=c1>// 两个字节，剩下 13 个比特位用于存数字（首位表示符号，12位存数字）</span>
            <span class=n>intenc</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>v</span><span class=o>&gt;&gt;</span><span class=mi>8</span><span class=p>)</span><span class=o>|</span><span class=n>LP_ENCODING_13BIT_INT</span><span class=p>;</span>
            <span class=n>intenc</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>v</span><span class=o>&amp;</span><span class=mh>0xff</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=c1>// 编码长度为 2</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>enclen</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>*</span><span class=n>enclen</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>v</span> <span class=o>&gt;=</span> <span class=o>-</span><span class=mi>32768</span> <span class=o>&amp;&amp;</span> <span class=n>v</span> <span class=o>&lt;=</span> <span class=mi>32767</span><span class=p>)</span> <span class=p>{</span>
        <span class=cm>/* 16 bit integer. */</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>v</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=n>v</span> <span class=o>=</span> <span class=p>((</span><span class=kt>int64_t</span><span class=p>)</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>16</span><span class=p>)</span><span class=o>+</span><span class=n>v</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>intenc</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// 一个字节是类型标识</span>
            <span class=n>intenc</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>LP_ENCODING_16BIT_INT</span><span class=p>;</span>
            <span class=c1>// 剩下两个字节，16 个比特位存数字（首位表示符号，15位存数字）</span>
            <span class=n>intenc</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>v</span><span class=o>&amp;</span><span class=mh>0xff</span><span class=p>;</span>
            <span class=n>intenc</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=n>v</span><span class=o>&gt;&gt;</span><span class=mi>8</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=c1>// 编码长度为 3</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>enclen</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>*</span><span class=n>enclen</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>v</span> <span class=o>&gt;=</span> <span class=o>-</span><span class=mi>8388608</span> <span class=o>&amp;&amp;</span> <span class=n>v</span> <span class=o>&lt;=</span> <span class=mi>8388607</span><span class=p>)</span> <span class=p>{</span>
        <span class=cm>/* 24 bit integer. */</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>v</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=n>v</span> <span class=o>=</span> <span class=p>((</span><span class=kt>int64_t</span><span class=p>)</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>24</span><span class=p>)</span><span class=o>+</span><span class=n>v</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>intenc</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// 一个字节是类型标识</span>
            <span class=n>intenc</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>LP_ENCODING_24BIT_INT</span><span class=p>;</span>
            <span class=c1>// 剩下 3 个字节，24 个比特位存数字（首位表示符号，15位存数字）</span>
            <span class=n>intenc</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>v</span><span class=o>&amp;</span><span class=mh>0xff</span><span class=p>;</span>
            <span class=n>intenc</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>v</span><span class=o>&gt;&gt;</span><span class=mi>8</span><span class=p>)</span><span class=o>&amp;</span><span class=mh>0xff</span><span class=p>;</span>
            <span class=n>intenc</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=n>v</span><span class=o>&gt;&gt;</span><span class=mi>16</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=c1>// 编码长度为 4</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>enclen</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>*</span><span class=n>enclen</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>v</span> <span class=o>&gt;=</span> <span class=o>-</span><span class=mi>2147483648</span> <span class=o>&amp;&amp;</span> <span class=n>v</span> <span class=o>&lt;=</span> <span class=mi>2147483647</span><span class=p>)</span> <span class=p>{</span>
        <span class=cm>/* 32 bit integer. */</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>v</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=n>v</span> <span class=o>=</span> <span class=p>((</span><span class=kt>int64_t</span><span class=p>)</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>32</span><span class=p>)</span><span class=o>+</span><span class=n>v</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>intenc</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// 一个字节是类型标识</span>
            <span class=n>intenc</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>LP_ENCODING_32BIT_INT</span><span class=p>;</span>
            <span class=c1>// 剩下 4 个字节，32 个比特位存数字（首位表示符号，15位存数字）</span>
            <span class=n>intenc</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>v</span><span class=o>&amp;</span><span class=mh>0xff</span><span class=p>;</span>
            <span class=n>intenc</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>v</span><span class=o>&gt;&gt;</span><span class=mi>8</span><span class=p>)</span><span class=o>&amp;</span><span class=mh>0xff</span><span class=p>;</span>
            <span class=n>intenc</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>v</span><span class=o>&gt;&gt;</span><span class=mi>16</span><span class=p>)</span><span class=o>&amp;</span><span class=mh>0xff</span><span class=p>;</span>
            <span class=n>intenc</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=n>v</span><span class=o>&gt;&gt;</span><span class=mi>24</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=c1>// 编码长度为 5</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>enclen</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>*</span><span class=n>enclen</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=cm>/* 64 bit integer. */</span>
        <span class=kt>uint64_t</span> <span class=n>uv</span> <span class=o>=</span> <span class=n>v</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>intenc</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// 一个字节是类型标识</span>
            <span class=n>intenc</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>LP_ENCODING_64BIT_INT</span><span class=p>;</span>
            <span class=c1>// 剩下 8 个字节，64 个比特位存数字（首位表示符号，15位存数字）</span>
            <span class=n>intenc</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>uv</span><span class=o>&amp;</span><span class=mh>0xff</span><span class=p>;</span>
            <span class=n>intenc</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>uv</span><span class=o>&gt;&gt;</span><span class=mi>8</span><span class=p>)</span><span class=o>&amp;</span><span class=mh>0xff</span><span class=p>;</span>
            <span class=n>intenc</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>uv</span><span class=o>&gt;&gt;</span><span class=mi>16</span><span class=p>)</span><span class=o>&amp;</span><span class=mh>0xff</span><span class=p>;</span>
            <span class=n>intenc</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>uv</span><span class=o>&gt;&gt;</span><span class=mi>24</span><span class=p>)</span><span class=o>&amp;</span><span class=mh>0xff</span><span class=p>;</span>
            <span class=n>intenc</span><span class=p>[</span><span class=mi>5</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>uv</span><span class=o>&gt;&gt;</span><span class=mi>32</span><span class=p>)</span><span class=o>&amp;</span><span class=mh>0xff</span><span class=p>;</span>
            <span class=n>intenc</span><span class=p>[</span><span class=mi>6</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>uv</span><span class=o>&gt;&gt;</span><span class=mi>40</span><span class=p>)</span><span class=o>&amp;</span><span class=mh>0xff</span><span class=p>;</span>
            <span class=n>intenc</span><span class=p>[</span><span class=mi>7</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>uv</span><span class=o>&gt;&gt;</span><span class=mi>48</span><span class=p>)</span><span class=o>&amp;</span><span class=mh>0xff</span><span class=p>;</span>
            <span class=n>intenc</span><span class=p>[</span><span class=mi>8</span><span class=p>]</span> <span class=o>=</span> <span class=n>uv</span><span class=o>&gt;&gt;</span><span class=mi>56</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=c1>// 编码长度为 9</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>enclen</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>*</span><span class=n>enclen</span> <span class=o>=</span> <span class=mi>9</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span></code></pre></div></div></div><div class=sect3><h4 id=string>对字符串编码</h4><div class="imageblock text-center"><div class=content><img src=/images/redis/listpack-string.png alt="listpack 字符串编码" width=95%></div><div class=title>图 3. listpack 字符串编码</div></div><div class=paragraph><p>对比 Hessian 对字符串的编码 <a href=https://www.diguage.com/post/hessian-protocol-interpretation-and-practice-3/ target=_blank rel=noopener>Hessian 协议解释与实战（三）：字符串</a>，两者也有相似之处：</p></div><div class="olist arabic"><ol class=arabic><li><p><code>类型标识</code> + <code>字符串长度</code> + <code>实际字符串内容</code>；</p></li><li><p>短字符串使用短码编码长度，长字符串使用长码编码长度。由于短字符串更多，也能节省很多内存。</p></li></ol></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><i class="fa icon-note" title=Note></i></td><td class=content>Redis 对字符串是如何编码的？</td></tr></tbody></table></div><div class=listingblock><div class=title><code>listpack.c</code></div><div class=content><pre class="rouge highlight nowrap"><code data-lang=c><span class=cp>#define LP_ENCODING_6BIT_STR 0x80
#define LP_ENCODING_6BIT_STR_MASK 0xC0
#define LP_ENCODING_IS_6BIT_STR(byte) (((byte)&amp;LP_ENCODING_6BIT_STR_MASK)==LP_ENCODING_6BIT_STR)
</span>
<span class=cp>#define LP_ENCODING_12BIT_STR 0xE0
#define LP_ENCODING_12BIT_STR_MASK 0xF0
#define LP_ENCODING_IS_12BIT_STR(byte) (((byte)&amp;LP_ENCODING_12BIT_STR_MASK)==LP_ENCODING_12BIT_STR)
</span>
<span class=cp>#define LP_ENCODING_32BIT_STR 0xF0
#define LP_ENCODING_32BIT_STR_MASK 0xFF
#define LP_ENCODING_IS_32BIT_STR(byte) (((byte)&amp;LP_ENCODING_32BIT_STR_MASK)==LP_ENCODING_32BIT_STR)
</span>

<span class=cm>/* Encode the string element pointed by &#39;s&#39; of size &#39;len&#39; in the target
 * buffer &#39;s&#39;. The function should be called with &#39;buf&#39; having always enough
 * space for encoding the string. This is done by calling lpEncodeGetType()
 * before calling this function. */</span>
<span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>lpEncodeString</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>s</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>len</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>len</span> <span class=o>&lt;</span> <span class=mi>64</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// LP_ENCODING_6BIT_STR = 0x80 | length，length 最多有 6 个比特位，则最大数字是： 2^6 -1 = 63</span>
        <span class=n>buf</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>len</span> <span class=o>|</span> <span class=n>LP_ENCODING_6BIT_STR</span><span class=p>;</span>
        <span class=c1>// 将字符串内容复制到后面的内存中</span>
        <span class=n>memcpy</span><span class=p>(</span><span class=n>buf</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span><span class=n>s</span><span class=p>,</span><span class=n>len</span><span class=p>);</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>len</span> <span class=o>&lt;</span> <span class=mi>4096</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// LP_ENCODING_12BIT_STR = 0xE0，前四个比特位存类型标识</span>
        <span class=c1>// 剩余 4 个比特位存长度： (lenght &gt;&gt; 8) | LP_ENCODING_12BIT_STR</span>
        <span class=c1>// 剩余 8 个比特位存第一个字节，length &amp; 0xff，12 个比特位，最大长度是 2^12 -1 = 4095</span>
        <span class=n>buf</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>len</span> <span class=o>&gt;&gt;</span> <span class=mi>8</span><span class=p>)</span> <span class=o>|</span> <span class=n>LP_ENCODING_12BIT_STR</span><span class=p>;</span>
        <span class=n>buf</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>len</span> <span class=o>&amp;</span> <span class=mh>0xff</span><span class=p>;</span>
        <span class=c1>// 将字符串内容复制到后面的内存中</span>
        <span class=n>memcpy</span><span class=p>(</span><span class=n>buf</span><span class=o>+</span><span class=mi>2</span><span class=p>,</span><span class=n>s</span><span class=p>,</span><span class=n>len</span><span class=p>);</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=c1>// 长度大于等于 4096 时，使用一个类型字节 + 四个标识长度的字节，来标识长度。</span>
        <span class=c1>// 最大长度是 2^32 -1 = 4294967295</span>
        <span class=n>buf</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>LP_ENCODING_32BIT_STR</span><span class=p>;</span>
        <span class=n>buf</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>len</span> <span class=o>&amp;</span> <span class=mh>0xff</span><span class=p>;</span>
        <span class=n>buf</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>len</span> <span class=o>&gt;&gt;</span> <span class=mi>8</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0xff</span><span class=p>;</span>
        <span class=n>buf</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>len</span> <span class=o>&gt;&gt;</span> <span class=mi>16</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0xff</span><span class=p>;</span>
        <span class=n>buf</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>len</span> <span class=o>&gt;&gt;</span> <span class=mi>24</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mh>0xff</span><span class=p>;</span>
        <span class=c1>// 将字符串内容复制到后面的内存中</span>
        <span class=n>memcpy</span><span class=p>(</span><span class=n>buf</span><span class=o>+</span><span class=mi>5</span><span class=p>,</span><span class=n>s</span><span class=p>,</span><span class=n>len</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span></code></pre></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content>将 <a href=#integer>对整数编码</a> 和 <a href=#string>对字符串编码</a> 放一起对比来看，当字符串长度超过 <code>4096</code> 时，直接跳到使用了 4 个字节表示长度。D瓜哥私以为，这个跳跃太大了，而且还有剩余标志位没用上，可以来一个： <code>&lt;一个标志位字节>+&lt;两个字节长度></code>，最大可以表示 <code>2<sup>16</sup> - 1 = 65535</code> 个字符，应该可以应付绝大部分场景了。</td></tr></tbody></table></div></div><div class=sect3><h4 id=_元素长度编码>元素长度编码</h4><div class=paragraph><p>每个 listpack 元素在最后都保存当前元素占用的字节数，<strong>只包含前面的类型字节、长度字节和数据字节，不包含这个元素长度的字节数。</strong></p></div><div class="imageblock text-center"><div class=content><img src=/images/redis/listpackentry-length.png alt="listpack 元素长度编码" width=95%></div><div class=title>图 4. listpack 元素长度编码</div></div><div class=paragraph><p>保存这个长度信息，主要是为了方便从右向左搜索：每个字节首位是 <code>1</code> 表示前面还有数据，是 <code>0</code> 则表示长度编码到此为止。</p></div></div></div><div class=sect2><h3 id=_源码分析>源码分析</h3><div class=sect3><h4 id=_新建_listpack_对象>新建 listpack 对象</h4><div class=listingblock><div class=title><code>listpack.c</code></div><div class=content><pre class="rouge highlight nowrap"><code data-lang=c><span class=cm>/* Create a new, empty listpack.
 * On success the new listpack is returned, otherwise an error is returned.
 * Pre-allocate at least `capacity` bytes of memory,
 * over-allocated memory can be shrunk by `lpShrinkToFit`.
 * */</span>
<span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=nf>lpNew</span><span class=p>(</span><span class=kt>size_t</span> <span class=n>capacity</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>lp</span> <span class=o>=</span> <span class=n>lp_malloc</span><span class=p>(</span><span class=n>capacity</span> <span class=o>&gt;</span> <span class=n>LP_HDR_SIZE</span><span class=o>+</span><span class=mi>1</span> <span class=o>?</span> <span class=n>capacity</span> <span class=o>:</span> <span class=n>LP_HDR_SIZE</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>lp</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=c1>// 设置 listpack 目前字节长度</span>
    <span class=n>lpSetTotalBytes</span><span class=p>(</span><span class=n>lp</span><span class=p>,</span><span class=n>LP_HDR_SIZE</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
    <span class=c1>// 元素为 0</span>
    <span class=n>lpSetNumElements</span><span class=p>(</span><span class=n>lp</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span>
    <span class=c1>// 后面直接接结束标志符</span>
    <span class=n>lp</span><span class=p>[</span><span class=n>LP_HDR_SIZE</span><span class=p>]</span> <span class=o>=</span> <span class=n>LP_EOF</span><span class=p>;</span>
    <span class=k>return</span> <span class=n>lp</span><span class=p>;</span>
<span class=p>}</span></code></pre></div></div><div class=paragraph><p>通过分析上面的代码可以得知，listpack 的新对象初始化完成后，内容如下：</p></div><div class="imageblock text-center"><div class=content><img src=/images/redis/listpack-new.png alt="listpack 新对象" width=95%></div><div class=title>图 5. listpack 新对象</div></div></div><div class=sect3><h4 id=_增删改>增删改</h4><div class=paragraph><p>listpack 的增删改所有更新操作，都被一个函数包圆了： <code>lpInsert</code>，来看看它是如何实现的。</p></div><div class=listingblock><div class=title><code>listpack.c</code></div><div class=content><pre class="rouge highlight nowrap"><code data-lang=c><span class=cm>/* Insert, delete or replace the specified string element &#39;elestr&#39; of length
 * &#39;size&#39; or integer element &#39;eleint&#39; at the specified position &#39;p&#39;, with &#39;p&#39;
 * being a listpack element pointer obtained with lpFirst(), lpLast(), lpNext(),
 * lpPrev() or lpSeek().
 *
 * The element is inserted before, after, or replaces the element pointed
 * by &#39;p&#39; depending on the &#39;where&#39; argument, that can be LP_BEFORE, LP_AFTER
 * or LP_REPLACE.
 *
 * If both &#39;elestr&#39; and `eleint` are NULL, the function removes the element
 * pointed by &#39;p&#39; instead of inserting one.
 * If `eleint` is non-NULL, &#39;size&#39; is the length of &#39;eleint&#39;, the function insert
 * or replace with a 64 bit integer, which is stored in the &#39;eleint&#39; buffer.
 * If &#39;elestr` is non-NULL, &#39;size&#39; is the length of &#39;elestr&#39;, the function insert
 * or replace with a string, which is stored in the &#39;elestr&#39; buffer.
 *
 * Returns NULL on out of memory or when the listpack total length would exceed
 * the max allowed size of 2^32-1, otherwise the new pointer to the listpack
 * holding the new element is returned (and the old pointer passed is no longer
 * considered valid)
 *
 * If &#39;newp&#39; is not NULL, at the end of a successful call &#39;*newp&#39; will be set
 * to the address of the element just added, so that it will be possible to
 * continue an interaction with lpNext() and lpPrev().
 *
 * For deletion operations (both &#39;elestr&#39; and &#39;eleint&#39; set to NULL) &#39;newp&#39; is
 * set to the next element, on the right of the deleted one, or to NULL if the
 * deleted element was the last one. */</span>
<span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=nf>lpInsert</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>lp</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>elestr</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>eleint</span><span class=p>,</span>
                        <span class=kt>uint32_t</span> <span class=n>size</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>p</span><span class=p>,</span> <span class=kt>int</span> <span class=n>where</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>**</span><span class=n>newp</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>intenc</span><span class=p>[</span><span class=n>LP_MAX_INT_ENCODING_LEN</span><span class=p>];</span>
    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>backlen</span><span class=p>[</span><span class=n>LP_MAX_BACKLEN_SIZE</span><span class=p>];</span>

    <span class=kt>uint64_t</span> <span class=n>enclen</span><span class=p>;</span> <span class=cm>/* The length of the encoded element. */</span>
    <span class=c1>// 如果没有传递内容，则就是删除</span>
    <span class=kt>int</span> <span class=n>delete</span> <span class=o>=</span> <span class=p>(</span><span class=n>elestr</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>&amp;&amp;</span> <span class=n>eleint</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>);</span>

    <span class=cm>/* when deletion, it is conceptually replacing the element with a
     * zero-length element. So whatever we get passed as &#39;where&#39;, set
     * it to LP_REPLACE. */</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>delete</span><span class=p>)</span> <span class=n>where</span> <span class=o>=</span> <span class=n>LP_REPLACE</span><span class=p>;</span>

    <span class=cm>/* If we need to insert after the current element, we just jump to the
     * next element (that could be the EOF one) and handle the case of
     * inserting before. So the function will actually deal with just two
     * cases: LP_BEFORE and LP_REPLACE. */</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>where</span> <span class=o>==</span> <span class=n>LP_AFTER</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>p</span> <span class=o>=</span> <span class=n>lpSkip</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
        <span class=n>where</span> <span class=o>=</span> <span class=n>LP_BEFORE</span><span class=p>;</span>
        <span class=n>ASSERT_INTEGRITY</span><span class=p>(</span><span class=n>lp</span><span class=p>,</span> <span class=n>p</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=cm>/* Store the offset of the element &#39;p&#39;, so that we can obtain its
     * address again after a reallocation. */</span>
    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>poff</span> <span class=o>=</span> <span class=n>p</span><span class=o>-</span><span class=n>lp</span><span class=p>;</span>

    <span class=kt>int</span> <span class=n>enctype</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>elestr</span><span class=p>)</span> <span class=p>{</span>
        <span class=cm>/* Calling lpEncodeGetType() results into the encoded version of the
        * element to be stored into &#39;intenc&#39; in case it is representable as
        * an integer: in that case, the function returns LP_ENCODING_INT.
        * Otherwise if LP_ENCODING_STR is returned, we&#39;ll have to call
        * lpEncodeString() to actually write the encoded string on place later.
        *
        * Whatever the returned encoding is, &#39;enclen&#39; is populated with the
        * length of the encoded element. */</span>
        <span class=c1>// 检查字符串是否可以使用整型表示。整型更加节省空间。</span>
        <span class=n>enctype</span> <span class=o>=</span> <span class=n>lpEncodeGetType</span><span class=p>(</span><span class=n>elestr</span><span class=p>,</span><span class=n>size</span><span class=p>,</span><span class=n>intenc</span><span class=p>,</span><span class=o>&amp;</span><span class=n>enclen</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>enctype</span> <span class=o>==</span> <span class=n>LP_ENCODING_INT</span><span class=p>)</span> <span class=n>eleint</span> <span class=o>=</span> <span class=n>intenc</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>eleint</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>enctype</span> <span class=o>=</span> <span class=n>LP_ENCODING_INT</span><span class=p>;</span>
        <span class=n>enclen</span> <span class=o>=</span> <span class=n>size</span><span class=p>;</span> <span class=cm>/* &#39;size&#39; is the length of the encoded integer element. */</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=n>enctype</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
        <span class=n>enclen</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=cm>/* We need to also encode the backward-parsable length of the element
     * and append it to the end: this allows to traverse the listpack from
     * the end to the start. */</span>
    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>backlen_size</span> <span class=o>=</span> <span class=p>(</span><span class=o>!</span><span class=n>delete</span><span class=p>)</span> <span class=o>?</span> <span class=n>lpEncodeBacklen</span><span class=p>(</span><span class=n>backlen</span><span class=p>,</span><span class=n>enclen</span><span class=p>)</span> <span class=o>:</span> <span class=mi>0</span><span class=p>;</span>
    <span class=kt>uint64_t</span> <span class=n>old_listpack_bytes</span> <span class=o>=</span> <span class=n>lpGetTotalBytes</span><span class=p>(</span><span class=n>lp</span><span class=p>);</span>
    <span class=kt>uint32_t</span> <span class=n>replaced_len</span>  <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>where</span> <span class=o>==</span> <span class=n>LP_REPLACE</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>replaced_len</span> <span class=o>=</span> <span class=n>lpCurrentEncodedSizeUnsafe</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
        <span class=n>replaced_len</span> <span class=o>+=</span> <span class=n>lpEncodeBacklenBytes</span><span class=p>(</span><span class=n>replaced_len</span><span class=p>);</span>
        <span class=n>ASSERT_INTEGRITY_LEN</span><span class=p>(</span><span class=n>lp</span><span class=p>,</span> <span class=n>p</span><span class=p>,</span> <span class=n>replaced_len</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=kt>uint64_t</span> <span class=n>new_listpack_bytes</span> <span class=o>=</span> <span class=n>old_listpack_bytes</span> <span class=o>+</span> <span class=n>enclen</span> <span class=o>+</span> <span class=n>backlen_size</span>
                                  <span class=o>-</span> <span class=n>replaced_len</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>new_listpack_bytes</span> <span class=o>&gt;</span> <span class=n>UINT32_MAX</span><span class=p>)</span> <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>

    <span class=cm>/* We now need to reallocate in order to make space or shrink the
     * allocation (in case &#39;when&#39; value is LP_REPLACE and the new element is
     * smaller). However we do that before memmoving the memory to
     * make room for the new element if the final allocation will get
     * larger, or we do it after if the final allocation will get smaller. */</span>

    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>dst</span> <span class=o>=</span> <span class=n>lp</span> <span class=o>+</span> <span class=n>poff</span><span class=p>;</span> <span class=cm>/* May be updated after reallocation. */</span>

    <span class=cm>/* Realloc before: we need more room. */</span>
    <span class=c1>// 扩容</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>new_listpack_bytes</span> <span class=o>&gt;</span> <span class=n>old_listpack_bytes</span> <span class=o>&amp;&amp;</span>
        <span class=n>new_listpack_bytes</span> <span class=o>&gt;</span> <span class=n>lp_malloc_size</span><span class=p>(</span><span class=n>lp</span><span class=p>))</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>((</span><span class=n>lp</span> <span class=o>=</span> <span class=n>lp_realloc</span><span class=p>(</span><span class=n>lp</span><span class=p>,</span><span class=n>new_listpack_bytes</span><span class=p>))</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
        <span class=n>dst</span> <span class=o>=</span> <span class=n>lp</span> <span class=o>+</span> <span class=n>poff</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=cm>/* Setup the listpack relocating the elements to make the exact room
     * we need to store the new one. */</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>where</span> <span class=o>==</span> <span class=n>LP_BEFORE</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>memmove</span><span class=p>(</span><span class=n>dst</span><span class=o>+</span><span class=n>enclen</span><span class=o>+</span><span class=n>backlen_size</span><span class=p>,</span><span class=n>dst</span><span class=p>,</span><span class=n>old_listpack_bytes</span><span class=o>-</span><span class=n>poff</span><span class=p>);</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span> <span class=cm>/* LP_REPLACE. */</span>
        <span class=n>memmove</span><span class=p>(</span><span class=n>dst</span><span class=o>+</span><span class=n>enclen</span><span class=o>+</span><span class=n>backlen_size</span><span class=p>,</span>
                <span class=n>dst</span><span class=o>+</span><span class=n>replaced_len</span><span class=p>,</span>
                <span class=n>old_listpack_bytes</span><span class=o>-</span><span class=n>poff</span><span class=o>-</span><span class=n>replaced_len</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=cm>/* Realloc after: we need to free space. */</span>
    <span class=c1>// 缩容</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>new_listpack_bytes</span> <span class=o>&lt;</span> <span class=n>old_listpack_bytes</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>((</span><span class=n>lp</span> <span class=o>=</span> <span class=n>lp_realloc</span><span class=p>(</span><span class=n>lp</span><span class=p>,</span><span class=n>new_listpack_bytes</span><span class=p>))</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
        <span class=n>dst</span> <span class=o>=</span> <span class=n>lp</span> <span class=o>+</span> <span class=n>poff</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=cm>/* Store the entry. */</span>
    <span class=c1>// 新增元素</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>newp</span><span class=p>)</span> <span class=p>{</span>
        <span class=o>*</span><span class=n>newp</span> <span class=o>=</span> <span class=n>dst</span><span class=p>;</span>
        <span class=cm>/* In case of deletion, set &#39;newp&#39; to NULL if the next element is
         * the EOF element. */</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>delete</span> <span class=o>&amp;&amp;</span> <span class=n>dst</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=n>LP_EOF</span><span class=p>)</span> <span class=o>*</span><span class=n>newp</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=c1>// 更新元素</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>delete</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>enctype</span> <span class=o>==</span> <span class=n>LP_ENCODING_INT</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>memcpy</span><span class=p>(</span><span class=n>dst</span><span class=p>,</span><span class=n>eleint</span><span class=p>,</span><span class=n>enclen</span><span class=p>);</span>
        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>elestr</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>lpEncodeString</span><span class=p>(</span><span class=n>dst</span><span class=p>,</span><span class=n>elestr</span><span class=p>,</span><span class=n>size</span><span class=p>);</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=n>redis_unreachable</span><span class=p>();</span>
        <span class=p>}</span>
        <span class=n>dst</span> <span class=o>+=</span> <span class=n>enclen</span><span class=p>;</span>
        <span class=n>memcpy</span><span class=p>(</span><span class=n>dst</span><span class=p>,</span><span class=n>backlen</span><span class=p>,</span><span class=n>backlen_size</span><span class=p>);</span>
        <span class=n>dst</span> <span class=o>+=</span> <span class=n>backlen_size</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=cm>/* Update header. */</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>where</span> <span class=o>!=</span> <span class=n>LP_REPLACE</span> <span class=o>||</span> <span class=n>delete</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>uint32_t</span> <span class=n>num_elements</span> <span class=o>=</span> <span class=n>lpGetNumElements</span><span class=p>(</span><span class=n>lp</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>num_elements</span> <span class=o>!=</span> <span class=n>LP_HDR_NUMELE_UNKNOWN</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>delete</span><span class=p>)</span>
                <span class=n>lpSetNumElements</span><span class=p>(</span><span class=n>lp</span><span class=p>,</span><span class=n>num_elements</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
            <span class=k>else</span>
                <span class=n>lpSetNumElements</span><span class=p>(</span><span class=n>lp</span><span class=p>,</span><span class=n>num_elements</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=n>lpSetTotalBytes</span><span class=p>(</span><span class=n>lp</span><span class=p>,</span><span class=n>new_listpack_bytes</span><span class=p>);</span>

<span class=c>#if 0
    /* This code path is normally disabled: what it does is to force listpack
     * to return *always* a new pointer after performing some modification to
     * the listpack, even if the previous allocation was enough. This is useful
     * in order to spot bugs in code using listpacks: by doing so we can find
     * if the caller forgets to set the new pointer where the listpack reference
     * is stored, after an update. */
    unsigned char *oldlp = lp;
    lp = lp_malloc(new_listpack_bytes);
    memcpy(lp,oldlp,new_listpack_bytes);
    if (newp) {
        unsigned long offset = (*newp)-oldlp;
        *newp = lp + offset;
    }
    /* Make sure the old allocation contains garbage. */
    memset(oldlp,&#39;A&#39;,new_listpack_bytes);
    lp_free(oldlp);
#endif
</span>
    <span class=k>return</span> <span class=n>lp</span><span class=p>;</span>
<span class=p>}</span></code></pre></div></div><div class=paragraph><p>查看代码简单总结一下：</p></div><div class="olist arabic"><ol class=arabic><li><p>如果可以，会优先使用整型对内容进行编码；</p></li><li><p>如果没有传递内容，则表示删除。</p></li><li><p>整体流程是：先操作数据元素，然后更新整体长度和元素个数。</p></li><li><p>内容使用存放和废除使用内存拷贝 <code>memcpy</code> 函数来完成。</p></li></ol></div></div><div class=sect3><h4 id=_查找>查找</h4><div class=listingblock><div class=title><code>listpack.c</code></div><div class=content><pre class="rouge highlight nowrap"><code data-lang=c><span class=cm>/* Skip the current entry returning the next. It is invalid to call this
 * function if the current element is the EOF element at the end of the
 * listpack, however, while this function is used to implement lpNext(),
 * it does not return NULL when the EOF element is encountered. */</span>
<span class=k>static</span> <span class=kr>inline</span> <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=nf>lpSkip</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>entrylen</span> <span class=o>=</span> <span class=n>lpCurrentEncodedSizeUnsafe</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
    <span class=n>entrylen</span> <span class=o>+=</span> <span class=n>lpEncodeBacklenBytes</span><span class=p>(</span><span class=n>entrylen</span><span class=p>);</span>
    <span class=n>p</span> <span class=o>+=</span> <span class=n>entrylen</span><span class=p>;</span>
    <span class=k>return</span> <span class=n>p</span><span class=p>;</span>
<span class=p>}</span>

<span class=cm>/* Return the listpack element pointed by &#39;p&#39;.
 *
 * The function changes behavior depending on the passed &#39;intbuf&#39; value.
 * Specifically, if &#39;intbuf&#39; is NULL:
 *
 * If the element is internally encoded as an integer, the function returns
 * NULL and populates the integer value by reference in &#39;count&#39;. Otherwise if
 * the element is encoded as a string a pointer to the string (pointing inside
 * the listpack itself) is returned, and &#39;count&#39; is set to the length of the
 * string.
 *
 * If instead &#39;intbuf&#39; points to a buffer passed by the caller, that must be
 * at least LP_INTBUF_SIZE bytes, the function always returns the element as
 * it was a string (returning the pointer to the string and setting the
 * &#39;count&#39; argument to the string length by reference). However if the element
 * is encoded as an integer, the &#39;intbuf&#39; buffer is used in order to store
 * the string representation.
 *
 * The user should use one or the other form depending on what the value will
 * be used for. If there is immediate usage for an integer value returned
 * by the function, than to pass a buffer (and convert it back to a number)
 * is of course useless.
 *
 * If &#39;entry_size&#39; is not NULL, *entry_size is set to the entry length of the
 * listpack element pointed by &#39;p&#39;. This includes the encoding bytes, length
 * bytes, the element data itself, and the backlen bytes.
 *
 * If the function is called against a badly encoded ziplist, so that there
 * is no valid way to parse it, the function returns like if there was an
 * integer encoded with value 12345678900000000 + &lt;unrecognized byte&gt;, this may
 * be an hint to understand that something is wrong. To crash in this case is
 * not sensible because of the different requirements of the application using
 * this lib.
 *
 * Similarly, there is no error returned since the listpack normally can be
 * assumed to be valid, so that would be a very high API cost. */</span>
<span class=k>static</span> <span class=kr>inline</span> <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=nf>lpGetWithSize</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>p</span><span class=p>,</span> <span class=kt>int64_t</span> <span class=o>*</span><span class=n>count</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>intbuf</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=o>*</span><span class=n>entry_size</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int64_t</span> <span class=n>val</span><span class=p>;</span>
    <span class=kt>uint64_t</span> <span class=n>uval</span><span class=p>,</span> <span class=n>negstart</span><span class=p>,</span> <span class=n>negmax</span><span class=p>;</span>

    <span class=n>assert</span><span class=p>(</span><span class=n>p</span><span class=p>);</span> <span class=cm>/* assertion for valgrind (avoid NPD) */</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>LP_ENCODING_IS_7BIT_UINT</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=mi>0</span><span class=p>]))</span> <span class=p>{</span>
        <span class=n>negstart</span> <span class=o>=</span> <span class=n>UINT64_MAX</span><span class=p>;</span> <span class=cm>/* 7 bit ints are always positive. */</span>
        <span class=n>negmax</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=n>uval</span> <span class=o>=</span> <span class=n>p</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>&amp;</span> <span class=mh>0x7f</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>entry_size</span><span class=p>)</span> <span class=o>*</span><span class=n>entry_size</span> <span class=o>=</span> <span class=n>LP_ENCODING_7BIT_UINT_ENTRY_SIZE</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>LP_ENCODING_IS_6BIT_STR</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=mi>0</span><span class=p>]))</span> <span class=p>{</span>
        <span class=o>*</span><span class=n>count</span> <span class=o>=</span> <span class=n>LP_ENCODING_6BIT_STR_LEN</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>entry_size</span><span class=p>)</span> <span class=o>*</span><span class=n>entry_size</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>+</span> <span class=o>*</span><span class=n>count</span> <span class=o>+</span> <span class=n>lpEncodeBacklenBytes</span><span class=p>(</span><span class=o>*</span><span class=n>count</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
        <span class=k>return</span> <span class=n>p</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>LP_ENCODING_IS_13BIT_INT</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=mi>0</span><span class=p>]))</span> <span class=p>{</span>
        <span class=n>uval</span> <span class=o>=</span> <span class=p>((</span><span class=n>p</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>&amp;</span><span class=mh>0x1f</span><span class=p>)</span><span class=o>&lt;&lt;</span><span class=mi>8</span><span class=p>)</span> <span class=o>|</span> <span class=n>p</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
        <span class=n>negstart</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>12</span><span class=p>;</span>
        <span class=n>negmax</span> <span class=o>=</span> <span class=mi>8191</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>entry_size</span><span class=p>)</span> <span class=o>*</span><span class=n>entry_size</span> <span class=o>=</span> <span class=n>LP_ENCODING_13BIT_INT_ENTRY_SIZE</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>LP_ENCODING_IS_16BIT_INT</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=mi>0</span><span class=p>]))</span> <span class=p>{</span>
        <span class=n>uval</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>p</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>|</span>
               <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>p</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=o>&lt;&lt;</span><span class=mi>8</span><span class=p>;</span>
        <span class=n>negstart</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>15</span><span class=p>;</span>
        <span class=n>negmax</span> <span class=o>=</span> <span class=n>UINT16_MAX</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>entry_size</span><span class=p>)</span> <span class=o>*</span><span class=n>entry_size</span> <span class=o>=</span> <span class=n>LP_ENCODING_16BIT_INT_ENTRY_SIZE</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>LP_ENCODING_IS_24BIT_INT</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=mi>0</span><span class=p>]))</span> <span class=p>{</span>
        <span class=n>uval</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>p</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>|</span>
               <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>p</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=o>&lt;&lt;</span><span class=mi>8</span> <span class=o>|</span>
               <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>p</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=o>&lt;&lt;</span><span class=mi>16</span><span class=p>;</span>
        <span class=n>negstart</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>23</span><span class=p>;</span>
        <span class=n>negmax</span> <span class=o>=</span> <span class=n>UINT32_MAX</span><span class=o>&gt;&gt;</span><span class=mi>8</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>entry_size</span><span class=p>)</span> <span class=o>*</span><span class=n>entry_size</span> <span class=o>=</span> <span class=n>LP_ENCODING_24BIT_INT_ENTRY_SIZE</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>LP_ENCODING_IS_32BIT_INT</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=mi>0</span><span class=p>]))</span> <span class=p>{</span>
        <span class=n>uval</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>p</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>|</span>
               <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>p</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=o>&lt;&lt;</span><span class=mi>8</span> <span class=o>|</span>
               <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>p</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=o>&lt;&lt;</span><span class=mi>16</span> <span class=o>|</span>
               <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>p</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span><span class=o>&lt;&lt;</span><span class=mi>24</span><span class=p>;</span>
        <span class=n>negstart</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>31</span><span class=p>;</span>
        <span class=n>negmax</span> <span class=o>=</span> <span class=n>UINT32_MAX</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>entry_size</span><span class=p>)</span> <span class=o>*</span><span class=n>entry_size</span> <span class=o>=</span> <span class=n>LP_ENCODING_32BIT_INT_ENTRY_SIZE</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>LP_ENCODING_IS_64BIT_INT</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=mi>0</span><span class=p>]))</span> <span class=p>{</span>
        <span class=n>uval</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>p</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>|</span>
               <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>p</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=o>&lt;&lt;</span><span class=mi>8</span> <span class=o>|</span>
               <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>p</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=o>&lt;&lt;</span><span class=mi>16</span> <span class=o>|</span>
               <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>p</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span><span class=o>&lt;&lt;</span><span class=mi>24</span> <span class=o>|</span>
               <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>p</span><span class=p>[</span><span class=mi>5</span><span class=p>]</span><span class=o>&lt;&lt;</span><span class=mi>32</span> <span class=o>|</span>
               <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>p</span><span class=p>[</span><span class=mi>6</span><span class=p>]</span><span class=o>&lt;&lt;</span><span class=mi>40</span> <span class=o>|</span>
               <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>p</span><span class=p>[</span><span class=mi>7</span><span class=p>]</span><span class=o>&lt;&lt;</span><span class=mi>48</span> <span class=o>|</span>
               <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=n>p</span><span class=p>[</span><span class=mi>8</span><span class=p>]</span><span class=o>&lt;&lt;</span><span class=mi>56</span><span class=p>;</span>
        <span class=n>negstart</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>63</span><span class=p>;</span>
        <span class=n>negmax</span> <span class=o>=</span> <span class=n>UINT64_MAX</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>entry_size</span><span class=p>)</span> <span class=o>*</span><span class=n>entry_size</span> <span class=o>=</span> <span class=n>LP_ENCODING_64BIT_INT_ENTRY_SIZE</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>LP_ENCODING_IS_12BIT_STR</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=mi>0</span><span class=p>]))</span> <span class=p>{</span>
        <span class=o>*</span><span class=n>count</span> <span class=o>=</span> <span class=n>LP_ENCODING_12BIT_STR_LEN</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>entry_size</span><span class=p>)</span> <span class=o>*</span><span class=n>entry_size</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>+</span> <span class=o>*</span><span class=n>count</span> <span class=o>+</span> <span class=n>lpEncodeBacklenBytes</span><span class=p>(</span><span class=o>*</span><span class=n>count</span> <span class=o>+</span> <span class=mi>2</span><span class=p>);</span>
        <span class=k>return</span> <span class=n>p</span><span class=o>+</span><span class=mi>2</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>LP_ENCODING_IS_32BIT_STR</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=mi>0</span><span class=p>]))</span> <span class=p>{</span>
        <span class=o>*</span><span class=n>count</span> <span class=o>=</span> <span class=n>LP_ENCODING_32BIT_STR_LEN</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>entry_size</span><span class=p>)</span> <span class=o>*</span><span class=n>entry_size</span> <span class=o>=</span> <span class=mi>5</span> <span class=o>+</span> <span class=o>*</span><span class=n>count</span> <span class=o>+</span> <span class=n>lpEncodeBacklenBytes</span><span class=p>(</span><span class=o>*</span><span class=n>count</span> <span class=o>+</span> <span class=mi>5</span><span class=p>);</span>
        <span class=k>return</span> <span class=n>p</span><span class=o>+</span><span class=mi>5</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=n>uval</span> <span class=o>=</span> <span class=mi>12345678900000000ULL</span> <span class=o>+</span> <span class=n>p</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
        <span class=n>negstart</span> <span class=o>=</span> <span class=n>UINT64_MAX</span><span class=p>;</span>
        <span class=n>negmax</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=cm>/* We reach this code path only for integer encodings.
     * Convert the unsigned value to the signed one using two&#39;s complement
     * rule. */</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>uval</span> <span class=o>&gt;=</span> <span class=n>negstart</span><span class=p>)</span> <span class=p>{</span>
        <span class=cm>/* This three steps conversion should avoid undefined behaviors
         * in the unsigned -&gt; signed conversion. */</span>
        <span class=n>uval</span> <span class=o>=</span> <span class=n>negmax</span><span class=o>-</span><span class=n>uval</span><span class=p>;</span>
        <span class=n>val</span> <span class=o>=</span> <span class=n>uval</span><span class=p>;</span>
        <span class=n>val</span> <span class=o>=</span> <span class=o>-</span><span class=n>val</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=n>val</span> <span class=o>=</span> <span class=n>uval</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=cm>/* Return the string representation of the integer or the value itself
     * depending on intbuf being NULL or not. */</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>intbuf</span><span class=p>)</span> <span class=p>{</span>
        <span class=o>*</span><span class=n>count</span> <span class=o>=</span> <span class=n>ll2string</span><span class=p>((</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=n>intbuf</span><span class=p>,</span><span class=n>LP_INTBUF_SIZE</span><span class=p>,(</span><span class=kt>long</span> <span class=kt>long</span><span class=p>)</span><span class=n>val</span><span class=p>);</span>
        <span class=k>return</span> <span class=n>intbuf</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=o>*</span><span class=n>count</span> <span class=o>=</span> <span class=n>val</span><span class=p>;</span>
        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=cm>/* Find pointer to the entry with a comparator callback.
 *
 * &#39;cmp&#39; is a comparator callback. If it returns zero, current entry pointer
 * will be returned. &#39;user&#39; is passed to this callback.
 * Skip &#39;skip&#39; entries between every comparison.
 * Returns NULL when the field could not be found. */</span>
<span class=k>static</span> <span class=kr>inline</span> <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=nf>lpFindCbInternal</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>lp</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>p</span><span class=p>,</span>
                                              <span class=kt>void</span> <span class=o>*</span><span class=n>user</span><span class=p>,</span> <span class=n>lpCmp</span> <span class=n>cmp</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>skip</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>skipcnt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>value</span><span class=p>;</span>
    <span class=kt>int64_t</span> <span class=n>ll</span><span class=p>;</span>
    <span class=kt>uint64_t</span> <span class=n>entry_size</span> <span class=o>=</span> <span class=mi>123456789</span><span class=p>;</span> <span class=cm>/* initialized to avoid warning. */</span>
    <span class=kt>uint32_t</span> <span class=n>lp_bytes</span> <span class=o>=</span> <span class=n>lpBytes</span><span class=p>(</span><span class=n>lp</span><span class=p>);</span>

    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>p</span><span class=p>)</span>
        <span class=n>p</span> <span class=o>=</span> <span class=n>lpFirst</span><span class=p>(</span><span class=n>lp</span><span class=p>);</span>

    <span class=k>while</span> <span class=p>(</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>skipcnt</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>value</span> <span class=o>=</span> <span class=n>lpGetWithSize</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ll</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>entry_size</span><span class=p>);</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>value</span><span class=p>)</span> <span class=p>{</span>
                <span class=cm>/* check the value doesn&#39;t reach outside the listpack before accessing it */</span>
                <span class=n>assert</span><span class=p>(</span><span class=n>p</span> <span class=o>&gt;=</span> <span class=n>lp</span> <span class=o>+</span> <span class=n>LP_HDR_SIZE</span> <span class=o>&amp;&amp;</span> <span class=n>p</span> <span class=o>+</span> <span class=n>entry_size</span> <span class=o>&lt;</span> <span class=n>lp</span> <span class=o>+</span> <span class=n>lp_bytes</span><span class=p>);</span>
            <span class=p>}</span>

            <span class=k>if</span> <span class=p>(</span><span class=n>unlikely</span><span class=p>(</span><span class=n>cmp</span><span class=p>(</span><span class=n>lp</span><span class=p>,</span> <span class=n>p</span><span class=p>,</span> <span class=n>user</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=n>ll</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>))</span>
                <span class=k>return</span> <span class=n>p</span><span class=p>;</span>

            <span class=cm>/* Reset skip count */</span>
            <span class=n>skipcnt</span> <span class=o>=</span> <span class=n>skip</span><span class=p>;</span>
            <span class=n>p</span> <span class=o>+=</span> <span class=n>entry_size</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=cm>/* Skip entry */</span>
            <span class=n>skipcnt</span><span class=o>--</span><span class=p>;</span>

            <span class=cm>/* Move to next entry, avoid use `lpNext` due to `lpAssertValidEntry` in
            * `lpNext` will call `lpBytes`, will cause performance degradation */</span>
            <span class=n>p</span> <span class=o>=</span> <span class=n>lpSkip</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
        <span class=p>}</span>

        <span class=cm>/* The next call to lpGetWithSize could read at most 8 bytes past `p`
         * We use the slower validation call only when necessary. */</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>p</span> <span class=o>+</span> <span class=mi>8</span> <span class=o>&gt;=</span> <span class=n>lp</span> <span class=o>+</span> <span class=n>lp_bytes</span><span class=p>)</span>
            <span class=n>lpAssertValidEntry</span><span class=p>(</span><span class=n>lp</span><span class=p>,</span> <span class=n>lp_bytes</span><span class=p>,</span> <span class=n>p</span><span class=p>);</span>
        <span class=k>else</span>
            <span class=n>assert</span><span class=p>(</span><span class=n>p</span> <span class=o>&gt;=</span> <span class=n>lp</span> <span class=o>+</span> <span class=n>LP_HDR_SIZE</span> <span class=o>&amp;&amp;</span> <span class=n>p</span> <span class=o>&lt;</span> <span class=n>lp</span> <span class=o>+</span> <span class=n>lp_bytes</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=n>LP_EOF</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
<span class=p>}</span>

<span class=cm>/* Find pointer to the entry equal to the specified entry. Skip &#39;skip&#39; entries
 * between every comparison. Returns NULL when the field could not be found. */</span>
<span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=nf>lpFind</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>lp</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>p</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>s</span><span class=p>,</span>
                      <span class=kt>uint32_t</span> <span class=n>slen</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>skip</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=n>lpFindArg</span> <span class=n>arg</span> <span class=o>=</span> <span class=p>{</span>
        <span class=p>.</span><span class=n>s</span> <span class=o>=</span> <span class=n>s</span><span class=p>,</span>
        <span class=p>.</span><span class=n>slen</span> <span class=o>=</span> <span class=n>slen</span>
    <span class=p>};</span>
    <span class=k>return</span> <span class=n>lpFindCbInternal</span><span class=p>(</span><span class=n>lp</span><span class=p>,</span> <span class=n>p</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>arg</span><span class=p>,</span> <span class=n>lpFindCmp</span><span class=p>,</span> <span class=n>skip</span><span class=p>);</span>
<span class=p>}</span>

<span class=cm>/* Validate the integrity of a single listpack entry and move to the next one.
 * The input argument &#39;pp&#39; is a reference to the current record and is advanced on exit.
 *  the data pointed to by &#39;lp&#39; will not be modified by the function.
 * Returns 1 if valid, 0 if invalid. */</span>
<span class=kt>int</span> <span class=nf>lpValidateNext</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>lp</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>**</span><span class=n>pp</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>lpbytes</span><span class=p>)</span> <span class=p>{</span>
<span class=cp>#define OUT_OF_RANGE(p) ( \
        (p) &lt; lp + LP_HDR_SIZE || \
        (p) &gt; lp + lpbytes - 1)
</span>    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=o>*</span><span class=n>pp</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>p</span><span class=p>)</span>
        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>

    <span class=cm>/* Before accessing p, make sure it&#39;s valid. */</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>OUT_OF_RANGE</span><span class=p>(</span><span class=n>p</span><span class=p>))</span>
        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>p</span> <span class=o>==</span> <span class=n>LP_EOF</span><span class=p>)</span> <span class=p>{</span>
        <span class=o>*</span><span class=n>pp</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=cm>/* check that we can read the encoded size */</span>
    <span class=kt>uint32_t</span> <span class=n>lenbytes</span> <span class=o>=</span> <span class=n>lpCurrentEncodedSizeBytes</span><span class=p>(</span><span class=n>p</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>lenbytes</span><span class=p>)</span>
        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>

    <span class=cm>/* make sure the encoded entry length doesn&#39;t reach outside the edge of the listpack */</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>OUT_OF_RANGE</span><span class=p>(</span><span class=n>p</span> <span class=o>+</span> <span class=n>lenbytes</span><span class=p>))</span>
        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>

    <span class=cm>/* get the entry length and encoded backlen. */</span>
    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>entrylen</span> <span class=o>=</span> <span class=n>lpCurrentEncodedSizeUnsafe</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>encodedBacklen</span> <span class=o>=</span> <span class=n>lpEncodeBacklenBytes</span><span class=p>(</span><span class=n>entrylen</span><span class=p>);</span>
    <span class=n>entrylen</span> <span class=o>+=</span> <span class=n>encodedBacklen</span><span class=p>;</span>

    <span class=cm>/* make sure the entry doesn&#39;t reach outside the edge of the listpack */</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>OUT_OF_RANGE</span><span class=p>(</span><span class=n>p</span> <span class=o>+</span> <span class=n>entrylen</span><span class=p>))</span>
        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>

    <span class=cm>/* move to the next entry */</span>
    <span class=n>p</span> <span class=o>+=</span> <span class=n>entrylen</span><span class=p>;</span>

    <span class=cm>/* make sure the encoded length at the end patches the one at the beginning. */</span>
    <span class=kt>uint64_t</span> <span class=n>prevlen</span> <span class=o>=</span> <span class=n>lpDecodeBacklen</span><span class=p>(</span><span class=n>p</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>prevlen</span> <span class=o>+</span> <span class=n>encodedBacklen</span> <span class=o>!=</span> <span class=n>entrylen</span><span class=p>)</span>
        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>

    <span class=o>*</span><span class=n>pp</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
    <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
<span class=cp>#undef OUT_OF_RANGE
</span><span class=p>}</span>

<span class=cm>/* Validate that the entry doesn&#39;t reach outside the listpack allocation. */</span>
<span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>lpAssertValidEntry</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span> <span class=n>lp</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>lpbytes</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>assert</span><span class=p>(</span><span class=n>lpValidateNext</span><span class=p>(</span><span class=n>lp</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p</span><span class=p>,</span> <span class=n>lpbytes</span><span class=p>));</span>
<span class=p>}</span></code></pre></div></div><div class=paragraph><p>这篇文章已经够长，到此为止。下一篇文章，分析一下 listpack 在各个数据结构中的使用情况，敬请期待： <a href=https://www.diguage.com/post/redis-core-data-structure-4/>Redis 核心数据结构（4）</a>。</p></div></div></div></div></div><div class=sect1><h2 id=_参考资料>参考资料</h2><div class=sectionbody><div class="olist arabic"><ol class=arabic><li><p><a href=https://github.com/antirez/listpack/blob/master/listpack.md target=_blank rel=noopener>Listpack specification</a></p></li><li><p><a href=https://github.com/redis/redis/pull/8887 target=_blank rel=noopener>Replace all usage of ziplist with listpack for t_hash</a></p></li><li><p><a href=https://github.com/redis/redis/pull/9366 target=_blank rel=noopener>Replace all usage of ziplist with listpack for t_zset</a></p></li><li><p><a href=https://github.com/redis/redis/pull/9740 target=_blank rel=noopener>Replace ziplist with listpack in quicklist</a></p></li><li><p><a href=https://github.com/redis/redis/releases/tag/7.0-rc1 target=_blank rel=noopener>Introduction to the Redis 7.0 release</a> — 从 7.0 开始，将 Hash、 List、 Zset 中的 listpack 替换 ziplist。</p></li><li><p><a href=https://juejin.cn/post/7220950867339247653 target=_blank rel=noopener>Redis7.0代码分析：底层数据结构listpack实现原理</a></p></li><li><p><a href=https://zhuanlan.zhihu.com/p/669544722 target=_blank rel=noopener>Redis数据结构之listpack</a></p></li><li><p><a href=https://zhuanlan.zhihu.com/p/435724042 target=_blank rel=noopener>redis源码学习-listpack篇</a></p></li><li><p><a href=https://thinkervision.com/reading-notes-on-redis-design-and-implementation-listpack-the-listpack-in-the-redis-source-code target=_blank rel=noopener>Redis 源码中的紧凑列表 Listpack</a></p></li><li><p><a href=https://blog.csdn.net/u013277209/article/details/125998869 target=_blank rel=noopener>吃透Redis（三）：数据结构篇-skiplist、quicklist、listpack_listpack编码方式</a></p></li></ol></div></div></div></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E5%AD%98%E5%82%A8/ rel=tag>存储</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E8%AE%BE%E8%AE%A1/ rel=tag>设计</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E6%9E%B6%E6%9E%84/ rel=tag>架构</a></li></ul></div></footer></article></main><div class=clearfix><h3>看在D瓜哥码字的辛苦上，请友情支持一下，D瓜哥感激不尽，😜</h3><table><tr><td><img alt=微信打赏码 src=/images/wxpay.jpg></td><td><img alt=支付宝打赏码 src=/images/alipay.png></td></tr></table></div><br><div class=clearfix><h3>欢迎关注D瓜哥的微信公众号，在公众号可以获取我的微信二维码：</h3><img alt=微信公众号 src=/images/wx-jikerizhi.jpg></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><i class="fa icon-tip" title=Tip></i></td><td class=content><strong>公众号的微信号是: <code>jikerizhi</code></strong>。如果图片加载不出来，可以直接通过搜索公众号的微信号来查找D瓜哥的公众号。</td></tr></tbody></table></div><div class="authorbox clearfix"><figure class=authorbox__avatar><a target=_blank href=/about/><img alt="D瓜哥 avatar" src=/images/avatar.jpg class=avatar height=110 width=110></a></figure><div class=authorbox__header><span class=authorbox__name>关于 D瓜哥</span></div><div class=authorbox__description>厨艺界最好的码农，挨踢界最棒的厨师。<ul><li><a target=_blank href=https://wordpress.diguage.com/>旧版“地瓜哥”博客网</a></li><li><a target=_blank href=https://notes.diguage.com/mysql/>MySQL 学习笔记<sup>Alpha</sup></a></li><li><a target=_blank href=https://diguage.github.io/jdk-source-analysis/>JDK 源码分析<sup>Alpha</sup></a></li></ul></div></div><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=/post/algorithm-pattern-subsets/ rel=prev><span class=pager__subtitle>«&#8201;上一篇</span><p class=pager__title>算法模式：子集</p></a></div><div class="pager__item pager__item--next"><a class=pager__link href=/post/redis-core-data-structure-4/ rel=next><span class=pager__subtitle>下一篇&#8201;»</span><p class=pager__title>Redis 核心数据结构（四）</p></a></div></nav><section class=comments><div id=SOHUCS sid=/post/redis-core-data-structure-3/></div><script type=text/javascript>(function(){if(window.location.hostname==="localhost")return;var n,e="cyuuTeBp3",t="prod_2906c47c31e735e0ed518282fec489a6",s=window.innerWidth||document.documentElement.clientWidth;s<960?window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id='+e+"&conf="+t+'"><\/script>'):(n=function(e,t){var s=document.getElementsByTagName("head")[0]||document.head||document.documentElement,n=document.createElement("script");n.setAttribute("type","text/javascript"),n.setAttribute("charset","UTF-8"),n.setAttribute("src",e),typeof t=="function"&&(window.attachEvent?n.onreadystatechange=function(){var e=n.readyState;(e==="loaded"||e==="complete")&&(n.onreadystatechange=null,t())}:n.onload=t),s.appendChild(n)},n("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:e,conf:t})}))})()</script></section></div><aside class=sidebar><div class="widget-search widget"><form class=widget-search__form role=search method=get action=https://google.com/search><label><input class=widget-search__field type=search placeholder=搜索… name=q aria-label=搜索…>
</label><input class=widget-search__submit type=submit value=Search>
<input type=hidden name=sitesearch value=https://www.diguage.com/></form></div><div class="widget-wechat widget"><h4 class=widget__title>微信公众号</h4><img alt=微信公众号 class=center src=/images/wx-jikerizhi-qrcode.jpg></div><div class="widget-wechat widget"><h4 class=widget__title>知识星球</h4><img alt=微信公众号 class=center src=/images/zhishixingqiu.png></div><div class="widget-recent widget"><h4 class=widget__title>近期文章</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/post/spring-boot-startup-process-overview/>Spring Boot 启动流程概述</a></li><li class=widget__item><a class=widget__link href=/post/redis-core-data-structure-4/>Redis 核心数据结构（四）</a></li><li class=widget__item><a class=widget__link href=/post/redis-core-data-structure-3/>Redis 核心数据结构（三）</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-subsets/>算法模式：子集</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-backtracking/>算法模式：回溯</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-transform-and-conquer/>算法模式：变治法</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-divide-and-conquer/>算法模式：分治法</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-decrease-and-conquer/>算法模式：减治法</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-topological-sort/>算法模式：拓扑排序</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-union-find/>算法模式：并查集</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-trie/>算法模式：前缀树</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-depth-first-search/>算法模式：深度优先搜索</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-breadth-first-search/>算法模式：广度优先搜索</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-k-way-merge/>算法模式：多路归并</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-two-heaps/>算法模式：双堆</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-cyclic-sort/>算法模式：循环排序</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-quickselect/>算法模式：快速选择</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-top-k-elements/>算法模式：Top K 问题</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-monotonic-stack/>算法模式：单调栈</a></li><li class=widget__item><a class=widget__link href=/post/algorithm-pattern-sliding-window/>算法模式：滑动窗口</a></li></ul></div></div><div class="widget-categories widget"><h4 class=widget__title>分类</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/categories/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/>个人成长</a></li><li class=widget__item><a class=widget__link href=/categories/%E5%88%86%E5%B8%83%E5%BC%8F/>分布式</a></li><li class=widget__item><a class=widget__link href=/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/>开发工具</a></li><li class=widget__item><a class=widget__link href=/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/>性能优化</a></li><li class=widget__item><a class=widget__link href=/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a></li><li class=widget__item><a class=widget__link href=/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/>数据存储</a></li><li class=widget__item><a class=widget__link href=/categories/%E6%96%87%E5%AD%A6/>文学</a></li><li class=widget__item><a class=widget__link href=/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/>方法论</a></li><li class=widget__item><a class=widget__link href=/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/>程序设计</a></li><li class=widget__item><a class=widget__link href=/categories/%E7%AE%97%E6%B3%95/>算法</a></li><li class=widget__item><a class=widget__link href=/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/>系统架构</a></li><li class=widget__item><a class=widget__link href=/categories/%E7%BB%8F%E6%B5%8E%E9%87%91%E8%9E%8D/>经济金融</a></li><li class=widget__item><a class=widget__link href=/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/>编程语言</a></li><li class=widget__item><a class=widget__link href=/categories/%E7%BD%91%E7%BB%9C/>网络</a></li><li class=widget__item><a class=widget__link href=/categories/%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95/>职业发展</a></li><li class=widget__item><a class=widget__link href=/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/>软件工程</a></li><li class=widget__item><a class=widget__link href=/categories/%E9%80%B8%E9%97%BB%E8%B6%A3%E4%BA%8B/>逸闻趣事</a></li><li class=widget__item><a class=widget__link href=/categories/%E9%98%85%E8%AF%BB%E6%91%98%E8%A6%81/>阅读摘要</a></li></ul></div></div><div class="widget-taglist widget"><h4 class=widget__title>标签</h4><div class=widget__content><a class="widget-taglist__link widget__link btn" href=/tags/gc/ title=GC>GC (9)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/http/ title=HTTP>HTTP (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/java/ title=Java>Java (64)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/jvm/ title=JVM>JVM (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/kpi/ title=KPI>KPI (4)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/kubernetes/ title=Kubernetes>Kubernetes (10)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/linux/ title=Linux>Linux (12)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/okr/ title=OKR>OKR (5)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/redis/ title=Redis>Redis (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/shell/ title=Shell>Shell (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/spring/ title=Spring>Spring (26)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/tcp/ title=TCP>TCP (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/udp/ title=UDP>UDP (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/zookeeper/ title=ZooKeeper>ZooKeeper (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E4%B8%AA%E4%BA%BA%E6%8F%90%E5%8D%87/ title=个人提升>个人提升 (10)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E4%B9%A6%E7%B1%8D/ title=书籍>书籍 (15)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E4%BA%A7%E5%93%81/ title=产品>产品 (7)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%80%BA%E5%88%B8/ title=债券>债券 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F/ title=分布式>分布式 (15)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%88%86%E6%B2%BB/ title=分治>分治 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/ title=动态规划>动态规划 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%9B%A2%E9%98%9F%E5%BB%BA%E8%AE%BE/ title=团队建设>团队建设 (6)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%9B%A2%E9%98%9F%E6%96%87%E5%8C%96/ title=团队文化>团队文化 (4)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%9B%BE/ title=图>图 (7)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%9F%BA%E9%87%91/ title=基金>基金 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%A0%86/ title=堆>堆 (3)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%AD%98%E5%82%A8/ title=存储>存储 (6)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95/ title=工作方法>工作方法 (5)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%B9%B6%E5%8F%91/ title=并发>并发 (3)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%BA%8F%E5%88%97%E5%8C%96/ title=序列化>序列化 (10)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/ title=微服务>微服务 (17)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%BF%83%E7%90%86%E5%AD%A6/ title=心理学>心理学 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/ title=性能测试>性能测试 (4)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2/ title=投资理财>投资理财 (5)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/ title=数据库>数据库 (10)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ title=数据结构>数据结构 (4)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%95%B0%E7%BB%84/ title=数组>数组 (13)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/ title=方法论>方法论 (13)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%97%85%E8%A1%8C/ title=旅行>旅行 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/ title=最佳实践>最佳实践 (10)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%9E%B6%E6%9E%84/ title=架构>架构 (44)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%A0%88/ title=栈>栈 (3)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%A0%91/ title=树>树 (11)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%B2%9F%E9%80%9A%E6%8A%80%E5%B7%A7/ title=沟通技巧>沟通技巧 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ title=源码分析>源码分析 (8)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E7%90%86%E8%B4%A2/ title=理财>理财 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E7%94%9F%E6%B4%BB/ title=生活>生活 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E7%AC%94%E8%AE%B0/ title=笔记>笔记 (5)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E7%AE%97%E6%B3%95/ title=算法>算法 (8)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%BC%8F/ title=算法模式>算法模式 (23)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E7%BB%8F%E6%B5%8E/ title=经济>经济 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E7%BC%96%E7%A0%81/ title=编码>编码 (3)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E7%BD%91%E7%BB%9C/ title=网络>网络 (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E7%BF%BB%E8%AF%91/ title=翻译>翻译 (7)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E8%82%A1%E7%A5%A8/ title=股票>股票 (5)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E8%84%91%E5%9B%BE/ title=脑图>脑图 (5)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E8%8A%82%E6%97%A5/ title=节日>节日 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E8%8B%B1%E8%AF%AD/ title=英语>英语 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/ title=虚拟机>虚拟机 (9)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E8%AE%BA%E6%96%87/ title=论文>论文 (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E8%AE%BE%E8%AE%A1/ title=设计>设计 (36)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ title=设计模式>设计模式 (3)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E8%AF%97%E6%AD%8C/ title=诗歌>诗歌 (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E8%AF%BB%E4%B9%A6/ title=读书>读书 (5)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E9%80%92%E5%BD%92/ title=递归>递归 (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E9%87%91%E8%9E%8D/ title=金融>金融 (5)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E9%93%BE%E8%A1%A8/ title=链表>链表 (5)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/ title=面向对象>面向对象 (5)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/ title=领域驱动设计>领域驱动设计 (5)</a></div></div><div class="widget-social widget"><h4 class="widget-social__title widget__title">社交</h4><div class="widget-social__content widget__content"><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=Twitter rel="noopener noreferrer" href=https://twitter.com/diguage target=_blank><svg class="widget-social__link-icon icon icon-twitter" width="24" height="24" viewBox="0 0 384 312"><path d="m384 36.9c-14.1 6.3-29.3 10.5-45.2 12.4 16.3-9.7 28.8-25.2 34.6-43.6-15.2 9-32.1 15.6-50 19.1-14.4-15.2-34.9-24.8-57.5-24.8-43.5.0-78.8 35.3-78.8 78.8.0 6.2.7 12.2 2 17.9-65.5-3.3-123.5-34.6-162.4-82.3C20 26 16.1 39.6 16.1 54c0 27.3 13.9 51.4 35 65.6-12.9-.4-25.1-4-35.7-9.9v1c0 38.2 27.2 70 63.2 77.2-6.6 1.8-13.6 2.8-20.8 2.8-5.1.0-10-.5-14.8-1.4 10 31.3 39.1 54.1 73.6 54.7-27 21.1-60.9 33.7-97.8 33.7-6.4.0-12.6-.4-18.8-1.1C34.9 299 76.3 312 120.8 312c144.9.0 224.1-120 224.1-224.1.0-3.4-.1-6.8-.2-10.2 15.4-11.1 28.7-25 39.3-40.8z"/></svg>
<span>Twitter</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=GitHub rel="noopener noreferrer" href=https://github.com/diguage target=_blank><svg class="widget-social__link-icon icon icon-github" width="24" height="24" viewBox="0 0 384 374"><path d="m192 0C85.9.0.0 85.8.0 191.7c0 84.7 55 156.6 131.3 181.9 9.6 1.8 13.1-4.2 13.1-9.2.0-4.6-.2-16.6-.3-32.6-53.4 11.6-64.7-25.7-64.7-25.7-8.7-22.1-21.3-28-21.3-28-17.4-11.9 1.3-11.6 1.3-11.6 19.3 1.4 29.4 19.8 29.4 19.8 17.1 29.3 44.9 20.8 55.9 15.9 1.7-12.4 6.7-20.8 12.2-25.6-42.6-4.8-87.5-21.3-87.5-94.8.0-20.9 7.5-38 19.8-51.4-2-4.9-8.6-24.3 1.9-50.7.0.0 16.1-5.2 52.8 19.7 15.3-4.2 31.7-6.4 48.1-6.5 16.3.1 32.7 2.2 48.1 6.5 36.7-24.8 52.8-19.7 52.8-19.7 10.5 26.4 3.9 45.9 1.9 50.7 12.3 13.4 19.7 30.5 19.7 51.4.0 73.7-44.9 89.9-87.7 94.6 6.9 5.9 13 17.6 13 35.5.0 25.6-.2 46.3-.2 52.6.0 5.1 3.5 11.1 13.2 9.2C329 348.2 384 276.4 384 191.7 384 85.8 298 0 192 0z"/></svg>
<span>GitHub</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=Email href=mailto:leejun119@gmail.com><svg class="widget-social__link-icon icon icon-mail" width="24" height="24" viewBox="0 0 416 288"><path d="m0 16v256 16h16 384 16v-16V16 0h-16H16 0zm347 16-139 92.5L69 32zM199 157.5l9 5.5 9-5.5L384 46v210H32V46z"/></svg>
<span>leejun119@gmail.com</span></a></div></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2025 "地瓜哥"博客网.
<span class=footer__copyright-credits>基于 <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> 引擎和 <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> 主题</span>
<span><a href=https://beian.miit.gov.cn/ target=_target>京ICP备14046450号-4</a></span></div></div></footer></div><script async defer src=/js/menu.js></script><script type=text/x-mathjax-config>
	MathJax.Hub.Config({
	  messageStyle: "none",
	  tex2jax: {
		inlineMath: [["\\(", "\\)"]],
		displayMath: [["\\[", "\\]"]],
		ignoreClass: "nostem|nolatexmath"
	  },
	  asciimath2jax: {
		delimiters: [["\\$", "\\$"]],
		ignoreClass: "nostem|noasciimath"
	  },
	  TeX: { equationNumbers: { autoNumber: "none" } }
	})
	MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
	  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
		if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
		  data.math.root.display = "block"
		}
		return data
	  })
	})
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML" async></script></body></html>