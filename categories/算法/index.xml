<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>算法 on "地瓜哥"博客网</title><link>https://www.diguage.com/categories/%E7%AE%97%E6%B3%95/</link><description>Recent content in 算法 on "地瓜哥"博客网</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Mon, 08 Sep 2025 22:04:47 +0800</lastBuildDate><atom:link href="https://www.diguage.com/categories/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml"/><item><title>Redis 核心数据结构（四）</title><link>https://www.diguage.com/post/redis-core-data-structure-4/</link><pubDate>Tue, 17 Jun 2025 16:36:56 +0800</pubDate><guid>https://www.diguage.com/post/redis-core-data-structure-4/</guid><description>&lt;div class="paragraph">
&lt;p>在 &lt;a href="https://www.diguage.com/post/redis-core-data-structure-3/" target="_blank" rel="noopener">Redis 核心数据结构（三）&lt;/a> 中，重点介绍了一下 Redis 7+ 使用的底层的数据结构 listpack。本文重点看一下，Redis 是如何基于 listpack 以及其他数据结构类型来构建对外暴露的五个核心数据结构的。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_quicklist">quicklist&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>关于 quicklist 更详细的介绍，请看 &lt;a href="https://www.diguage.com/post/redis-core-data-structure-1/#quicklist" target="_blank" rel="noopener">Redis 核心数据结构（一：quicklist&lt;/a>。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>与上述内容不一样的地方是，现在的 quicklist 底层是使用 listpack 来构建的，而不是上述内容介绍的 ziplist。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_list">list&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>关于 &lt;code>list-max-listpack-size&lt;/code> 的解释，在源码中找到了详细介绍：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="title">&lt;code>redis.conf&lt;/code>&lt;/div>
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="bash">&lt;span class="c"># Lists are also encoded in a special way to save a lot of space.&lt;/span>
&lt;span class="c"># The number of entries allowed per internal list node can be specified&lt;/span>
&lt;span class="c"># as a fixed maximum size or a maximum number of elements.&lt;/span>
&lt;span class="c"># For a fixed maximum size, use -5 through -1, meaning:&lt;/span>
&lt;span class="c"># -5: max size: 64 Kb &amp;lt;-- not recommended for normal workloads&lt;/span>
&lt;span class="c"># -4: max size: 32 Kb &amp;lt;-- not recommended&lt;/span>
&lt;span class="c"># -3: max size: 16 Kb &amp;lt;-- probably not recommended&lt;/span>
&lt;span class="c"># -2: max size: 8 Kb &amp;lt;-- good&lt;/span>
&lt;span class="c"># -1: max size: 4 Kb &amp;lt;-- good&lt;/span>
&lt;span class="c"># Positive numbers mean store up to _exactly_ that number of elements&lt;/span>
&lt;span class="c"># per list node.&lt;/span>
&lt;span class="c"># The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),&lt;/span>
&lt;span class="c"># but if your use case is unique, adjust the settings as necessary.&lt;/span>
list-max-listpack-size &lt;span class="nt">-2&lt;/span>&lt;/code>&lt;/pre>
&lt;/div></description></item><item><title>Redis 核心数据结构（三）</title><link>https://www.diguage.com/post/redis-core-data-structure-3/</link><pubDate>Fri, 13 Jun 2025 17:36:31 +0800</pubDate><guid>https://www.diguage.com/post/redis-core-data-structure-3/</guid><description>&lt;div class="paragraph">
&lt;p>在五年前，D瓜哥写了 &lt;a href="https://www.diguage.com/post/redis-core-data-structure-1/" target="_blank" rel="noopener">Redis 核心数据结构（一）&lt;/a> 和 &lt;a href="https://www.diguage.com/post/redis-core-data-structure-2/" target="_blank" rel="noopener">Redis 核心数据结构（二）&lt;/a> 两篇文章，来对 Redis 内部的数据结构做了深入分析。随着时间的推移，Redis 的实现也在不断进化，现在这些内容已经跟不上最新发展了，推陈出新，现在重写文章，来介绍 Redis 的最新发展。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_listpack">listpack&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>从 Redis 7.0 开始，使用 listpack 替换原来的 ziplist。至于替换原因，在 &lt;a href="https://github.com/redis/redis/issues/8702" target="_blank" rel="noopener">[NEW] listpack migration - replace all usage of ziplist with listpack&lt;/a> 做了解释说明：&lt;/p>
&lt;/div>
&lt;div class="quoteblock">
&lt;blockquote>
&lt;div class="paragraph">
&lt;p>The reason for using listpack instead of ziplist is that ziplist may cause cascading updates when insert and delete in middle, which is the biggest problem.&lt;/p>
&lt;/div>
&lt;/blockquote>
&lt;div class="attribution">
— sundb
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>翻译过来：当在中间进行插入和删除时，ziplist 也许会产生级联更新，这是一个大问题。&lt;/p>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_编码规范">编码规范&lt;/h3>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/redis/listpack.png" alt="listpack 编码格式" width="95%"/>
&lt;/div>
&lt;div class="title">图 1. listpack 编码格式&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>相比 ziplist，listpack 更偏向空间换时间。淡化极致的内存使用率，向更快的方向发力。&lt;/p>
&lt;/div>
&lt;div class="sect3">
&lt;h4 id="integer">对整数编码&lt;/h4>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/redis/listpack-integer.png" alt="listpack 整数编码" width="95%"/>
&lt;/div></description></item><item><title>算法模式：子集</title><link>https://www.diguage.com/post/algorithm-pattern-subsets/</link><pubDate>Thu, 10 Apr 2025 11:38:25 +0800</pubDate><guid>https://www.diguage.com/post/algorithm-pattern-subsets/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/algorithm-pattern-backtracking/" target="_blank" rel="noopener">算法模式：回溯&lt;/a> 介绍一种“一步三回头”、“落棋有悔”的算法模式：回溯。本篇文章，介绍一种无需“一步三回头”，无需“落棋有悔”也可以解决排列组合问题的算法模式：子集。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_子集">子集&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>超级多的编程面试问题都会涉及到排列和组合问题。一般都是使用回溯来解决该类问题，回溯法属于 &lt;a href="https://www.diguage.com/post/algorithm-pattern-depth-first-search/" target="_blank" rel="noopener">深度优先搜索&lt;/a>。子集问题模式讲的是用 &lt;a href="https://www.diguage.com/post/algorithm-pattern-breadth-first-search/" target="_blank" rel="noopener">广度优先搜索&lt;/a> 来处理这些问题。子集模式适用于子集与全排列。下面分别介绍：&lt;/p>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="deal-with-subset">处理子集问题&lt;/h3>
&lt;div class="paragraph">
&lt;p>举例来说明一下这个模式：&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>给一组数字 &lt;code>[1, 5, 3]&lt;/code>&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>我们从空集开始：&lt;code>[[]]&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>把第一个数 &lt;code>1&lt;/code>，加到之前已经存在的集合中：&lt;code>[[], [1]]&lt;/code>;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>把第二个数 &lt;code>5&lt;/code>，加到之前的集合中得到：&lt;code>[[], [1], [5], [1,5]]&lt;/code>;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>再加第三个数 &lt;code>3&lt;/code>，则有：&lt;code>[[], [1], [5], [1,5], [3], [1,3], [5,3], [1,5,3]]&lt;/code>.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>如果原有集合中存在重复元素，那么就需要针对这种情况特殊处理一下。流程如下：&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>给一组数字 &lt;code>[5, 1, 5]&lt;/code>&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>先对原有集合进行排序： &lt;code>[1, 5, 3]&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>从空集开始：&lt;code>[[]]&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>把第一个数 &lt;code>1&lt;/code>，加到之前已经存在的集合中：&lt;code>[[], [1]]&lt;/code>;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>把第二个数 &lt;code>5&lt;/code>，加到之前的集合中得到：&lt;code>[[], [1], [5], [1,5]]&lt;/code>;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>处理第三个数，也是 &lt;code>5&lt;/code> 时需要注意：&lt;/p>
&lt;div class="olist loweralpha">
&lt;ol class="loweralpha" type="a">
&lt;li>
&lt;p>如果还是按照上述方案处理，那么就会得到如下结果： &lt;code>[[], [1], [5], [1,5], &lt;strong>[5], [1, 5]&lt;/strong>, [5, 5], [1,5, 5]]&lt;/code>。这里出现了重复子集： &lt;code>[5], [1, 5]&lt;/code>。该方案不通过，❌&lt;/p>
&lt;/li>
&lt;li>
&lt;p>观察最后生成的所有子集与重复的子集，会发现重复的子集，在处理第二个数时，已经处理过 &lt;code>[], [1]&lt;/code>，如果再次处理 &lt;code>5&lt;/code>，那么就会出现重复。所以，只需要处理在处理上一个相同的数时新增加的子集即可。上一个相同数新增的子集是 &lt;code>[5], [1,5]&lt;/code>，只需要在这些子集后面增加当前数字即可。这样最后的子集就是：&lt;code>[[], [1], [5], [1,5], [5, 5], [1,5, 5]]&lt;/code>。方案通过 ✅&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>算法模式：回溯</title><link>https://www.diguage.com/post/algorithm-pattern-backtracking/</link><pubDate>Wed, 09 Apr 2025 17:30:51 +0800</pubDate><guid>https://www.diguage.com/post/algorithm-pattern-backtracking/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/algorithm-pattern-transform-and-conquer/" target="_blank" rel="noopener">算法模式：变治法&lt;/a> 介绍一种有魔力的，可以将复杂问题化繁为简，化腐朽为神奇的算法模式：变治法。本篇文章，介绍一种“一步三回头”、“落棋有悔”的算法模式：回溯。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_回溯">回溯&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>“回溯”算法也叫“回溯搜索”算法，主要用于在一个庞大的空间里搜索我们所需要的问题的解。我们每天使用的“搜索引擎”就是帮助我们在庞大的互联网上搜索我们需要的信息。“搜索”引擎的“搜索”和“回溯搜索”算法的“搜索”意思是一样的。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>“回溯”指的是“状态重置”，可以理解为“回到过去”、“恢复现场”，是在编码的过程中，是为了节约空间而使用的一种技巧。而回溯其实是“深度优先遍历”特有的一种现象。之所以是“深度优先遍历”，是因为我们要解决的问题通常是在一棵树上完成的，在这棵树上搜索需要的答案，一般使用深度优先遍历。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>“全排列”就是一个非常经典的“回溯”算法的应用。我们知道，&lt;code>N&lt;/code> 个数字的全排列一共有 \$N!\$ 这么多个。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>使用编程的方法得到全排列，就是在这样的一个树形结构中进行编程，具体来说，就是&lt;strong>执行一次深度优先遍历，从树的根结点到叶子结点形成的路径就是一个全排列。&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/0046-01.png" alt="0046 01" width="95%"/>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>说明：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>每一个结点表示了“全排列”问题求解的不同阶段，这些阶段通过变量的“不同的值”体现；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这些变量的不同的值，也称之为“状态”；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用深度优先遍历有“回头”的过程，在“回头”以后，状态变量需要设置成为和先前一样；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>因此在回到上一层结点的过程中，需要撤销上一次选择，这个操作也称之为“状态重置”；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>深度优先遍历，可以直接借助系统栈空间，为我们保存所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：往下走一层的时候，&lt;code>path&lt;/code> 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 &lt;code>path&lt;/code> 变量是一个栈。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>深度优先遍历通过“回溯”操作，实现了全局使用一份状态变量的效果。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>解决一个回溯问题，实际上就是一个决策树的遍历过程。&lt;/strong>只需要思考 3 个问题：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>路径：也就是已经做出的选择。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>选择列表：也就是你当前可以做的选择。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>结束条件：也就是到达决策树底层，无法再做选择的条件。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>这三个问题也就对应回溯三部曲：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>定义递归函数以及参数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>确定递归终止条件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>思考递归单层搜索逻辑&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>代码方面，回溯算法的框架：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="rouge highlight">&lt;code>result = []
def backtrack(路径, 选择列表):
 if 满足结束条件:
 result.add(路径)
 return

 for 选择 in 选择列表:
 做选择
 backtrack(路径, 选择列表)
 撤销选择&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>其核心就是 &lt;code>for&lt;/code> 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」&lt;/strong>，特别简单。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 \$O(N!)\$，因为穷举整棵决策树是无法避免的。&lt;strong>这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高。&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>玩回溯，一定要画出递归调用树。这样可以帮助我们更深入地理解整个回溯的过程，方便进一步剪枝优化。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>回溯优化，重要的是，要学会剪枝！&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_leetcode_46_全排列">LeetCode 46. 全排列&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://leetcode.cn/problems/permutations/" target="_blank" rel="noopener">LeetCode - 46. 全排列 &lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>给定一个不含重复数字的数组 &lt;code>nums&lt;/code> ，返回其 &lt;em>所有可能的全排列&lt;/em> 。你可以 &lt;strong>按任意顺序&lt;/strong> 返回答案。&lt;/p>
&lt;/div></description></item><item><title>算法模式：变治法</title><link>https://www.diguage.com/post/algorithm-pattern-transform-and-conquer/</link><pubDate>Tue, 08 Apr 2025 16:50:33 +0800</pubDate><guid>https://www.diguage.com/post/algorithm-pattern-transform-and-conquer/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/algorithm-pattern-divide-and-conquer/" target="_blank" rel="noopener">算法模式：分治法&lt;/a> 介绍一种可用于处理节点前后顺序的算法模式：拓扑排序。本篇文章，介绍一种有魔力的，可以将复杂问题化繁为简，化腐朽为神奇的算法模式：变治法。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_变治法">变治法&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>D瓜哥最早知道变治法也是在 &lt;a href="https://book.douban.com/subject/26337727/" target="_blank" rel="noopener">《算法设计与分析基础》&lt;/a> 中。这里也直接引用该书的介绍。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>变治法，就是基于变换的一种思想方法，首先把问题的实例变得容易求解，然后进行求解。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>变治法的工作可以分成两个阶段：首先把问题变得更容易求解，然后对实例进行求解。根据我们对问题实例的变换方式，变治思想有3种主要的类型：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>实例化简(Instance simplification) — 指将原问题变换为同样问题的一个更简单或者更方便的实例。一个典型的案例是：去重时，先排序，&lt;/p>
&lt;div class="olist loweralpha">
&lt;ol class="loweralpha" type="a">
&lt;li>
&lt;p>列表预排序&lt;/p>
&lt;div class="olist lowerroman">
&lt;ol class="lowerroman" type="i">
&lt;li>
&lt;p>检验数组中元素的唯一性&lt;/p>
&lt;/li>
&lt;li>
&lt;p>模式计算&lt;/p>
&lt;/li>
&lt;li>
&lt;p>查找问题&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>高斯消元法&lt;/p>
&lt;div class="olist lowerroman">
&lt;ol class="lowerroman" type="i">
&lt;li>
&lt;p>系数矩阵的LU分解(LU decomposition)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>计算矩阵的逆&lt;/p>
&lt;/li>
&lt;li>
&lt;p>计算矩阵的行列式&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>AVL 树&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>改变表现(Representation Change) — 指将原问题变换为同样实例的不同表现。经典的栗子：霍纳法则。&lt;/p>
&lt;div class="olist loweralpha">
&lt;ol class="loweralpha" type="a">
&lt;li>
&lt;p>多路平衡查找树（最简单的情况：2-3树）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>求多项式的霍纳法则&lt;/p>
&lt;/li>
&lt;li>
&lt;p>两种二进制幂算法&lt;/p>
&lt;/li>
&lt;li>
&lt;p>堆排序&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>问题化简(Problem reduction) — 指把一个给定的问题变换为另一个可以用已知算法求解的问题。（归化思想）转换的难题在于如何找到一个变换的目标算法。典型案例是背包问题，背包问题的本质是线性规划。了解了线性规划的本质后，才能更好地解决高维的背包问题。&lt;/p>
&lt;div class="olist loweralpha">
&lt;ol class="loweralpha" type="a">
&lt;li>
&lt;p>求最小公倍数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>计算图中的路径数量&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最优化问题（最大化问题(maximization problem)、最小化问题(minimization problem)）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>线性规划（单纯形法、0/1背包问题）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>简化为图问题&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_leetcode_474_一和零">LeetCode 474. 一和零&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://leetcode.cn/problems/ones-and-zeroes/" target="_blank" rel="noopener">LeetCode - 474. 一和零&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>给你一个二进制字符串数组 &lt;code>strs&lt;/code> 和两个整数 &lt;code>m&lt;/code> 和 &lt;code>n&lt;/code> 。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>请你找出并返回 &lt;code>strs&lt;/code> 的最大子集的长度，该子集中 &lt;strong>最多&lt;/strong> 有 &lt;code>m&lt;/code> 个 &lt;code>0&lt;/code> 和 &lt;code>n&lt;/code> 个 &lt;code>1&lt;/code> 。&lt;/p>
&lt;/div></description></item><item><title>算法模式：分治法</title><link>https://www.diguage.com/post/algorithm-pattern-divide-and-conquer/</link><pubDate>Mon, 07 Apr 2025 15:59:27 +0800</pubDate><guid>https://www.diguage.com/post/algorithm-pattern-divide-and-conquer/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/algorithm-pattern-decrease-and-conquer/" target="_blank" rel="noopener">算法模式：减治法&lt;/a> 介绍一种有魔力的，可以将复杂问题化繁为简，化腐朽为神奇的算法模式：减治法。本篇文章，继续介绍一种有魔力的，可以将复杂问题化繁为简，化腐朽为神奇的算法模式：分治法。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_分治法">分治法&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>关于分治法的内容，这里继续参考 &lt;a href="https://book.douban.com/subject/26337727/" target="_blank" rel="noopener">《算法设计与分析基础》&lt;/a> 中的内容。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>分治法是按照以下方案工作的。&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>将一个问题划分为同一类型的若干子问题，子问题最好规模相同。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对这些子问题求解（一般使用递归方法，但在问题规模足够小时，有时也会利用另一个算法）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>有必要的话，合并这些子问题的解，以得到原始问题的答案。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/divide-and-conquer-1.png" alt="分治法" width="95%"/>
&lt;/div>
&lt;div class="title">图 1. 分治法&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>从字面上分析就可以看到有哪些步骤：&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>分-分解-将问题分解为规模更小的子问题，子问题最好相同或相似；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>治-求解-将这些规模更小的子问题逐个击破；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>合-合并-将已解决的子问题合并，最终得出原问题的解；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>从上述步骤中我们可以看出，分治算法一般适用满足以下条件的场景：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>问题规模缩小到一定的程度就可以很容易解决；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>问题&lt;strong>可以分解&lt;/strong>为若干个规模较小的相同问题；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>问题分解出的若干子问题的解可以合并为该问题的解；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每个子问题都是&lt;strong>独立&lt;/strong>的，相互之间没有交集。（这是区别分治法与减）&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>在“分”的过程中，我们尽可能让分解出的子问题与原始问题相似，而规模更小。这刚好符合递归的特性。因此，分治法往往与递归联系在一起。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>在分治法最典型的运用中，问题规模为 &lt;code>n&lt;/code> 的实例被划分为两个规模为 &lt;code>n/2&lt;/code> 的实例。更一般的情况下，一个规模为 &lt;code>n&lt;/code> 的实例可以划分为 &lt;code>b&lt;/code> 个规模为 &lt;code>n/b&lt;/code> 的实例，其中 &lt;code>a&lt;/code> 个实例需要求解（这里，&lt;code>a&lt;/code> 和 &lt;code>b&lt;/code> 是常量，&lt;code>a≥1&lt;/code>，&lt;code>b&amp;gt;1&lt;/code>）。&lt;/p>
&lt;/div>
&lt;div class="stemblock text-center">
&lt;div class="content">
\$T(n) = aT(n/b) + f(n)\$
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>其中，\$f(n)\$ 是一个函数，表示将问题分解为小问题和将结果合并起来所消耗的时间&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>分治法的典型案例如下：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>归并排序&lt;/p>
&lt;/li>
&lt;li>
&lt;p>快速排序&lt;/p>
&lt;/li>
&lt;li>
&lt;p>二叉树的经典遍历算法和其他类似的算法都需要递归处理左右两棵子树&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Strassen 算法&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最近对问题&lt;/p>
&lt;/li>
&lt;li>
&lt;p>凸包问题&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>分治法对&lt;strong>分治出的部分需要分别处理&lt;/strong>，进行分开的单独计算，而减治法则利用了&amp;#34;一个问题给定实例的解和同样问题较小实例的解之间的关系&amp;#34;，只针对部分子问题求解，&lt;strong>减治掉的那部分就不需要了&lt;/strong>。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>减常因子的减治法也可以看做是分治的变种。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_leetcode_148_排序链表">LeetCode 148. 排序链表&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://leetcode.cn/problems/sort-list/" target="_blank" rel="noopener">LeetCode - 148. 排序链表 &lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>给你链表的头结点 &lt;code>head&lt;/code> ，请将其按 &lt;strong>升序&lt;/strong> 排列并返回 &lt;strong>排序后的链表&lt;/strong> 。&lt;/p>
&lt;/div></description></item><item><title>算法模式：减治法</title><link>https://www.diguage.com/post/algorithm-pattern-decrease-and-conquer/</link><pubDate>Sun, 06 Apr 2025 23:32:03 +0800</pubDate><guid>https://www.diguage.com/post/algorithm-pattern-decrease-and-conquer/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/algorithm-pattern-topological-sort/" target="_blank" rel="noopener">算法模式：拓扑排序&lt;/a> 介绍一种可用于处理节点前后顺序的算法模式：拓扑排序。本篇文章，介绍一种有魔力的，可以将复杂问题化繁为简，化腐朽为神奇的算法模式：减治法。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_减治法">减治法&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>D瓜哥最早知道减治法是在 &lt;a href="https://book.douban.com/subject/26337727/" target="_blank" rel="noopener">《算法设计与分析基础》&lt;/a> 中。这里也直接引用该书的介绍。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>减治(decrease-and-conquer)技术利用了一个问题给定实例的解和同样问题较小实例的解之间的某种关系。自底向上版本往往是迭代实现的，从求解问题的一个较小实例开始，该方法有时也称为增量法(Incremental Approach)。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>减治法有3种主要的变化形式：&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;strong>减去一个常量。&lt;/strong>在减常量(decrease-by-a-constant)变化形式中，每次算法迭代总是从实例中减去一个相同的常量。&lt;/p>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>插入排序&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>减去一个常量因子。&lt;/strong>减常因子(decrease-by-a-constant-factor)技术意味着在算法的每次迭代中，总是从实例的规模中减去一个相同的常数因子。在大多数应用中，这样的常数因子等于2，其实就是减半。&lt;/p>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>二分查找&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>减去的规模是可变的。&lt;/strong>在减治法的减可变规模(variable-size-decrease)变化形式中，算法在每次迭代时，规模减小的模式都是不同的。&lt;/p>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>计算最大公约数的欧几里得算法是这种情况的一个很好的例子。 \$gcd(m, n)=gcd(n,m mod n)\$&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_leetcode_50_powx_n">LeetCode 50. Pow(x, n)&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://leetcode.cn/problems/powx-n/" target="_blank" rel="noopener">LeetCode - 50. Pow(x, n) &lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>实现 &lt;a href="https://www.cplusplus.com/reference/valarray/pow/">pow(x, n)&lt;/a> ，即计算 &lt;code>x&lt;/code> 的整数 &lt;code>n&lt;/code> 次幂函数（即，&lt;code>x&lt;sup>n&lt;/sup>&lt;/code>）。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入：x = 2.00000, n = 10
输出：1024.00000&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入：x = 2.10000, n = 3
输出：9.26100&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 3：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入：x = 2.00000, n = -2
输出：0.25000
解释：2-2 = 1/22 = 1/4 = 0.25&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>提示：&lt;/strong>&lt;/p>
&lt;/div></description></item><item><title>算法模式：拓扑排序</title><link>https://www.diguage.com/post/algorithm-pattern-topological-sort/</link><pubDate>Fri, 04 Apr 2025 09:09:09 +0800</pubDate><guid>https://www.diguage.com/post/algorithm-pattern-topological-sort/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/algorithm-pattern-union-find/" target="_blank" rel="noopener">算法模式：并查集&lt;/a> 介绍一种关于特殊的树的算法模式：并查集。本篇文章，介绍一种可用于处理节点前后顺序的算法模式：拓扑排序。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_拓扑排序">拓扑排序&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>拓扑排序模式用来寻找一种线性的顺序，这些元素之间具有依懒性。比如，如果事件 B 依赖于事件 A，那 A 在拓扑排序顺序中排在 B 的前面。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>这种模式定义了一种简单方式来理解拓扑排序这种技术。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>这种模式是这样奏效的：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>初始化&lt;/p>
&lt;div class="olist loweralpha">
&lt;ol class="loweralpha" type="a">
&lt;li>
&lt;p>借助于 &lt;code>Map&lt;/code> 将图保存成邻接表形式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>找到所有的起点，用 &lt;code>Map&lt;/code> 来帮助记录每个节点的入度&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>创建图，找到每个节点的入度&lt;/p>
&lt;div class="olist loweralpha">
&lt;ol class="loweralpha" type="a">
&lt;li>
&lt;p>利用输入，把图建好，然后遍历一下图，将入度信息记录在 &lt;code>Map&lt;/code> 中&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>找所有的起点&lt;/p>
&lt;div class="olist loweralpha">
&lt;ol class="loweralpha" type="a">
&lt;li>
&lt;p>所有入度为 &lt;code>0&lt;/code> 的节点，都是有效的起点，而且我们讲他们都加入到一个队列中&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>排序&lt;/p>
&lt;div class="olist loweralpha">
&lt;ol class="loweralpha" type="a">
&lt;li>
&lt;p>对每个起点，执行以下步骤&lt;/p>
&lt;div class="olist lowerroman">
&lt;ol class="lowerroman" type="i">
&lt;li>
&lt;p>把它加到结果的顺序中&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将其在图中的孩子节点取到&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将其孩子的入度减少1&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果孩子的入度变为0，则改孩子节点成为起点，将其加入队列中&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>重复上述过程，直到起点队列为空。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>用一句话概括：&lt;strong>将依赖关系转化成一张有向图，如果这张图中的节点没有循环依赖，那么则方案可行，否则方案不可行。&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="admonitionblock tip">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-tip" title="Tip">&lt;/i>
&lt;/td>
&lt;td class="content">
这里解释的是一种广度优先搜索，还存在一种深度优先搜索的处理办法，感兴趣可以尝试一下。
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="paragraph">
&lt;p>拓扑排序模式识别：&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>待解决的问题需要处理无环图&lt;/p>
&lt;/li>
&lt;li>
&lt;p>你需要以一种有序的秩序更新输入元素&lt;/p>
&lt;/li>
&lt;li>
&lt;p>需要处理的输入遵循某种特定的顺序&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_leetcode_207_课程表">LeetCode 207. 课程表&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://leetcode.cn/problems/course-schedule/" target="_blank" rel="noopener">LeetCode - 207. 课程表 &lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>你这个学期必须选修 &lt;code>numCourses&lt;/code> 门课程，记为 &lt;code>0&lt;/code> 到 &lt;code>numCourses - 1&lt;/code> 。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>在选修某些课程之前需要一些先修课程。 先修课程按数组 &lt;code>prerequisites&lt;/code> 给出，其中 &lt;code>prerequisites[i] = [a&lt;sub>i&lt;/sub>, b&lt;sub>i&lt;/sub>]&lt;/code>，表示如果要学习课程 &lt;code>a&lt;sub>i&lt;/sub>&lt;/code> 则 &lt;strong>必须&lt;/strong> 先学习课程 &lt;code>b&lt;sub>i&lt;/sub>&lt;/code>。&lt;/p>
&lt;/div></description></item><item><title>算法模式：并查集</title><link>https://www.diguage.com/post/algorithm-pattern-union-find/</link><pubDate>Thu, 03 Apr 2025 15:22:41 +0800</pubDate><guid>https://www.diguage.com/post/algorithm-pattern-union-find/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/algorithm-pattern-trie/" target="_blank" rel="noopener">算法模式：前缀树&lt;/a> 介绍一种关于特殊的树的算法模式。本篇文章，再介绍一种关于特殊的树的算法模式：并查集。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_并查集">并查集&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>并查集算法，英文是 Union-Find，是解决动态连通性（Dynamic Conectivity）问题的一种算法。动态连通性是计算机图论中的一种数据结构，动态维护图结构中相连信息。简单的说就是，图中各个节点之间是否相连、如何将两个节点连接，连接后还剩多少个连通分量。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>动态连通性其实可以抽象成给一幅图连线。假设用一个数组表示一堆节点，每个节点都是一个连通分量。初始化视图如下：&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/union-find-1.png" alt="并查集初始化" width="95%"/>
&lt;/div>
&lt;div class="title">图 1. 并查集初始化&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>并查集的一个重要操作是 &lt;code>union(a, b)&lt;/code>，就是将节点 &lt;code>a&lt;/code> 和节点 &lt;code>b&lt;/code> 建立连接。如图所示：&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/union-find-2.png" alt="并查集合并" width="95%"/>
&lt;/div>
&lt;div class="title">图 2. 并查集合并&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;code>union(a, b)&lt;/code> 还可以将已经建立的两个“子网”进行连接：&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/union-find-3.png" alt="并查集再合并" width="95%"/>
&lt;/div>
&lt;div class="title">图 3. 并查集再合并&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>并查集除了 &lt;code>union&lt;/code>，还有一个重要操作是 &lt;code>connnected(a, b)&lt;/code>。判断方法也很简单，从节点 &lt;code>a&lt;/code> 和 &lt;code>b&lt;/code> 开始，向上查找，直到两个节点的根节点，判断两个根节点是否相等即可判断两个节点是否已经连接。为了加快这个判断速度，可以对其进行“路径压缩”，直白点说，就是将所有树的节点，都直接指向根节点，这样只需要一步即可到达根节点。路径压缩如图所示：&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/union-find-4.png" alt="并查集路径压缩" width="95%"/>
&lt;/div>
&lt;div class="title">图 4. 并查集路径压缩&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>简单代码实现如下：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="java">&lt;span class="kn">package&lt;/span> &lt;span class="nn">com.diguage.labs&lt;/span>&lt;span class="o">;&lt;/span>

&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.util.ArrayList&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.util.List&lt;/span>&lt;span class="o">;&lt;/span>

&lt;span class="cm">/**
 * 并查集
 *
 * PS：没想到代码竟然一次通过。
 *
 * @author D瓜哥 · &lt;a href="https://www.diguage.com" target="_blank">https://www.diguage.com&lt;/a>
 * @since 2025-04-03 15:22:41
 */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">UnionFind&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="cm">/**
 * 连通分量
 */&lt;/span>
 &lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="cm">/**
 * 每个节点及对应的父节点
 */&lt;/span>
 &lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">parent&lt;/span>&lt;span class="o">;&lt;/span>

 &lt;span class="kd">public&lt;/span> &lt;span class="nf">UnionFind&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">this&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="n">parent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="o">];&lt;/span>
 &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">parent&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="o">}&lt;/span>

 &lt;span class="cm">/**
 * a 和 b 建立连接
 */&lt;/span>
 &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">union&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="kt">int&lt;/span> &lt;span class="n">ap&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">find&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="kt">int&lt;/span> &lt;span class="n">bp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">find&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">ap&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">bp&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">return&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="n">parent&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">ap&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bp&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="n">size&lt;/span>&lt;span class="o">--;&lt;/span>
 &lt;span class="o">}&lt;/span>

 &lt;span class="cm">/**
 * a 和 b 是否连通
 */&lt;/span>
 &lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">connected&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="kt">int&lt;/span> &lt;span class="n">ap&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">find&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="kt">int&lt;/span> &lt;span class="n">bp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">find&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="n">ap&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">bp&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>

 &lt;span class="cm">/**
 * 连通分量
 */&lt;/span>
 &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">count&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>

 &lt;span class="cm">/**
 * 查找节点 a 的根节点
 */&lt;/span>
 &lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">find&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="kt">int&lt;/span> &lt;span class="n">ap&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">parent&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">];&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">a&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">ap&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nc">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">ArrayList&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
 &lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="c1">// 向上查找根节点&lt;/span>
 &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">ap&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">ap&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ap&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">ap&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">parent&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">ap&lt;/span>&lt;span class="o">];&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="c1">// 路径压缩&lt;/span>
 &lt;span class="c1">// 只有一步，无需缩短路径&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="n">ap&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="nc">Integer&lt;/span> &lt;span class="n">idx&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">path&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">parent&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">idx&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ap&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="n">ap&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>

 &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">UnionFind&lt;/span> &lt;span class="n">uf&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">UnionFind&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">uf&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">union&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">uf&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">union&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">uf&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">union&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">uf&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">union&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">uf&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">union&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">uf&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">union&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">uf&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">union&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">7&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">uf&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">union&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">uf&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">union&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="nc">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">uf&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">count&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34;, &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">uf&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">connected&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="o">));&lt;/span>
 &lt;span class="nc">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">uf&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">count&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34;, &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">uf&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">connected&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="o">));&lt;/span>
 &lt;span class="nc">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">uf&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">count&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34;, &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">uf&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">connected&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="o">));&lt;/span>
 &lt;span class="nc">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">uf&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">count&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34;, &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">uf&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">connected&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="o">));&lt;/span>
 &lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div></description></item><item><title>算法模式：前缀树</title><link>https://www.diguage.com/post/algorithm-pattern-trie/</link><pubDate>Wed, 02 Apr 2025 19:16:24 +0800</pubDate><guid>https://www.diguage.com/post/algorithm-pattern-trie/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/algorithm-pattern-depth-first-search/" target="_blank" rel="noopener">算法模式：深度优先搜索&lt;/a> 介绍了介绍一种即适用于树，又适用于图的的算法模式。本篇文章，介绍一种关于特殊的树的算法模式：前缀树。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_前缀树">前缀树&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>前缀树，又称为字典树，还叫单词查找树，英文是 Trie，也有叫 Prefix Tree。顾名思义，就是一个像字典一样的树。如图：&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/trie.svg" alt="前缀树" width="95%"/>
&lt;/div>
&lt;div class="title">图 1. 前缀树&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>前缀树是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_leetcode_208_实现_trie_前缀树">LeetCode 208. 实现 Trie (前缀树)&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://leetcode.cn/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">LeetCode - 208. 实现 Trie (前缀树) &lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>&lt;a href="https://baike.baidu.com/item/字典树/9825209?fr=aladdin">Trie&lt;/a>&lt;/strong>（发音类似 &amp;#34;try&amp;#34;）或者说 &lt;strong>前缀树&lt;/strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>请你实现 Trie 类：&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;code>Trie()&lt;/code> 初始化前缀树对象。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>void insert(String word)&lt;/code> 向前缀树中插入字符串 &lt;code>word&lt;/code> 。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>boolean search(String word)&lt;/code> 如果字符串 &lt;code>word&lt;/code> 在前缀树中，返回 &lt;code>true&lt;/code>（即，在检索之前已经插入）；否则，返回 &lt;code>false&lt;/code> 。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>boolean startsWith(String prefix)&lt;/code> 如果之前已经插入的字符串 &lt;code>word&lt;/code> 的前缀之一为 &lt;code>prefix&lt;/code> ，返回 &lt;code>true&lt;/code> ；否则，返回 &lt;code>false&lt;/code> 。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入
[&amp;#34;Trie&amp;#34;, &amp;#34;insert&amp;#34;, &amp;#34;search&amp;#34;, &amp;#34;search&amp;#34;, &amp;#34;startsWith&amp;#34;, &amp;#34;insert&amp;#34;, &amp;#34;search&amp;#34;]
[[], [&amp;#34;apple&amp;#34;], [&amp;#34;apple&amp;#34;], [&amp;#34;app&amp;#34;], [&amp;#34;app&amp;#34;], [&amp;#34;app&amp;#34;], [&amp;#34;app&amp;#34;]]
输出
[null, null, true, false, true, null, true]

解释
Trie trie = new Trie();
trie.insert(&amp;#34;apple&amp;#34;);
trie.search(&amp;#34;apple&amp;#34;); // 返回 True
trie.search(&amp;#34;app&amp;#34;); // 返回 False
trie.startsWith(&amp;#34;app&amp;#34;); // 返回 True
trie.insert(&amp;#34;app&amp;#34;);
trie.search(&amp;#34;app&amp;#34;); // 返回 True&lt;/pre>
&lt;/div></description></item><item><title>算法模式：深度优先搜索</title><link>https://www.diguage.com/post/algorithm-pattern-depth-first-search/</link><pubDate>Tue, 01 Apr 2025 10:43:31 +0800</pubDate><guid>https://www.diguage.com/post/algorithm-pattern-depth-first-search/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/algorithm-pattern-breadth-first-search/" target="_blank" rel="noopener">算法模式：广度优先搜索&lt;/a> 介绍了介绍一种即适用于树，又适用于图的的算法模式。本篇文章，继续介绍一种即适用于树，又适用于图的的算法模式：深度优先搜索。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_深度优先搜索">深度优先搜索&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>深度优先搜索主要思路是从图中一个未访问的顶点 V 开始，沿着一条路一直走到底，然后从这条路尽头的节点回退到上一个节点，再从另一条路开始走到底…​，不断递归重复此过程，直到所有的顶点都遍历完成，它的特点是不撞南墙不回头，先走完一条路，再换一条路继续走。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>树是图的一种特例(连通无环的图就是树)，所以，深度优先搜索也适用于树。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>在对树做深度优先搜索时，可以用递归（或显式栈，如果你想用迭代方式的话）来记录遍历过程中访问过的父节点。运行方式是从根节点开始，如果该节点不是叶子节点，我们需要干三件事：&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>需要区别我们是先处理根节点（pre-order，前序），处理孩子节点之间处理根节点（in-order，中序），还是处理完所有孩子再处理根节点（post-order，后序）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>递归处理当前节点的左右孩子。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_leetcode_124_二叉树中的最大路径和">LeetCode 124. 二叉树中的最大路径和&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">LeetCode - 124. 二叉树中的最大路径和 &lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>二叉树中的 &lt;strong>路径&lt;/strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 &lt;strong>至多出现一次&lt;/strong> 。该路径 &lt;strong>至少包含一个&lt;/strong> 节点，且不一定经过根节点。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>路径和&lt;/strong> 是路径中各节点值的总和。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>给你一个二叉树的根节点 &lt;code>root&lt;/code> ，返回其 &lt;strong>最大路径和&lt;/strong> 。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre> 1
 / \
 2 3
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -&amp;gt; 1 -&amp;gt; 3 ，路径和为 2 + 1 + 3 = 6&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre> -10
 / \
 9 20
 / \
 15 7

输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -&amp;gt; 20 -&amp;gt; 7 ，路径和为 15 + 20 + 7 = 42&lt;/pre>
&lt;/div></description></item><item><title>算法模式：广度优先搜索</title><link>https://www.diguage.com/post/algorithm-pattern-breadth-first-search/</link><pubDate>Mon, 31 Mar 2025 07:31:39 +0800</pubDate><guid>https://www.diguage.com/post/algorithm-pattern-breadth-first-search/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/algorithm-pattern-k-way-merge/" target="_blank" rel="noopener">算法模式：多路归并&lt;/a> 介绍了一种利用堆做链表合并的算法模式。本篇文章，介绍一种即适用于树，又适用于图的的算法模式：广度优先搜索。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_广度优先搜索">广度优先搜索&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>广度优先搜索既适用于树，又适用于图。除此之外，在处理一些矩阵问题时，也会用到广度优先搜索的思想。当然，也可以把矩阵按照图来理解。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>树上的广度优先搜索模式是通过把根节点加到队列中，然后不断遍历直到队列为空。每一次循环中，我们都会把队头结点拿出来（remove），然后对其进行必要的操作。在删除每个节点的同时，其孩子节点，都会被加到队列中。借助于队列数据结构，从而能保证树的节点按照他们的层数打印出来。打印完当前层所有元素，才能执行到下一层。所有这种需要遍历树且需要一层一层遍历的问题，都能用这种模式高效解决。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>识别树上的广度优先搜索：&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>如果你被问到去遍历树，需要按层操作的方式（也称作层序遍历）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_leetcode_102_二叉树的层序遍历">LeetCode 102. 二叉树的层序遍历&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">LeetCode - 102. 二叉树的层序遍历 &lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>给你二叉树的根节点 &lt;code>root&lt;/code> ，返回其节点值的 &lt;strong>层序遍历&lt;/strong> 。（即逐层地，从左到右访问所有节点）。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/0102-00.jpg" alt="0102 00" width="95%"/>
&lt;/div>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入：root = [1]
输出：[[1]]&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 3：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入：root = []
输出：[]&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>提示：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>树中节点数目在范围 &lt;code>[0, 2000]&lt;/code> 内&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-1000 &amp;lt;= Node.val &amp;lt;= 1000&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_思路分析">思路分析&lt;/h3>
&lt;div class="paragraph">
&lt;p>思路与上述描述类似，这里直接看图：&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/0102-00.png" alt="广度优先搜索" width="95%"/>
&lt;/div>
&lt;div class="title">图 1. 广度优先搜索&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>代码如下：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="java">&lt;span class="cm">/**
 * @author D瓜哥 · &lt;a href="https://www.diguage.com" target="_blank">https://www.diguage.com&lt;/a>
 * @since 2025-03-31 07:31:39
 */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="nc">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nc">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nc">Integer&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="nf">levelOrder&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">TreeNode&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="nc">Collections&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">emptyList&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="nc">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nc">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nc">Integer&lt;/span>&lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">LinkedList&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
 &lt;span class="nc">Queue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nc">TreeNode&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">queue&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">LinkedList&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
 &lt;span class="n">queue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">offer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="k">while&lt;/span> &lt;span class="o">(!&lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isEmpty&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="kt">int&lt;/span> &lt;span class="n">size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">queue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">size&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="nc">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nc">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">level&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">ArrayList&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;(&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">TreeNode&lt;/span> &lt;span class="n">node&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">queue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">poll&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="n">level&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">val&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="c1">// 将下一层节点，从左到右，依次加入到队列中&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">queue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">offer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">queue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">offer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="n">result&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">level&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>算法模式：多路归并</title><link>https://www.diguage.com/post/algorithm-pattern-k-way-merge/</link><pubDate>Sun, 30 Mar 2025 23:20:44 +0800</pubDate><guid>https://www.diguage.com/post/algorithm-pattern-k-way-merge/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/algorithm-pattern-two-heaps/" target="_blank" rel="noopener">算法模式：双堆&lt;/a> 介绍了一种利用两个堆选择中间数的算法模式。本篇文章，再来介绍一种关于堆的模式：多路归并。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_多路归并">多路归并&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>多路归并能帮咱们解决那些涉及到多组排好序的数组的问题。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>每当你的输入是 K 个排好序的数组，你就可以用堆来高效顺序遍历其中所有数组的所有元素。你可以将每个数组中最小的一个元素加入到最小堆中，从而得到全局最小值。当我们拿到这个全局最小值之后，再从该元素所在的数组里取出其后面紧挨着的元素，加入堆。如此往复直到处理完所有的元素。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>该模式是这样的运行的：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>把每个数组中的第一个元素都加入最小堆中&lt;/p>
&lt;/li>
&lt;li>
&lt;p>取出堆顶元素（全局最小），将该元素放入排好序的结果集合里面&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将刚取出的元素所在的数组里面的下一个元素加入堆&lt;/p>
&lt;/li>
&lt;li>
&lt;p>重复步骤 2，3，直到处理完所有数字&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>识别K路归并：&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>该问题的输入是排好序的数组，链表或是矩阵&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果问题让咱们合并多个排好序的集合，或是需要找这些集合中最小的元素&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_leetcode_23_合并_k_个升序链表">LeetCode 23. 合并 K 个升序链表&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://leetcode.cn/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">LeetCode - 23. 合并 K 个升序链表 &lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>给你一个链表数组，每个链表都已经按升序排列。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>请你将所有链表合并到一个升序链表中，返回合并后的链表。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
 1-&amp;gt;4-&amp;gt;5,
 1-&amp;gt;3-&amp;gt;4,
 2-&amp;gt;6
]
将它们合并到一个有序链表中得到。
1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入：lists = []
输出：[]&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 3：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入：lists = [[]]
输出：[]&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>提示：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;code>k == lists.length&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>0 &amp;lt;= k &amp;lt;= 10&lt;sup>4&lt;/sup>&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>0 &amp;lt;= lists[i].length &amp;lt;= 500&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-10&lt;sup>4&lt;/sup> &amp;lt;= lists[i][j] &amp;lt;= 10&lt;sup>4&lt;/sup>&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>lists[i]&lt;/code> 按 &lt;strong>升序&lt;/strong> 排列&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>lists[i].length&lt;/code> 的总和不超过 &lt;code>10&lt;sup>4&lt;/sup>&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div></description></item><item><title>算法模式：双堆</title><link>https://www.diguage.com/post/algorithm-pattern-two-heaps/</link><pubDate>Fri, 28 Mar 2025 17:00:16 +0800</pubDate><guid>https://www.diguage.com/post/algorithm-pattern-two-heaps/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/algorithm-pattern-cyclic-sort/" target="_blank" rel="noopener">算法模式：循环排序&lt;/a> 介绍了一种只需 \$O(1)\$ 时间就可以完成排序的算法模式。本篇文章，来介绍一种可以快速查出数组中位数的模式：双堆。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_双堆">双堆&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>很多问题中，我们被告知，我们拿到一大把可以分成两队的数字。为了解决这个问题，我们感兴趣的是，怎么把数字分成两半？使得：小的数字都放在一起，大的放在另外一半。双堆模式就能高效解决此类问题。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>正如名字所示，该模式用到了两个堆，是不是很难猜？一个最小堆用来找最小元素；一个最大堆，拿到最大元素。这种模式将一半的元素放在最大堆中，这样你可以从这一堆中秒找到最大元素。同理，把剩下一半丢到最小堆中，\$O(1)\$ 时间找到他们中的最小元素。通过这样的方式，这一大堆元素的中位数就可以从两个堆的堆顶拿到数字，从而计算出来。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>判断双堆模式的秘诀：&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>这种模式在优先队列，计划安排问题（Scheduling）中有奇效&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果问题让你找一组数中的最大/最小/中位数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>有时候，这种模式在涉及到二叉树数据结构时也特别有用&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/max-min-heap.svg" alt="大堆与小堆" width="95%"/>
&lt;/div>
&lt;div class="title">图 1. 大堆与小堆&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_leetcode_295_数据流的中位数">LeetCode 295. 数据流的中位数&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://leetcode.cn/problems/find-median-from-data-stream/" target="_blank" rel="noopener">LeetCode - 295. 数据流的中位数 &lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>中位数&lt;/strong>是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>例如 &lt;code>arr = [2,3,4]&lt;/code> 的中位数是 &lt;code>3&lt;/code> 。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>例如 &lt;code>arr = [2,3]&lt;/code> 的中位数是 &lt;code>(2 + 3) / 2 = 2.5&lt;/code> 。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>实现 MedianFinder 类:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;code>MedianFinder()&lt;/code> 初始化 &lt;code>MedianFinder&lt;/code> 对象。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>void addNum(int num)&lt;/code> 将数据流中的整数 &lt;code>num&lt;/code> 添加到数据结构中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>double findMedian()&lt;/code> 返回到目前为止所有元素的中位数。与实际答案相差 &lt;code>10&lt;sup>-5&lt;/sup>&lt;/code> 以内的答案将被接受。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入
[&amp;#34;MedianFinder&amp;#34;, &amp;#34;addNum&amp;#34;, &amp;#34;addNum&amp;#34;, &amp;#34;findMedian&amp;#34;, &amp;#34;addNum&amp;#34;, &amp;#34;findMedian&amp;#34;]
[[], [1], [2], [], [3], []]
输出
[null, null, null, 1.5, null, 2.0]

解释
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1); // arr = [1]
medianFinder.addNum(2); // arr = [1, 2]
medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)
medianFinder.addNum(3); // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0&lt;/pre>
&lt;/div></description></item><item><title>算法模式：循环排序</title><link>https://www.diguage.com/post/algorithm-pattern-cyclic-sort/</link><pubDate>Thu, 27 Mar 2025 22:16:54 +0800</pubDate><guid>https://www.diguage.com/post/algorithm-pattern-cyclic-sort/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/algorithm-pattern-quickselect/" target="_blank" rel="noopener">算法模式：快速选择&lt;/a> 介绍了如何利用快排思想快速选出第 K 个 最 X 的元素。本篇文章，介绍一种只需 \$O(1)\$ 时间就可以完成排序的算法模式：循环排序。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_循环排序">循环排序&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>循环排序讲述的是一种很好玩的模式：可以用来处理数组中的数值限定在一定的区间的问题。这种模式一个个遍历数组中的元素，如果当前这个数它不在其应该在的位置的话，咱们就把它和它应该在的那个位置上的数交换一下。你可以尝试将该数放到其正确的位置上，但这复杂度就会是 \$O(n^2)\$。这样的话，可能就不是最优解了。因此循环排序的优势就体现出来了。&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/cyclic-sort.png" alt="循环排序" width="95%"/>
&lt;/div>
&lt;div class="title">图 1. 循环排序&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>循环排序适用的场景：&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>包含连续数字的数组（如 1 到 n 或 0 到 n-1）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>需要找出缺失/重复数字的问题&lt;/p>
&lt;/li>
&lt;li>
&lt;p>需要原地排序且时间复杂度要求高的情况&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_leetcode_41_缺失的第一个正数">LeetCode 41. 缺失的第一个正数&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://leetcode.cn/problems/first-missing-positive/" target="_blank" rel="noopener">LeetCode - 41. 缺失的第一个正数&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>给你一个未排序的整数数组 &lt;code>nums&lt;/code> ，请你找出其中没有出现的最小的正整数。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>请你实现时间复杂度为 \$O(n)\$ 并且只使用常数级别额外空间的解决方案。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入：nums = [1,2,0]
输出：3
解释：范围 [1,2] 中的数字都在数组中。&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入：nums = [3,4,-1,1]

输出：2

解释：1 在数组中，但 2 没有。&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 3：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入：nums = [7,8,9,11,12]
输出：1
解释：最小的正数 1 没有出现。&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>提示：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;code>1 &amp;lt;= nums.length &amp;lt;= 10&lt;sup>5&lt;/sup>&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-2&lt;sup>31&lt;/sup> &amp;lt;= nums[i] &amp;lt;= 2&lt;sup>31&lt;/sup> - 1&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div></description></item><item><title>算法模式：快速选择</title><link>https://www.diguage.com/post/algorithm-pattern-quickselect/</link><pubDate>Wed, 26 Mar 2025 16:24:19 +0800</pubDate><guid>https://www.diguage.com/post/algorithm-pattern-quickselect/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/algorithm-pattern-top-k-elements/" target="_blank" rel="noopener">算法模式：Top K 问题&lt;/a> 介绍了如何利用堆快速选出最 X 的 K 个元素。本篇文章，介绍一种可以快速选择第 K 个 最 X 元素的算法模式：快速选择。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_快速选择">快速选择&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>快速选择起源于快排算法。在快排算法中，把元素根据基准元素分成左右两部分，一边的元素小于基准元素，另外一个的元素大于等于基准元素，再对两边的元素递归处理，最终得到有序结果。受此启发，在将元素根据基准元素分成左右两部分后，这里假设，左边小于基准元素，右边大于等于基准元素，那么会有如下三种情况：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>当前基准元素所在位置正好是 K，正好是所求结果，直接返回；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当前基准元素所在位置小于 K，那么 K 位置在当前基准元素的右边；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当前基准元素所在位置大于 K，那么 K 位置在当前基准元素的左边；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>所以，该模式不仅适用于求第 K 个之最元素，也适用于求“Top K 问题”。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_leetcode_215_数组中的第k个最大元素">LeetCode 215. 数组中的第K个最大元素&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">LeetCode - 215. 数组中的第K个最大元素 &lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>给定整数数组 &lt;code>nums&lt;/code> 和整数 &lt;code>k&lt;/code>，请返回数组中第 &lt;strong>&lt;code>k&lt;/code>&lt;/strong> 个最大的元素。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>请注意，你需要找的是数组排序后的第 &lt;code>k&lt;/code> 个最大的元素，而不是第 &lt;code>k&lt;/code> 个不同的元素。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>你必须设计并实现时间复杂度为 \$O(n)\$ 的算法解决此问题。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 1:&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入: [3,2,1,5,6,4], k = 2
输出: 5&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 2:&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4&lt;/pre>
&lt;/div></description></item><item><title>算法模式：Top K 问题</title><link>https://www.diguage.com/post/algorithm-pattern-top-k-elements/</link><pubDate>Tue, 25 Mar 2025 21:20:04 +0800</pubDate><guid>https://www.diguage.com/post/algorithm-pattern-top-k-elements/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/algorithm-pattern-monotonic-stack/" target="_blank" rel="noopener">算法模式：单调栈&lt;/a> 介绍了单调栈的算法模式。本篇文章，介绍一种堆相关的算法模式：Top K 问题。（英语原文是 Top K Elements，实在没有找到好的翻译，暂时翻译成 “Top K 问题”，后续有好的翻译再改。）&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_top_k_问题">Top K 问题&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>任何让求解最大/最小/最频繁的K个元素的题，都遵循这种模式。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>用来记录这种前 K 类型的最佳数据结构就是堆了（在Java中，对应的结构是优先队列 &lt;code>PriorityQueue&lt;/code> ）。这种模式借助堆来解决很多这种前 K 个数值的问题。&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/max-min-heap.svg" alt="大堆与小堆" width="95%"/>
&lt;/div>
&lt;div class="title">图 1. 大堆与小堆&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>这个模式是这样的：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>根据题目要求，将K个元素插入到最小堆或是最大堆。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>遍历剩下的还没访问的元素，如果当前出来到的这个元素比堆顶元素大或者小，那咱们把堆顶元素先删除，再加当前元素进去。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>如果求最大的前 K 个元素，则适合使用小堆，将待检查元素与堆顶元素相比，堆顶元素小，直接删除堆顶元素，将待检查元素添加到堆即可。反之，则用大堆。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>注意这种模式下，咱们不需要去排序数组，因为堆具有这种良好的局部有序性，这对咱们需要解决问题就够了。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>识别最大 K 个元素模式：&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>如果你需要求最大/最小/最频繁的前K个元素&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果你需要通过排序去找一个特定的数&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_leetcode_347_前_k_个高频元素">LeetCode 347. 前 K 个高频元素&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://leetcode.cn/problems/top-k-frequent-elements/" target="_blank" rel="noopener">LeetCode - 347. 前 K 个高频元素 &lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>给你一个整数数组 &lt;code>nums&lt;/code> 和一个整数 &lt;code>k&lt;/code> ，请你返回其中出现频率前 &lt;code>k&lt;/code> 高的元素。你可以按 &lt;strong>任意顺序&lt;/strong> 返回答案。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 1:&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 2:&lt;/strong>&lt;/p>
&lt;/div></description></item><item><title>算法模式：单调栈</title><link>https://www.diguage.com/post/algorithm-pattern-monotonic-stack/</link><pubDate>Mon, 24 Mar 2025 20:26:12 +0800</pubDate><guid>https://www.diguage.com/post/algorithm-pattern-monotonic-stack/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/algorithm-pattern-sliding-window/" target="_blank" rel="noopener">算法模式：滑动窗口&lt;/a> 介绍了滑动窗口的算法模式。本篇文章，介绍一种堆栈相关的算法模式：单调栈。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_单调栈">单调栈&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>所谓单调栈，就是在栈的基础上，增加了一个附加条件：栈内元素单调递增或者递减，如果不符合要求，则将元素出栈，直到符合条件为止。当需要给当前的元素，找右边/左边第一个比它大/小的位置时，就特别适合使用单调栈。&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/monotonically-increasing-stack.svg" alt="单调递增栈" width="95%"/>
&lt;/div>
&lt;div class="title">图 1. 单调递增栈&lt;/div>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/monotonically-decreasing-stack.svg" alt="单调递减栈" width="95%"/>
&lt;/div>
&lt;div class="title">图 2. 单调递减栈&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>一般会用到 &lt;code>Deque&lt;/code> 的以下四个方法：&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;code>stack.isEmpty()&lt;/code>：如果 &lt;code>deque&lt;/code> 不包含任何元素，则返回 &lt;code>true&lt;/code>，否则返回 &lt;code>false&lt;/code>。因为要栈顶元素在满足要求的时候要弹出，所以需要进行空栈判断。有些场景，可能栈一定不会空的时候，就不需要该方法进行空栈判断。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>stack.push(e)&lt;/code>：将元素 &lt;code>e&lt;/code> 入栈。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>stack.pop()&lt;/code>：将栈顶元素弹出，并返回当前弹出的栈顶元素。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>stack.peek()&lt;/code>：获取栈顶元素，不弹出。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="java">&lt;span class="c1">// 定义一个单调栈&lt;/span>
&lt;span class="nc">Deque&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nc">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">stack&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">LinkedList&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
&lt;span class="c1">// 第一个元素，直接添加&lt;/span>
&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">);&lt;/span> &lt;span class="c1">// 注意：栈内存的是数组下标&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 如果是单调递增栈，那么这里就是大于，即 nums[i] &amp;gt; nums[deque.peek()]&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">peek&lt;/span>&lt;span class="o">()])&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">peek&lt;/span>&lt;span class="o">()])&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="c1">// 此处除了入栈，在有些场景下，还有可能有其他操作&lt;/span>
 &lt;span class="c1">// ..............&lt;/span>
 &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 循环比较，直到遇到当前元素小于栈顶的元素情况，跳出循环&lt;/span>
 &lt;span class="c1">// 单调递增栈，这里是小于，即nums[i] &amp;lt; nums[deque.peek()]&lt;/span>
 &lt;span class="k">while&lt;/span> &lt;span class="o">(!&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isEmpty&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">peek&lt;/span>&lt;span class="o">()])&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">//主要逻辑&lt;/span>
 &lt;span class="c1">// ............&lt;/span>
 &lt;span class="c1">// ............&lt;/span>
 &lt;span class="c1">// 弹出栈顶元素&lt;/span>
 &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pop&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>记住这两句话：&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>单调递增栈，利用波谷剔除栈中的波峰，留下波谷；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>单调递减栈，利用波峰剔除栈中的波谷，留下波峰。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_leetcode_316_去除重复字母">LeetCode 316. 去除重复字母&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://leetcode.cn/problems/remove-duplicate-letters/" target="_blank" rel="noopener">LeetCode - 316. 去除重复字母 &lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>给你一个字符串 &lt;code>s&lt;/code>，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 &lt;strong>返回结果的字典序最小&lt;/strong>（要求不能打乱其他字符的相对位置）。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入：s = &amp;#34;bcabc&amp;#34;
输出：&amp;#34;abc&amp;#34;&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入：s = &amp;#34;cbacdcbc&amp;#34;
输出：&amp;#34;acdb&amp;#34;&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>提示：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;code>1 &amp;lt;= s.length &amp;lt;= 10&lt;sup>4&lt;/sup>&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>s&lt;/code> 由小写英文字母组成&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div></description></item><item><title>算法模式：滑动窗口</title><link>https://www.diguage.com/post/algorithm-pattern-sliding-window/</link><pubDate>Fri, 21 Mar 2025 11:49:41 +0800</pubDate><guid>https://www.diguage.com/post/algorithm-pattern-sliding-window/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/algorithm-pattern-two-pointer/" target="_blank" rel="noopener">算法模式：双指针&lt;/a> 介绍了双指针的算法模式。本篇文章，介绍一种类似双指针的算法模式：滑动窗口。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_滑动窗口">滑动窗口&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>滑动窗口类型的题目经常是用来执行数组或是链表上某个区间（窗口）上的操作。比如找最长的全为1的子数组长度。滑动窗口一般从第一个元素开始，一直往右边一个一个元素挪动。当然了，根据题目要求，我们可能有固定窗口大小的情况，也有窗口的大小变化的情况。&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/sliding-window.png" alt="滑动窗口" width="95%"/>
&lt;/div>
&lt;div class="title">图 1. 滑动窗口&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>滑动窗口大概思路如下：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="java">&lt;span class="c1">// 向前滑动窗口&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">right&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">array&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">lenght&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 扩大窗口，将元素放入窗口&lt;/span>
 &lt;span class="n">right&lt;/span>&lt;span class="o">++;&lt;/span>
 &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">缩小窗口条件&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 处理窗口内的元素&lt;/span>
 &lt;span class="c1">// 缩小窗口，将元素丢出窗口&lt;/span>
 &lt;span class="n">left&lt;/span>&lt;span class="o">++;&lt;/span>
 &lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>下面是一些我们用来判断我们可能需要上滑动窗口策略的方法：&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>问题的输入是一些线性结构：比如链表，数组，字符串之类的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>让你去求最长/最短子字符串或是某些特定的长度要求&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_leetcode_3_无重复字符的最长子串">LeetCode 3. 无重复字符的最长子串&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">LeetCode - 3. 无重复字符的最长子串 &lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>给定一个字符串 &lt;code>s&lt;/code> ，请你找出其中不含有重复字符的 &lt;strong>最长子串&lt;/strong> 的长度。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 1:&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入: s = &amp;#34;abcabcbb&amp;#34;
输出: 3
解释: 因为无重复字符的最长子串是 &amp;#34;abc&amp;#34;，所以其长度为 3。&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 2:&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入: s = &amp;#34;bbbbb&amp;#34;
输出: 1
解释: 因为无重复字符的最长子串是 &amp;#34;b&amp;#34;，所以其长度为 1。&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 3:&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入: s = &amp;#34;pwwkew&amp;#34;
输出: 3
解释: 因为无重复字符的最长子串是 &amp;#34;wke&amp;#34;，所以其长度为 3。
 请注意，你的答案必须是 子串 的长度，&amp;#34;pwke&amp;#34; 是一个子序列，不是子串。&lt;/pre>
&lt;/div></description></item><item><title>算法模式：双指针</title><link>https://www.diguage.com/post/algorithm-pattern-two-pointer/</link><pubDate>Thu, 06 Mar 2025 17:32:45 +0800</pubDate><guid>https://www.diguage.com/post/algorithm-pattern-two-pointer/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/algorithm-pattern-merge-intervals/" target="_blank" rel="noopener">算法模式：区间合并&lt;/a> 介绍了合并区间所用的算法模式。本篇文章，介绍一种即可以用在数组，又可以用在链表中的算法模式：双指针。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_双指针">双指针&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>双指针是这样的模式：两个指针朝着左右方向移动（双指针分为同向双指针和异向双指针），直到他们有一个或是两个都满足某种条件。双指针通常用在排好序的数组或是链表中寻找对子。比如，你需要去比较数组中每个元素和其他元素的关系时，你就需要用到双指针了。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>需要双指针的原因是：如果你只用一个指针的话，你得来回跑才能在数组中找到你需要的答案。这一个指针来来回回的过程就很耗时和浪费空间了 — 这是考虑算法的复杂度分析的时候的重要概念。虽然 Brute F orce 一个指针的解法可能会奏效，但时间复杂度一般会是 \$O(n^2)\$。在很多情况下，双指针能帮助我们找到空间或是时间复杂度更低的解。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>识别使用双指针的招数：&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>一般来说，数组或是链表是排好序的，你得在里头找一些组合满足某种限制条件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这种组合可能是一对数，三个数，或是一个子数组&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_leetcode_15_三数之和">LeetCode 15. 三数之和&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://leetcode.cn/problems/3sum/" target="_blank" rel="noopener">LeetCode - 15. 三数之和 &lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>给你一个整数数组 &lt;code>nums&lt;/code> ，判断是否存在三元组 &lt;code>[nums[i], nums[j], nums[k]]&lt;/code> 满足 &lt;code>i != j&lt;/code>、&lt;code>i != k&lt;/code> 且 &lt;code>j != k&lt;/code> ，同时还满足 &lt;code>nums[i] + nums[j] + nums[k] == 0&lt;/code>。请你返回所有和为 &lt;code>0&lt;/code> 且不重复的三元组。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>注意：&lt;/strong>答案中不可以包含重复的三元组。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。&lt;/pre>
&lt;/div></description></item><item><title>算法模式：快慢指针</title><link>https://www.diguage.com/post/algorithm-pattern-fast-slow-pointers/</link><pubDate>Wed, 05 Mar 2025 19:50:11 +0800</pubDate><guid>https://www.diguage.com/post/algorithm-pattern-fast-slow-pointers/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/algorithm-pattern-two-pointer/" target="_blank" rel="noopener">算法模式：双指针&lt;/a> 介绍了双指针模式。本篇文章，再介绍一种即可以用在数组，又可以用在链表中的算法模式：快慢指针。快慢指针，其实是双指针模式的一个变种。所以，两者在很多地方有相通之处。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_快慢指针">快慢指针&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>快慢指针模式，有一个非常出名的名字，叫龟兔赛跑。大家肯定都知道龟兔赛跑啦。但还是再解释一下快慢指针：这种算法的两个指针的在数组上（或是链表上，序列上）的移动速度不一样。还别说，这种方法在解决有环的链表和数组时特别有用。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>通过控制指针不同的移动速度（比如在环形链表上），这种算法证明了他们肯定会相遇的。快的一个指针肯定会追上慢的一个（可以想象成跑道上面跑得快的人套圈跑得慢的人）。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>咋知道需要用快慢指针模式勒？&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>问题需要处理环上的问题，比如环形链表和环形数组&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当你需要知道链表的长度或是某个特别位置的信息的时候&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>那啥时候用快慢指针而不是上面的双指针呢？&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>有些情形下，咱们不应该用双指针，比如我们在单链表上不能往回移动的时候。一个典型的需要用到快慢指针的模式的是当你需要去判断一个链表是否是回文的时候。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_leetcode_141_环形链表">LeetCode 141. 环形链表&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://leetcode.cn/problems/linked-list-cycle/" target="_blank" rel="noopener">LeetCode - 141. 环形链表 &lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>给你一个链表的头节点 &lt;code>head&lt;/code> ，判断链表中是否有环。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>如果链表中有某个节点，可以通过连续跟踪 &lt;code>next&lt;/code> 指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数 &lt;code>pos&lt;/code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。&lt;strong>注意：&lt;code>pos&lt;/code> 不作为参数进行传递&lt;/strong>。仅仅是为了标识链表的实际情况。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;em>如果链表中存在环&lt;/em> ，则返回 &lt;code>true&lt;/code> 。 否则，返回 &lt;code>false&lt;/code> 。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/0141-00.png" alt="0141 00" width="95%"/>
&lt;/div>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/0141-01.png" alt="0141 01" width="95%"/>
&lt;/div>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 3：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/0141-03.png" alt="0141 03" width="95%"/>
&lt;/div>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入：head = [1], pos = -1
输出：false
解释：链表中没有环。&lt;/pre>
&lt;/div></description></item><item><title>算法模式：区间合并</title><link>https://www.diguage.com/post/algorithm-pattern-merge-intervals/</link><pubDate>Wed, 05 Mar 2025 19:50:11 +0800</pubDate><guid>https://www.diguage.com/post/algorithm-pattern-merge-intervals/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/algorithm-pattern-modified-binary-search/" target="_blank" rel="noopener">算法模式：改进的二分查找&lt;/a> 介绍了二分查找以及相关变种。本篇文章，继续介绍数组相关的算法模式：区间合并。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_区间合并">区间合并&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>区间合并模式是一个用来处理有区间重叠的很高效的技术。在涉及到区间的很多问题中，通常咱们需要要么判断是否有重叠，要么合并区间，如果他们重叠的话。这个模式是这么起作用的。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>给两个区间，一个是 a，另外一个是 b。别小看就两个区间，他们之间的关系能跑出来6种情况。详细的就看图啦。&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/0056-merge-intervals.png" alt="区间关系" width="95%"/>
&lt;/div>
&lt;div class="title">图 1. 区间关系&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>观察这六种排序，明显后三种排序是前三种排序的一个“变种”：对区间根据起点和终点进行排序，就是剩下前三种排序了。再对其进行合并就很简单了：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>没有重叠，则直接开启新区间。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>有重叠，起点和终点分别取最大值和最小值即可：由于区间已经排序，则相邻两个区间的起点是前面区间的起点，重点则是两个区间终点的最大值。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_leetcode_56_合并区间">LeetCode 56. 合并区间&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://leetcode.cn/problems/merge-intervals/" target="_blank" rel="noopener">LeetCode - 56. 合并区间 &lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>以数组 &lt;code>intervals&lt;/code> 表示若干个区间的集合，其中单个区间为 &lt;code>intervals[i] = [start&lt;sub>i&lt;/sub>, end&lt;sub>i&lt;/sub>]&lt;/code>。请你合并所有重叠的区间，并返回 &lt;em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间&lt;/em> 。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>提示：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;code>1 &amp;lt;= intervals.length &amp;lt;= 10&lt;sup>4&lt;/sup>&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>intervals[i].length == 2&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>0 &amp;lt;= start&lt;sub>i&lt;/sub> &amp;lt;= end&lt;sub>i&lt;/sub> &amp;lt;= 10&lt;sup>4&lt;/sup>&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div></description></item><item><title>算法模式：改进的二分查找</title><link>https://www.diguage.com/post/algorithm-pattern-modified-binary-search/</link><pubDate>Tue, 04 Mar 2025 19:47:34 +0800</pubDate><guid>https://www.diguage.com/post/algorithm-pattern-modified-binary-search/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/algorithm-pattern-prefix-sum/" target="_blank" rel="noopener">算法模式：前缀和&lt;/a> 介绍了前缀和的算法模式。本篇文章，继续介绍数组相关的算法模式：改进的二分查找。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_二分查找">二分查找&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>二分查找相比每一个学过计算机算法的小伙伴都了解，时间复杂度是： \$\log_2N\$，是一个非常高效的数组查找算法。当然，前提是数组必须有序。过程如下：&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/binary-search.jpg" alt="二分查找" width="95%"/>
&lt;/div>
&lt;div class="title">图 1. 二分查找&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;a href="https://leetcode.cn/problems/binary-search/description/" target="_blank" rel="noopener">LeetCode 704. 二分查找&lt;/a> 就是一个标准的二分查找的算法题。代码如下：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="java">&lt;span class="cm">/**
 * @author D瓜哥 · &lt;a href="https://www.diguage.com" target="_blank">https://www.diguage.com&lt;/a>
 * @since 2024-09-14 19:52:26
 */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">search&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">target&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="kt">int&lt;/span> &lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">left&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="kt">int&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">left&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">right&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">left&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">mid&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">target&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="n">mid&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">mid&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">target&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mid&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>除了在排序数组中查找特定的值，二分查找还可以用于找边界和在旋转数组中查值。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_找边界leetcode_34_在排序数组中查找元素的第一个和最后一个位置">找边界：LeetCode 34. 在排序数组中查找元素的第一个和最后一个位置&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">LeetCode - 34. 在排序数组中查找元素的第一个和最后一个位置&lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>给你一个按照非递减顺序排列的整数数组 &lt;code>nums&lt;/code>，和一个目标值 &lt;code>target&lt;/code>。请你找出给定目标值在数组中的开始位置和结束位置。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>如果数组中不存在目标值 &lt;code>target&lt;/code>，返回 &lt;code>[-1, -1]&lt;/code>。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>你必须设计并实现时间复杂度为 \$log_2n\$ 的算法解决此问题。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 1：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 2：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>示例 3：&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="literalblock">
&lt;div class="content">
&lt;pre>输入：nums = [], target = 0
输出：[-1,-1]&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>提示：&lt;/strong>&lt;/p>
&lt;/div></description></item><item><title>算法模式：前缀和</title><link>https://www.diguage.com/post/algorithm-pattern-prefix-sum/</link><pubDate>Thu, 27 Feb 2025 19:47:34 +0800</pubDate><guid>https://www.diguage.com/post/algorithm-pattern-prefix-sum/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章 &lt;a href="https://www.diguage.com/post/algorithm-pattern-difference-array/" target="_blank" rel="noopener">算法模式：差分数组&lt;/a>，本篇文章，继续介绍数组相关的算法模式：前缀和。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_前缀和">前缀和&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>前缀和可以简单理解为「数列的前 n 项的和」。具体过程如图所示：&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/prefix-sum.svg" alt="前缀和" width="95%"/>
&lt;/div>
&lt;div class="title">图 1. 前缀和&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>这是一种重要的预处理方式，也就是需要额外的空间并且提前计算好这些值。如果使用得当，能大大降低查询的时间复杂度。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_leetcode_303_区域和检索_数组不可变">LeetCode 303. 区域和检索 - 数组不可变&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://leetcode.cn/problems/range-sum-query-immutable/" target="_blank" rel="noopener">LeetCode - 303. 区域和检索 - 数组不可变 &lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>给定一个整数数组 &lt;code>nums&lt;/code>，处理以下类型的多个查询:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>计算索引 &lt;code>left&lt;/code> 和 &lt;code>right&lt;/code> （包含 &lt;code>left&lt;/code> 和 &lt;code>right&lt;/code>）之间的
&lt;code>nums&lt;/code> 元素的 &lt;strong>和&lt;/strong> ，其中 &lt;code>left &amp;lt;= right&lt;/code>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>实现 &lt;code>NumArray&lt;/code> 类：&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;code>NumArray(int[] nums)&lt;/code> 使用数组 &lt;code>nums&lt;/code> 初始化对象&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>int sumRange(int left, int right)&lt;/code> 返回数组 &lt;code>nums&lt;/code> 中索引 &lt;code>left&lt;/code> 和 &lt;code>right&lt;/code> 之间的元素的 &lt;strong>总和&lt;/strong>，包含 &lt;code>left&lt;/code> 和 &lt;code>right&lt;/code> 两点（也就是 &lt;code>nums[left] + nums[left + 1] + …​ + nums[right]&lt;/code> )&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div></description></item><item><title>算法模式：差分数组</title><link>https://www.diguage.com/post/algorithm-pattern-difference-array/</link><pubDate>Wed, 26 Feb 2025 17:01:52 +0800</pubDate><guid>https://www.diguage.com/post/algorithm-pattern-difference-array/</guid><description>&lt;div class="paragraph">
&lt;p>Christopher Alexander 在 &lt;a href="https://book.douban.com/subject/1177968/" target="_blank" rel="noopener">《建筑的永恒之道》&lt;/a> 中说：“每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。”受此影响，GoF 总结经验，写出了著名的 &lt;a href="https://book.douban.com/subject/34262305/" target="_blank" rel="noopener">《设计模式》&lt;/a>。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>在算法中，也有很多类似设计模式这样的解决方案。D瓜哥称其为“算法模式”。后面，慢慢写文章一一介绍一下。由浅及深，今天先来介绍最简单的一个模式：差分数组。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_差分数组">差分数组&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>差分数组：差分数组就是原始数组相邻元素之间的差。举例如下：&lt;/p>
&lt;/div>
&lt;table class="tableblock frame-all grid-all stretch">
&lt;colgroup>
&lt;col style="width: 14.2857%;"/>
&lt;col style="width: 14.2857%;"/>
&lt;col style="width: 14.2857%;"/>
&lt;col style="width: 14.2857%;"/>
&lt;col style="width: 14.2857%;"/>
&lt;col style="width: 14.2857%;"/>
&lt;col style="width: 14.2858%;"/>
&lt;/colgroup>
&lt;thead>
&lt;tr>
&lt;th class="tableblock halign-left valign-top">下标&lt;/th>
&lt;th class="tableblock halign-left valign-top">0&lt;/th>
&lt;th class="tableblock halign-left valign-top">1&lt;/th>
&lt;th class="tableblock halign-left valign-top">2&lt;/th>
&lt;th class="tableblock halign-left valign-top">3&lt;/th>
&lt;th class="tableblock halign-left valign-top">4&lt;/th>
&lt;th class="tableblock halign-left valign-top">5&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td class="tableblock halign-left valign-top">&lt;p class="tableblock">原始数组&lt;/p>&lt;/td>
&lt;td class="tableblock halign-left valign-top">&lt;p class="tableblock">5&lt;/p>&lt;/td>
&lt;td class="tableblock halign-left valign-top">&lt;p class="tableblock">9&lt;/p>&lt;/td>
&lt;td class="tableblock halign-left valign-top">&lt;p class="tableblock">2&lt;/p>&lt;/td>
&lt;td class="tableblock halign-left valign-top">&lt;p class="tableblock">6&lt;/p>&lt;/td>
&lt;td class="tableblock halign-left valign-top">&lt;p class="tableblock">5&lt;/p>&lt;/td>
&lt;td class="tableblock halign-left valign-top">&lt;p class="tableblock">3&lt;/p>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td class="tableblock halign-left valign-top">&lt;p class="tableblock">差分数组&lt;/p>&lt;/td>
&lt;td class="tableblock halign-left valign-top">&lt;p class="tableblock">5&lt;/p>&lt;/td>
&lt;td class="tableblock halign-left valign-top">&lt;p class="tableblock">4&lt;/p>&lt;/td>
&lt;td class="tableblock halign-left valign-top">&lt;p class="tableblock">-7&lt;/p>&lt;/td>
&lt;td class="tableblock halign-left valign-top">&lt;p class="tableblock">4&lt;/p>&lt;/td>
&lt;td class="tableblock halign-left valign-top">&lt;p class="tableblock">-1&lt;/p>&lt;/td>
&lt;td class="tableblock halign-left valign-top">&lt;p class="tableblock">-2&lt;/p>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;div class="paragraph">
&lt;p>差分数组是从原始数组构造出来的一个辅助数组，表示相邻元素直接的差值。可用于解决需要对数组一个区间内同时做加减的操作。比如：随着公交站各个站台上下车，判断公交车是否超载。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_leetcode_370_区间加法">LeetCode 370. 区间加法&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://leetcode.cn/problems/range-addition/" target="_blank" rel="noopener">LeetCode - 370. 区间加法 &lt;/a>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>假设你有一个长度为 &lt;code>n&lt;/code> 的数组，初始情况下所有的数字均为 &lt;code>0&lt;/code>，你将会被给出 &lt;code>k&lt;/code> 个更新的操作。&lt;/p>
&lt;/div></description></item><item><title>单调栈实践（二）：应用</title><link>https://www.diguage.com/post/monotonic-stack-in-practice-2/</link><pubDate>Fri, 02 Aug 2024 22:57:10 +0800</pubDate><guid>https://www.diguage.com/post/monotonic-stack-in-practice-2/</guid><description>&lt;div class="paragraph">
&lt;p>在 &lt;a href="https://www.diguage.com/post/monotonic-stack-in-practice-1/" target="_blank" rel="noopener">单调栈实践（一）：入门&lt;/a> 中对单调栈做了一个初步介绍，同时使用一个类似单调栈的题目做了入门的尝试。在本文中，将分析正式单调栈的使用案例。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_实践_leetcode_503_下一个更大元素_ii">实践： LeetCode 503. 下一个更大元素 II&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>单调栈主要就是为了解决选择下一个更大或者更小元素的相关问题。来看一下 &lt;a href="https://leetcode.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">LeetCode 503. 下一个更大元素 II&lt;/a>。&lt;/p>
&lt;/div>
&lt;div class="quoteblock">
&lt;blockquote>
&lt;div class="paragraph">
&lt;p>给定一个循环数组 &lt;code>nums&lt;/code> （ &lt;code>nums[nums.length - 1]&lt;/code> 的下一个元素是 &lt;code>nums[0]&lt;/code> ），返回 &lt;code>nums&lt;/code> 中每个元素的下一个更大元素。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>数字 &lt;code>x&lt;/code> 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 &lt;code>-1&lt;/code> 。&lt;/p>
&lt;/div>
&lt;/blockquote>
&lt;/div>
&lt;div class="paragraph">
&lt;p>如果熟悉单调栈，这道题的解法就一目了然：&lt;strong>将数组从后向前遍历，如果单调栈栈顶元素比当前元素小，就将栈顶元素弹出；重复上述操作，直到栈顶元素大于当前元素，或者栈为空。如果栈不为空，则栈顶元素就是当前元素的后继更大元素。&lt;/strong>代码如下：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="java">&lt;span class="cm">/**
 * LeetCode 503. 下一个更大元素 II
 *
 * @author D瓜哥 · &lt;a href="https://www.diguage.com" target="_blank">https://www.diguage.com&lt;/a>
 * @since 2024-07-05 23:08:39
 */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="nf">nextGreaterElements&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">nums&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">];&lt;/span>
 &lt;span class="nc">Deque&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nc">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">stack&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">LinkedList&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
 &lt;span class="c1">// 只需要将数组“拼接”，遍历两遍数组，就可以解决所有元素后继更大元素的问题&lt;/span>
 &lt;span class="c1">// 从后向前遍历，再加上单调递增栈，就是时间复杂度为 O(n) 的解决方案&lt;/span>
 &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">--)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 取余即可获取当前需要处理的元素&lt;/span>
 &lt;span class="kt">int&lt;/span> &lt;span class="n">index&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="c1">// 在单调栈不为空的情况下，将栈中小于等于当前元素的值都弹出&lt;/span>
 &lt;span class="k">while&lt;/span> &lt;span class="o">(!&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isEmpty&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">peek&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="o">])&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pop&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="c1">// 剩下元素既是比当前元素大的后继元素。为空则是没有更大元素&lt;/span>
 &lt;span class="c1">// 这里还有一个隐含变量：&lt;/span>
 &lt;span class="c1">// 由于栈是从后向前添加，则栈顶元素距离当前元素更近。&lt;/span>
 &lt;span class="c1">// 如果栈不为空，则栈顶元素就是符合条件的元素。&lt;/span>
 &lt;span class="n">result&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isEmpty&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">peek&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="o">]);&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="admonitionblock tip">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;i class="fa icon-tip" title="Tip">&lt;/i>
&lt;/td>
&lt;td class="content">
使用单调栈，一个关键点是确定使用的是单调递增栈，还是单调递减栈。
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre>这里给大家留一个思考题：本文提供的答案是从后向前遍历数组。尝试一下从前向后遍历数组的解决方案。&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_实践_leetcode_42_接雨水">实践： LeetCode 42. 接雨水&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>下面再来看一下： &lt;a href="https://leetcode.com/problems/trapping-rain-water/description/" target="_blank" rel="noopener">LeetCode 42. 接雨水&lt;/a>。&lt;/p>
&lt;/div>
&lt;div class="quoteblock">
&lt;blockquote>
&lt;div class="paragraph">
&lt;p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p>
&lt;/div></description></item><item><title>单调栈实践（一）：入门</title><link>https://www.diguage.com/post/monotonic-stack-in-practice-1/</link><pubDate>Thu, 01 Aug 2024 11:32:47 +0800</pubDate><guid>https://www.diguage.com/post/monotonic-stack-in-practice-1/</guid><description>&lt;div class="paragraph">
&lt;p>最近刷 LeetCode 算法题中，遇到了一些需要单调栈的题目，就顺便学习了一下单调栈。分享出来，以备后续深入学习。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>学习单调栈之前，先了解一些栈。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_栈_stack">栈 Stack&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>栈是一个众所周知的线性数据结构，它遵循先入后出（First In Last Out，简称 FILO）或后入先出（Last In First Out，简称 LIFO）的访问顺序。操作示意图如下：&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/stack.gif" alt="入栈与出栈" width="95%"/>
&lt;/div>
&lt;div class="title">图 1. 入栈与出栈&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_单调栈_monotonic_stack">单调栈 Monotonic Stack&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>单调栈是一种特殊的栈，添加了一些限制条件：内部元素只能是递增或递减的顺序存储；添加元素时，如果新元素不符合单调性，则将其内部元素弹出，直到符合添加时，才添加元素。根据元素顺序，又可分为单调递增栈和单调递减栈。操作示意图如下：&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/monotonically-increasing-stack.svg" alt="单调递增栈" width="95%"/>
&lt;/div>
&lt;div class="title">图 2. 单调递增栈&lt;/div>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/monotonically-decreasing-stack.svg" alt="单调递减栈" width="95%"/>
&lt;/div>
&lt;div class="title">图 3. 单调递减栈&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="monotonic-stack-pseudocode">代码示例&lt;/h3>
&lt;div class="paragraph">
&lt;p>在写代码时，一般基于 &lt;code>Deque&lt;/code> 来实现，通常用到以下四个方法：&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;code>deque.isEmpty()&lt;/code>：如果 &lt;code>deque&lt;/code> 不包含任何元素，则返回 &lt;code>true&lt;/code>，否则返回 &lt;code>false&lt;/code>。因为要栈顶元素在满足要求的时候要弹出，所以需要进行空栈判断。有些场景，可能栈一定不会空的时候，就不需要该方法进行空栈判断。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>deque.push(e)&lt;/code>：将元素 &lt;code>e&lt;/code> 入栈。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>deque.pop()&lt;/code>：将栈顶元素弹出，并返回当前弹出的栈顶元素。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>deque.peek()&lt;/code>：获取栈顶元素，不弹出。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="java">&lt;span class="c1">// 定义一个单调栈&lt;/span>
&lt;span class="nc">Deque&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="nc">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">stack&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">LinkedList&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
&lt;span class="c1">// 第一个元素，直接添加&lt;/span>
&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">);&lt;/span> &lt;span class="c1">// 这里存的是数组下标&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 单调递增栈这里就是大于，即 nums[i] &amp;gt; nums[deque.peek()]&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">peek&lt;/span>&lt;span class="o">()])&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">peek&lt;/span>&lt;span class="o">()])&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="c1">// 此处除了入栈，在有些场景下，还有可能有其他操作&lt;/span>
 &lt;span class="c1">// ..............&lt;/span>
 &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 循环比较，直到遇到当前元素小于栈顶的元素情况，跳出循环&lt;/span>
 &lt;span class="c1">// 单调递增栈，这里是小于，即nums[i] &amp;lt; nums[deque.peek()]&lt;/span>
 &lt;span class="k">while&lt;/span> &lt;span class="o">(!&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isEmpty&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">peek&lt;/span>&lt;span class="o">()])&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">//主要逻辑&lt;/span>
 &lt;span class="c1">// ............&lt;/span>
 &lt;span class="c1">// ............&lt;/span>
 &lt;span class="c1">// 弹出栈顶元素&lt;/span>
 &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">pop&lt;/span>&lt;span class="o">();&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="n">stack&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">push&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_应用_leetcode_155_最小栈">应用： LeetCode 155. 最小栈&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>来看一个 LeetCode 算法提： &lt;a href="https://leetcode.com/problems/min-stack/description/" target="_blank" rel="noopener">LeetCode 155. 最小栈&lt;/a>，D瓜哥愿意称之为单调栈入门最佳试题。&lt;/p>
&lt;/div></description></item><item><title>细说编码与字符集</title><link>https://www.diguage.com/post/dive-into-encoding-and-character-set/</link><pubDate>Sat, 29 Oct 2022 09:09:12 +0800</pubDate><guid>https://www.diguage.com/post/dive-into-encoding-and-character-set/</guid><description>&lt;div class="paragraph">
&lt;p>&lt;strong>文章还没写完，提前放出防止出现 404。稍后慢慢更新，敬请期待： &lt;a href="https://www.diguage.com/post/dive-into-encoding-and-character-set/" target="_blank" rel="noopener">细说编码与字符集 - &amp;#34;地瓜哥&amp;#34;博客网&lt;/a>&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>文章还没写完，提前放出防止出现 404。稍后慢慢更新，敬请期待： &lt;a href="https://www.diguage.com/post/dive-into-encoding-and-character-set/" target="_blank" rel="noopener">细说编码与字符集 - &amp;#34;地瓜哥&amp;#34;博客网&lt;/a>&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;strong>文章还没写完，提前放出防止出现 404。稍后慢慢更新，敬请期待： &lt;a href="https://www.diguage.com/post/dive-into-encoding-and-character-set/" target="_blank" rel="noopener">细说编码与字符集 - &amp;#34;地瓜哥&amp;#34;博客网&lt;/a>&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>前段时间要研究 Hessian 编码格式，为了搞清楚 Hessian 对字符串的编码，就顺路查了好多编码和字符集的工作，理清了很多以前模糊的知识点。下面整理一下笔记，也梳理一下自己的思路和理解。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_ascii_码">ASCII 码&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>计算机起源于美国，他们对英语字符与二进制位之间的对应关系做了统一规定，并制定了一套字符编码规则，这套编码规则被称为 American Standard Code for Information Interchange，简称为 ASCII 编码&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>其实，ASCII 最早起源于电报码。最早的商业应用是贝尔公司的七位电传打字机。后来于 1963 年发布了该标准的第一版。在网络交换中使用的 ASCII 格式是在 1969 年发布的，该格式在 2015 年发展成为互联网标准。点击 &lt;a href="https://www.rfc-editor.org/rfc/rfc20.pdf" target="_blank" rel="noopener">RFC 20: ASCII format for network interchange&lt;/a>，感受一下 1969 年的古香古色。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>ASCII 编码一共定义了128个字符的编码规则，用七位二进制表示（&lt;code>0x00&lt;/code> - &lt;code>0x7F&lt;/code>）, 这些字符组成的集合就叫做 ASCII 字符集。完整列表如下：&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/encoding/ascii-table.svg" alt="ASCII Table" width="95%"/>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>ASCII 码可以说是现在所有编码的鼻祖。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_编码乱战及_unicode_应运而生">编码乱战及 Unicode 应运而生&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>ASCII 编码是为专门英语指定的编码标准，但是却不能编码英语外来词。比如 &lt;code>résumé&lt;/code>，其中 &lt;code>é&lt;/code> 就不在 ASCII 编码范围内。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>随着计算机的发展，各个国家或地区，甚至不同公司都推出了不同的编码标准，比如中国推出了 GB2312、GBK 以及 GB18030；微软推出了 Windows character sets 。&lt;/p>
&lt;/div></description></item><item><title>Raft 论文摘要（二）</title><link>https://www.diguage.com/post/summary-of-the-raft-paper-2/</link><pubDate>Mon, 05 Jul 2021 19:58:32 +0800</pubDate><guid>https://www.diguage.com/post/summary-of-the-raft-paper-2/</guid><description>&lt;div class="paragraph">
&lt;p>在上一篇文章中，通过阅读 &lt;a href="https://raft.github.io/raft.pdf">《In Search of an Understandable Consensus Algorithm》&lt;/a> 前三节的内容，对论文的大致内容做了简介，简单说明了一下 Replicated state machines 的用途以及 Paxos 本身存在的问题。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_4_designing_for_understandability">4. Designing for understandability&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="quoteblock">
&lt;blockquote>
&lt;div class="paragraph">
&lt;p>several goals in designing Raft:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>it must providea complete and practical foundation for system building;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>it must be safe under all conditions and available under typical operating conditions;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>it must be efficient for common operations.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Our most important goal — and most difficult challenge — was &lt;strong>understandability&lt;/strong>.&lt;/p>
&lt;/div>
&lt;/blockquote>
&lt;/div>
&lt;div class="paragraph">
&lt;p>从这里可以看出，Raft 设计的初衷就是为了易于理解和便于构建。&lt;/p>
&lt;/div>
&lt;div class="quoteblock">
&lt;blockquote>
There were numerous points in the design of Raft where we had to choose among alternative approaches. In these situations we evaluated the alternatives based on understandability.
&lt;/blockquote>
&lt;/div></description></item><item><title>Raft 论文摘要（一）</title><link>https://www.diguage.com/post/summary-of-the-raft-paper-1/</link><pubDate>Fri, 02 Jul 2021 11:42:26 +0800</pubDate><guid>https://www.diguage.com/post/summary-of-the-raft-paper-1/</guid><description>&lt;div class="paragraph">
&lt;p>前一段时间，在一次开组会的时候，给小组成员简单介绍了一下 Raft 协议。大概四年前读过 Raft 的论文，这次分享的时候，好多好多细节都忘了。所以，再次把 &lt;a href="https://raft.github.io/raft.pdf">《In Search of an Understandable Consensus Algorithm》&lt;/a> 这篇论文找出来，重读一遍，做个笔记和摘要，方便后续学习和复习。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_abstract">Abstract&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="quoteblock">
&lt;blockquote>
Raft is a consensus algorithm for managing a replicated log.
&lt;/blockquote>
&lt;/div>
&lt;div class="paragraph">
&lt;p>开篇摘要就点出了 Raft 的特点： Raft 是一种管理复制日志的共识算法。&lt;/p>
&lt;/div>
&lt;div class="quoteblock">
&lt;blockquote>
In order to enhance understandability, Raft separates the key elements of consensus, such as leader election, log replication, and safety, and it enforcesa stronger degree of coherency to reduce the number of states that must be considered.
&lt;/blockquote>
&lt;/div>
&lt;div class="paragraph">
&lt;p>为了增强可理解性，Raft 将共识分解成几个关键元素，例如 Leader 选举，日志复制，以及安全性等；同时，为了降低需要考虑的状态的数量，还强制实施了更强的一致性。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_1_introduction">1. Introduction&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="quoteblock">
&lt;blockquote>
Consensus algorithms allow a collection of machines to work as a coherent group that can survive the failures of some of its members.
&lt;/blockquote>
&lt;/div></description></item><item><title>神奇的 Morris 树遍历</title><link>https://www.diguage.com/post/morris-tree-traversal/</link><pubDate>Fri, 14 Aug 2020 18:27:03 +0800</pubDate><guid>https://www.diguage.com/post/morris-tree-traversal/</guid><description>&lt;div class="paragraph">
&lt;p>无论是在计算机课上，还是在网上，对数据结构有一定了解的童鞋，应该都对树的遍历不陌生。常见的遍历方式有如下两种：&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>基于栈的遍历：需要额外的空间复杂度。实现略复杂。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>基于递归的遍历：实现简单。空间复杂度上，与栈类似，只是这里的栈维护是由系统自动完成的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>在看左程云的《程序员代码面试指南》时，里面介绍了一种只需 O(1) 的额外空间复杂度的遍历方法：Morris 树遍历。感觉非常神奇。这里给大家介绍一下。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Morris 树遍历的神奇之处在于，它充分利用了树里面大量的空闲节点（比如叶子节点的左右子树节点就为空，可以利用起来）来建立起必要的连接，推动遍历的进行。核心思想非常简单：找出当前节点左子树的最右节点，此时最右节点的右子树为空，将最右节点的右子树指向当前节点。然后左移，递归完成所有相关连接。没有左子树时，则向右移动，依次完成上述操作。我们来结合图来说明。如图：&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/data-structure/morris-tree-traversal.svg" alt="Morris 树遍历" width="95%"/>
&lt;/div>
&lt;div class="title">图 1. Morris 树遍历&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>如上图所示，当访问根节点 &lt;code>4&lt;/code> 时，它的左子树的最右节点就是 &lt;code>3&lt;/code>，将 &lt;code>3&lt;/code> 的右子树指向当前节点 &lt;code>4&lt;/code>，如线条 &lt;code>⑥&lt;/code> 所示。向左启动，建立起 &lt;code>1&lt;/code> 到 &lt;code>2&lt;/code> 的连接 &lt;code>④&lt;/code>。再向左移动到 &lt;code>1&lt;/code>，&lt;code>1&lt;/code> 没有左子树，则向右移动，此时就利用上了刚刚建立起的连接 &lt;code>④&lt;/code>。依次类推，即可完成遍历。在遍历过程中，也需要把建立的临时连接给取消掉。&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="java">&lt;span class="cm">/**
 * Morris 树遍历
 *
 * @author D瓜哥 · &lt;a href="https://www.diguage.com" target="_blank">https://www.diguage.com&lt;/a>
 */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">morris&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">TreeNode&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">TreeNode&lt;/span> &lt;span class="n">curr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="nc">TreeNode&lt;/span> &lt;span class="n">mostRight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">curr&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 当前节点左子树的最右节点，当然是从左子树开始了&lt;/span>
 &lt;span class="n">mostRight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">curr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">mostRight&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 左子树不为空，则找出左子树的最右节点&lt;/span>
 &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">mostRight&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>
 &lt;span class="c1">// 由于需要建立最右节点到当前节点的连接，&lt;/span>
 &lt;span class="c1">// 所以，需要判断是否已建立连接来打破死循环&lt;/span>
 &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">mostRight&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">curr&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">mostRight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mostRight&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">mostRight&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 最右节点的右子树为空，则第一次访问，那么建立起连接&lt;/span>
 &lt;span class="n">mostRight&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">curr&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="n">curr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">curr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="k">continue&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 最右节点的右子树不为空，则第二次访问，打破连接，恢复原貌&lt;/span>
 &lt;span class="n">mostRight&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="c1">// 左子树为空，则向右移动&lt;/span>
 &lt;span class="n">curr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">curr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>根据代码，结合图示，很容易得到 Morris 遍历的结果： &lt;code>4&lt;/code>、&lt;code>2&lt;/code>、&lt;code>1&lt;/code>、&lt;code>2&lt;sub>2&lt;/sub>&lt;/code>、&lt;code>3&lt;/code>、&lt;code>4&lt;sub>2&lt;/sub>&lt;/code>、&lt;code>6&lt;/code>、&lt;code>5&lt;/code>、&lt;code>6&lt;sub>2&lt;/sub>&lt;/code>、&lt;code>7&lt;/code>。分析这个结果可以发现：&lt;strong>有左子树的节点都会被访问两次。&lt;/strong>&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_前根遍历">前根遍历&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>那么该树的前根遍历是什么呢？这个也很容易得出：&lt;code>4&lt;/code>、&lt;code>2&lt;/code>、&lt;code>1&lt;/code>、&lt;code>3&lt;/code>、&lt;code>6&lt;/code>、&lt;code>5&lt;/code>、&lt;code>7&lt;/code>。如何从 Morris 遍历中，得到前根遍历的结果呢？对比两边的结果，可以很容易发现：将访问两次的元素，只在第一次访问时输出；只访问一次的原始直接输出即可。代码如下：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="java">&lt;span class="cm">/**
 * Morris 树前根遍历
 *
 * @author D瓜哥 · &lt;a href="https://www.diguage.com" target="_blank">https://www.diguage.com&lt;/a>
 */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">morrisPre&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">TreeNode&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">TreeNode&lt;/span> &lt;span class="n">curr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="nc">TreeNode&lt;/span> &lt;span class="n">mostRight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">curr&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 当前节点左子树的最右节点，当然是从左子树开始了&lt;/span>
 &lt;span class="n">mostRight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">curr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">mostRight&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 左子树不为空，则找出左子树的最右节点&lt;/span>
 &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">mostRight&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>
 &lt;span class="c1">// 由于需要建立最右节点到当前节点的连接，&lt;/span>
 &lt;span class="c1">// 所以，需要判断是否已建立连接来打破死循环&lt;/span>
 &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">mostRight&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">curr&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">mostRight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mostRight&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">mostRight&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 最右节点的右子树为空，则第一次访问，那么建立起连接&lt;/span>
 &lt;span class="n">mostRight&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">curr&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="c1">// 第一次访问时，即输出&lt;/span>
 &lt;span class="nc">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">print&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">curr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">val&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34; &amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="n">curr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">curr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="k">continue&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 最右节点的右子树不为空，则第二次访问，打破连接，恢复原貌&lt;/span>
 &lt;span class="n">mostRight&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 前面内容已经分析过：有左子树的节点就会被访问两次&lt;/span>
 &lt;span class="c1">// 那么没有左子树的节点，就自会访问一次，访问到时直接输出即可。&lt;/span>
 &lt;span class="nc">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">print&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">curr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">val&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="s">&amp;#34; &amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="c1">// 左子树为空，则向右移动&lt;/span>
 &lt;span class="n">curr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">curr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div></description></item><item><title>TCP 三次握手和四次挥手</title><link>https://www.diguage.com/post/tcp-3-way-handshake-and-4-way-handshake/</link><pubDate>Mon, 03 Aug 2020 00:57:26 +0800</pubDate><guid>https://www.diguage.com/post/tcp-3-way-handshake-and-4-way-handshake/</guid><description>&lt;div class="paragraph">
&lt;p>传输控制协议（英语：Transmission Control Protocol，缩写：TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。在简化的计算机网络 OSI 模型中，它完成第四层传输层所指定的功能。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>毫不夸张地说，TCP 协议是目前整个互联网的基础。它解决了一系列的网络问题。带来的结果，就是协议本身非常复杂。考虑到文章篇幅问题，本文着重说明 TCP 建立连接时的三次握手过程和关闭连接时的四次挥手过程。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_三次握手">三次握手&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/tcp/tcp-connection-made-three-way-handshake.png" alt="TCP 三次握手" width="95%"/>
&lt;/div>
&lt;div class="title">图 1. TCP 三次握手&lt;/div>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>第一次握手(&lt;code>SYN=1&lt;/code>, &lt;code>seq=x&lt;/code>):&lt;/p>
&lt;div class="paragraph">
&lt;p>客户端发送一个 TCP 的 &lt;code>SYN&lt;/code> 标志位置 &lt;code>1&lt;/code> 的包，指明客户端打算连接的服务器的端口，以及初始序号 &lt;code>x&lt;/code>，保存在包头的序列号(&lt;code>Sequence Number&lt;/code>)字段里。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>发送完毕后，客户端进入 &lt;code>SYN_SEND&lt;/code> 状态。&lt;/p>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>第二次握手(&lt;code>SYN=1&lt;/code>、&lt;code>seq=y&lt;/code>；&lt;code>ACK=1&lt;/code>、&lt;code>ACKnum=x+1&lt;/code>):&lt;/p>
&lt;div class="paragraph">
&lt;p>服务器发回确认包(&lt;code>ACK&lt;/code>)应答。即 &lt;code>SYN&lt;/code> 标志位和 &lt;code>ACK&lt;/code> 标志位均为 &lt;code>1&lt;/code>。服务器端选择自己 &lt;code>ISN&lt;/code> 序列号，放到包头的序列号(&lt;code>Sequence Number&lt;/code>)字段里，同时将确认序号(&lt;code>Acknowledgement Number&lt;/code>)设置为客户的 &lt;code>ISN&lt;/code> 加 &lt;code>1&lt;/code>，即 &lt;code>x+1&lt;/code>。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>发送完毕后，服务器端进入 &lt;code>SYN_RCVD&lt;/code> 状态。&lt;/p>
&lt;/div>
&lt;/li>
&lt;li>
&lt;p>第三次握手(&lt;code>ACK=1&lt;/code>，&lt;code>ACKnum=y+1&lt;/code>)&lt;/p>
&lt;div class="paragraph">
&lt;p>客户端再次发送确认包(&lt;code>ACK&lt;/code>)，SYN 标志位为 &lt;code>0&lt;/code>，&lt;code>ACK&lt;/code> 标志位为 &lt;code>1&lt;/code>，并且把服务器发来 &lt;code>ISN&lt;/code> 的序号字段+1，放在确定字段中发送给对方，即数据段放写 &lt;code>y+1&lt;/code>。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>发送完毕后，客户端进入 &lt;code>ESTABLISHED&lt;/code> 状态，当服务器端接收到这个包时，也进入 &lt;code>ESTABLISHED&lt;/code> 状态，TCP 握手结束。&lt;/p>
&lt;/div>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_syn_flood_攻击">SYN Flood 攻击&lt;/h3>
&lt;div class="paragraph">
&lt;p>在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 &lt;code>SYN_RCVD&lt;/code> 状态。当收到 ACK 后，服务器才能转入 &lt;code>ESTABLISHED&lt;/code> 状态.&lt;/p>
&lt;/div></description></item><item><title>题解：538.把二叉搜索树转换为累加树</title><link>https://www.diguage.com/post/convert-bst-to-greater-tree/</link><pubDate>Fri, 03 Jul 2020 14:56:24 +0800</pubDate><guid>https://www.diguage.com/post/convert-bst-to-greater-tree/</guid><description>&lt;div class="sect1">
&lt;h2 id="_题目描述">题目描述&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>题目是 LeetCode 的第 538 题： &lt;a href="https://leetcode.com/problems/convert-bst-to-greater-tree/description/" target="_blank" rel="noopener">把二叉搜索树转换为累加树&lt;/a>。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>给出二叉搜索树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 &lt;code>node&lt;/code> 的新值等于原树中大于或等于 &lt;code>node.val&lt;/code> 的值之和。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>提醒一下，二叉搜索树满足下列约束条件：&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>节点的左子树仅包含键 小于 节点键的节点。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>节点的右子树仅包含键 大于 节点键的节点。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>左右子树也必须是二叉搜索树。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_思路分析">思路分析&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>一棵二叉搜索树，如果是中根遍历，那么，其序列正好是一个升序序列。但，题目要求的是大于等于自身的节点值之和。正常的中根遍历是“左中右”，反过来“右中左”，就是降序序列，累计求和就符合题目要求了。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_解题代码">解题代码&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>中序遍历，可以用栈，也可以使用 Morris 遍历。在 &lt;a href="https://www.diguage.com/post/find-two-error-node-in-binary-search-tree/" target="_blank" rel="noopener">题解：找到二叉搜索树中两个错误的节点&lt;/a> 中就是用了 Morris 遍历。网上也很少有反向的 Morris 中根遍历。正好练习一下。&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="java">&lt;span class="cm">/**
 * 基于 Morris 的倒序中根遍历
 *
 * @author D瓜哥 · &lt;a href="https://www.diguage.com" target="_blank">https://www.diguage.com&lt;/a>
 */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="nc">TreeNode&lt;/span> &lt;span class="nf">convertBST&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">TreeNode&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="kt">int&lt;/span> &lt;span class="n">sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="c1">// 反向 Morris&lt;/span>
 &lt;span class="nc">TreeNode&lt;/span> &lt;span class="n">cur&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="nc">TreeNode&lt;/span> &lt;span class="n">mostLeft&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">cur&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 向右转&lt;/span>
 &lt;span class="n">mostLeft&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cur&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">mostLeft&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 寻找最左边的节点&lt;/span>
 &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">mostLeft&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">mostLeft&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">cur&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">mostLeft&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mostLeft&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">mostLeft&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 第一次访问，将最左节点的左子树指向当前节点&lt;/span>
 &lt;span class="n">mostLeft&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cur&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="n">cur&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cur&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="k">continue&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="c1">// 第二次访问，掐断中间建立的连接&lt;/span>
 &lt;span class="n">mostLeft&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="c1">// 计算累加和&lt;/span>
 &lt;span class="n">sum&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">cur&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">val&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="n">cur&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">val&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="n">cur&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cur&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>得益于 Morris 的优秀本质，这个解法的时间复杂度是： O(n)，空间复杂度是： O(1)。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>关于 Morris 树遍历的更多介绍，请看： &lt;a href="https://www.diguage.com/post/morris-tree-traversal/" target="_blank" rel="noopener">神奇的 Morris 树遍历&lt;/a>。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>Redis 核心数据结构（二）</title><link>https://www.diguage.com/post/redis-core-data-structure-2/</link><pubDate>Fri, 03 Jul 2020 00:39:43 +0800</pubDate><guid>https://www.diguage.com/post/redis-core-data-structure-2/</guid><description>&lt;div class="sidebarblock">
&lt;div class="content">
&lt;div class="paragraph">
&lt;p>本文内容对于 Redis 7+ 来说已经过时，最新实现请看下面两篇文章：&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/redis-core-data-structure-3/">Redis 核心数据结构（3）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/redis-core-data-structure-4/">Redis 核心数据结构（4）&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>在上一篇文章： &lt;a href="https://www.diguage.com/post/redis-core-data-structure-1/">Redis 核心数据结构（1）&lt;/a> 中，介绍了链表、ziplist、quicklist 数据结构。这篇文章，来介绍一下 skiplist、dict。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="skiplist">skiplist&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>跳跃表是一种有序数据结构，支持平均 O(logN)、最坏 O(N) 复杂度的节点查找；大部分情况效率可以和平衡树相媲美，实现却比平衡树简单。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>跳跃表就是 Redis 中有序集合键的底层实现之一。&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="title">server.h&lt;/div>
&lt;div class="content">
&lt;pre class="rouge highlight">&lt;code data-lang="c">&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">zskiplistNode&lt;/span> &lt;span class="p">{&lt;/span>
 &lt;span class="n">sds&lt;/span> &lt;span class="n">ele&lt;/span>&lt;span class="p">;&lt;/span>
 &lt;span class="kt">double&lt;/span> &lt;span class="n">score&lt;/span>&lt;span class="p">;&lt;/span>
 &lt;span class="k">struct&lt;/span> &lt;span class="n">zskiplistNode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">backward&lt;/span>&lt;span class="p">;&lt;/span>
 &lt;span class="k">struct&lt;/span> &lt;span class="n">zskiplistLevel&lt;/span> &lt;span class="p">{&lt;/span>
 &lt;span class="k">struct&lt;/span> &lt;span class="n">zskiplistNode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">forward&lt;/span>&lt;span class="p">;&lt;/span>
 &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">span&lt;/span>&lt;span class="p">;&lt;/span>
 &lt;span class="p">}&lt;/span> &lt;span class="n">level&lt;/span>&lt;span class="p">[];&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">zskiplistNode&lt;/span>&lt;span class="p">;&lt;/span>

&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">zskiplist&lt;/span> &lt;span class="p">{&lt;/span>
 &lt;span class="k">struct&lt;/span> &lt;span class="n">zskiplistNode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">header&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">tail&lt;/span>&lt;span class="p">;&lt;/span>
 &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">length&lt;/span>&lt;span class="p">;&lt;/span>
 &lt;span class="kt">int&lt;/span> &lt;span class="n">level&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">zskiplist&lt;/span>&lt;span class="p">;&lt;/span>

&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">zset&lt;/span> &lt;span class="p">{&lt;/span>
 &lt;span class="n">dict&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">dict&lt;/span>&lt;span class="p">;&lt;/span>
 &lt;span class="n">zskiplist&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">zsl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">zset&lt;/span>&lt;span class="p">;&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>skiplist，顾名思义，首先它是一个list。实际上，它是在有序链表的基础上发展起来的。&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/redis/skiplist.png" alt="skiplist" width="95%"/>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>当我们想查找数据的时候，可以先沿着跨度大的链进行查找。当碰到比待查数据大的节点时，再回到跨度小的链表中进行查找。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>skiplist正是受这种多层链表的想法的启发而设计出来的。按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到 O(logN)。但是，存在的一个问题是：如果插入新节点后就会打乱上下相邻两层节点是 2:1 的对应关系。如果要维持，则需要调整后面所有的节点。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>skiplist为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)。&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/redis/redis-skiplist-insertions.png" alt="redis skiplist insertions" width="95%"/>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>插入操作只需要修改插入节点前后的指针，而不需要对很多节点都进行调整。这就降低了插入操作的复杂度。实际上，这是 skiplist 的一个很重要的特性，这让它在插入性能上明显优于平衡树的方案。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>skiplist，翻译成中文，可以翻译成“跳表”或“跳跃表”，指的就是除了最下面第1层链表之外，它会产生若干层稀疏的链表，这些链表里面的指针故意跳过了一些节点（而且越高层的链表跳过的节点越多）。这就使得我们在查找数据的时候能够先在高层的链表中进行查找，然后逐层降低，最终降到第1层链表来精确地确定数据位置。在这个过程中，我们跳过了一些节点，从而也就加快了查找速度。&lt;/p>
&lt;/div>
&lt;div class="sidebarblock">
&lt;div class="content">
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>在中间插入一个有比较高 Level 的节点，如何维护前面节点到这个节点的这些链接？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在平衡树种，如何做范围查找？先确定边界，然后其他节点怎么查找？&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/redis/redis_skiplist_example.png" alt="redis skiplist example" width="95%"/>
&lt;/div>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>skiplist 中 key 允许重复。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在比较时，不仅比较分数（即key），还要比较数据自身。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第一层链表是双向链表，并且反向指针只有一个。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 skiplist 中可以很方便计算每个元素的排名。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Redis 中的有序集合（sorted set），是在 skiplist, dict 和 ziplist 基础上构建起来的:&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>当数据较少时，sorted set是由一个 ziplist 来实现的。其中集合元素按照分值从小到大排序。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当数据多的时候，sorted set 是由一个叫 zset 的数据结构来实现的，这个 zset 包含一个 dict + 一个 skiplist。dict 用来查询数据到分数(score)的对应关系，而 skiplist 用来根据分数查询数据（可能是范围查找）。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Redis 核心数据结构（一）</title><link>https://www.diguage.com/post/redis-core-data-structure-1/</link><pubDate>Thu, 02 Jul 2020 10:13:16 +0800</pubDate><guid>https://www.diguage.com/post/redis-core-data-structure-1/</guid><description>&lt;div class="sidebarblock">
&lt;div class="content">
&lt;div class="paragraph">
&lt;p>本文内容对于 Redis 7+ 来说已经过时，最新实现请看下面两篇文章：&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/redis-core-data-structure-3/">Redis 核心数据结构（3）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.diguage.com/post/redis-core-data-structure-4/">Redis 核心数据结构（4）&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Redis 目前是使用最广泛的缓存中间件。其突出特点就是支持多种常见的数据结构。对比 JDK 集合类的实现，Redis 的实现表现出很多独到之处，很多地方设计得别具匠心。下面就来简要介绍一下。&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_linkedlist">linkedlist&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Redis 底层也有很多地方使用到 linkedlist，并且也是双向链表。&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="title">adlist.h&lt;/div>
&lt;div class="content">
&lt;pre class="rouge highlight">&lt;code data-lang="c">&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">listNode&lt;/span> &lt;span class="p">{&lt;/span>
 &lt;span class="k">struct&lt;/span> &lt;span class="n">listNode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">prev&lt;/span>&lt;span class="p">;&lt;/span>
 &lt;span class="k">struct&lt;/span> &lt;span class="n">listNode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">next&lt;/span>&lt;span class="p">;&lt;/span>
 &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">listNode&lt;/span>&lt;span class="p">;&lt;/span>

&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">listIter&lt;/span> &lt;span class="p">{&lt;/span>
 &lt;span class="n">listNode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">next&lt;/span>&lt;span class="p">;&lt;/span>
 &lt;span class="kt">int&lt;/span> &lt;span class="n">direction&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">listIter&lt;/span>&lt;span class="p">;&lt;/span>

&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">list&lt;/span> &lt;span class="p">{&lt;/span>
 &lt;span class="n">listNode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">head&lt;/span>&lt;span class="p">;&lt;/span>
 &lt;span class="n">listNode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">tail&lt;/span>&lt;span class="p">;&lt;/span>
 &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">dup&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="p">);&lt;/span>
 &lt;span class="kt">void&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">free&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="p">);&lt;/span>
 &lt;span class="kt">int&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">match&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>
 &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">long&lt;/span> &lt;span class="n">len&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="p">;&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Redis 的 linkedlist 实现特点是：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>双向：节点带有前后指针；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>无环：首尾没有相连，所以没有构成环状；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>链表保存了首尾指针；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>多态：可以保存不同类型的值，这里成为泛型也许更符合 Java 中的语义。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>Redis 在 2014 年实现了 &lt;a href="#quicklist">quicklist&lt;/a>，并使用 quicklist 代替了 linkedlist。所以，现在 linkedlist 几乎已经是废弃状态。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_ziplist">ziplist&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Redis 官方在 ziplist.c 文件的注释中对 ziplist 进行了定义：&lt;/p>
&lt;/div>
&lt;div class="quoteblock">
&lt;blockquote>
&lt;div class="paragraph">
&lt;p>The ziplist is a specially encoded dually linked list that is designed
to be very memory efficient. It stores both strings and integer values,
where integers are encoded as actual integers instead of a series of
characters. It allows push and pop operations on either side of the list
in O(1) time. However, because every operation requires a reallocation of
the memory used by the ziplist, the actual complexity is related to the
amount of memory used by the ziplist.&lt;/p>
&lt;/div></description></item><item><title>题解：找到二叉搜索树中两个错误的节点</title><link>https://www.diguage.com/post/find-two-error-node-in-binary-search-tree/</link><pubDate>Sun, 21 Jun 2020 17:57:19 +0800</pubDate><guid>https://www.diguage.com/post/find-two-error-node-in-binary-search-tree/</guid><description>&lt;div class="sect1">
&lt;h2 id="_题目描述">题目描述&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>一棵二叉树原本是二叉搜索树，但是其中有两个节点调换了位置，使得这棵二叉树不再是二叉搜索树，请按升序输出这两个错误节点的值。(每个节点的值各不相同)&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_思路分析">思路分析&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>一棵二叉搜索树，如果是中序遍历，那么，其序列正好是一个升序序列。如果序列中间出现了降序，那么就是树中错误的节点。这里有两种情况需要考虑：&lt;/p>
&lt;/div>
&lt;div class="olist arabic">
&lt;ol class="arabic">
&lt;li>
&lt;p>如果两个节点正好相邻，那么降序的两个节点就是题目要求的节点。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果两个节点不相邻，就会出现两次降序。很容易想到，“大”的元素跑前面，“小”的元素跑后面。在进行比较的时候，第一个降序时，前面大的元素是错误节点；第二次降序时，则是后面小的元素是错误节点。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
&lt;div class="paragraph">
&lt;p>有了上面的分析，就可以写代码了。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_解题代码">解题代码&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>中序遍历，可以用栈，也可以使用 Morris 遍历。前面正好学习了一下 Morris（详情请看： &lt;a href="https://www.diguage.com/post/morris-tree-traversal/" target="_blank" rel="noopener">神奇的 Morris 树遍历&lt;/a>），借此机会练练手：&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="rouge highlight nowrap">&lt;code data-lang="java">&lt;span class="cm">/**
 * 基于 Morris 的中根遍历
 *
 * @author D瓜哥 · &lt;a href="https://www.diguage.com" target="_blank">https://www.diguage.com&lt;/a>
 */&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="nc">TreeNode&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="nf">getErrs&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="nc">TreeNode&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="nc">TreeNode&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nc">TreeNode&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="o">];&lt;/span>
 &lt;span class="nc">TreeNode&lt;/span> &lt;span class="n">curr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">head&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="nc">TreeNode&lt;/span> &lt;span class="n">mostRight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="nc">TreeNode&lt;/span> &lt;span class="n">prior&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">curr&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">mostRight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">curr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">mostRight&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">while&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">mostRight&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">mostRight&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">curr&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">mostRight&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mostRight&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">mostRight&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">mostRight&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">curr&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="n">curr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">curr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="k">continue&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">mostRight&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">prior&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">prior&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">val&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">curr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">val&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">result&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">curr&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="n">result&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">prior&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">{&lt;/span>
 &lt;span class="n">result&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">curr&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="n">prior&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">curr&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="n">curr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">curr&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">;&lt;/span>
 &lt;span class="o">}&lt;/span>
 &lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>得益于 Morris 的优秀本质，这个解法的时间复杂度是： O(n)，空间复杂度是： O(1)。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div></description></item><item><title>负载均衡算法及实践</title><link>https://www.diguage.com/post/load-balancing-algorithm/</link><pubDate>Fri, 15 May 2020 11:37:25 +0800</pubDate><guid>https://www.diguage.com/post/load-balancing-algorithm/</guid><description>&lt;div class="paragraph">
&lt;p>前几天在看一个资料时，看到关于负载均衡算法的介绍。最近也在研究 Spring Cloud 和 Apache Dubbo 等微服务框架。正好负载均衡是微服务框架中一个很重要的知识点。就动手做个整理和总结。方便后续学习。&lt;/p>
&lt;/div>
&lt;div class="sidebarblock">
&lt;div class="content">
&lt;div class="paragraph">
&lt;p>听朋友建议，这篇文章还可以在算法对比，客户端负载均衡与服务端负载均衡区分等两方面做些补充。这些内容后续再补充加入进来。&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_常见的负载均衡算法">常见的负载均衡算法&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="sect2">
&lt;h3 id="round-robin">轮询(Round Robin)法&lt;/h3>
&lt;div class="paragraph">
&lt;p>轮询选择指的是从已有的后端节点列表中按顺序依次选择一个节点出来提供服务。&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/load-balancing-algorithm/round-robin.png" alt="round robin"/>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>优点：试图做到请求转移的绝对均衡。实现简单，使用广泛。&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="weighted-round-robin">加权轮询(Weighted Round Robin)法&lt;/h3>
&lt;div class="paragraph">
&lt;p>实际使用中各个节点往往都带有不同的权重，所以一般都需要实现带权重的轮询选择。 权重高的被选中的次数多，权重低的被选中的次数少。&lt;/p>
&lt;/div>
&lt;div class="imageblock text-center">
&lt;div class="content">
&lt;img src="https://www.diguage.com/images/load-balancing-algorithm/weighted-round_robin.jpg" alt="weighted round robin"/>
&lt;/div>
&lt;/div>
&lt;div class="paragraph">
&lt;p>优点：是 &lt;a href="#round-robin">轮询(Round Robin)法&lt;/a> 改良版。适用于服务器配置不一致时，可以将配置好的服务器多干活，配置差的服务器少干活以使机器的负载达到相同的水平。&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="static-round-robin">静态轮询(Static Round Robin)法&lt;/h3>
&lt;div class="paragraph">
&lt;p>HAProxy 中实现的一个负载均衡算法。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>没有后台服务器的限制，服务器启动时，修改权重也不会生效。增删服务器时，服务器准备就绪后，会立即加入到服务队列中。&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="random">随机(Random)法&lt;/h3>
&lt;div class="paragraph">
&lt;p>通过随机函数，根据后端服务器列表的大小值来随机选择其中一台进行访问。由概率统计理论可以得知，随着调用量的增大，其实际效果越来越接近于平均分配流量到每一台后端服务器，也就是轮询的效果。&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="weighted-random">加权随机(Weighted Random)法&lt;/h3>
&lt;div class="paragraph">
&lt;p>与加权轮询法类似，加权随机法也是根据后端服务器不同的配置和负载情况来配置不同的权重。不同的是，它是按照权重来随机选择服务器的，而不是顺序。&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="ip-hash">原地址哈希(IP Hashing)法&lt;/h3>
&lt;div class="paragraph">
&lt;p>源地址哈希的思想是获取客户端访问的IP地址值，通过哈希函数计算得到一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是要访问的服务器的序号。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>优点：保证了相同客户端 IP 地址将会被哈希到同一台后端服务器，直到后端服务器列表变更。根据此特性可以在服务消费者与服务提供者之间建立有状态的 Session 会话。&lt;/p>
&lt;/div>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="uri-hash">URI 哈希(URI Hashing)法&lt;/h3>
&lt;div class="paragraph">
&lt;p>HAProxy 中实现的一个负载均衡算法。支持部分 URI（问号之前）和完整 URI 两种模式。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>这个算法可以把同一个 URI 的访问发送到同一台服务器上，以最大程度提高缓存命中率。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>该算法支持两个可选参数 &lt;code>len&lt;/code> 和 &lt;code>depth&lt;/code>，后跟一个正整数。仅在需要基于URI的开头来平衡服务器时，这些选项可能会很有用。 &lt;code>len&lt;/code> 参数指示算法仅应考虑URI开头的许多字符来计算哈希。请注意，将 &lt;code>len&lt;/code> 设置为 &lt;code>1&lt;/code> 几乎没有意义，因为大多数URI都以前导 &lt;code>/&lt;/code> 开头。&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>&lt;code>depth&lt;/code> 参数指示用于计算哈希的最大目录深度。请求中的每个斜杠都计为一个级别。如果同时指定了两个参数，则在达到任意一个参数时都将停止评估。&lt;/p>
&lt;/div></description></item></channel></rss>