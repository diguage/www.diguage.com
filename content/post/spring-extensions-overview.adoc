---
title: "Spring æ‰©å±•ç‚¹æ¦‚è§ˆåŠå®è·µ"
date: 2020-05-26T17:14:20+08:00
draft: false
keywords: ["Java","Spring"]
tags: ["Java","è®¾è®¡","æ¶æ„"]
categories: ["Java","ç¨‹åºè®¾è®¡"]
thumbnail: "images/spring-framework/spring-logo.jpg"

weight: 1

# You can also close(false) or open(true) something for this content.
# P.S. comment can only be closed
# comment: false
# toc: true
---

:source-highlighter: pygments
:pygments-style: monokai
:pygments-linenums-mode: table
:source_attr: indent=0,subs="attributes,verbatim,quotes,macros"

å­¦ä¹  Spring ä»£ç ï¼Œæœ€é‡è¦çš„æ˜¯æŒæ¡ Spring æœ‰å“ªäº›æ‰©å±•ç‚¹ï¼Œå¯ä»¥åˆ©ç”¨è¿™äº›æ‰©å±•ç‚¹å¯¹ Spring åšä»€ä¹ˆæ‰©å±•æ“ä½œã€‚è¯´å¾—æ›´å…·ä½“ä¸€ç‚¹ï¼Œå¦‚æœè‡ªå·±å¼€å‘ä¸€ä¸ªæ¡†æ¶ï¼Œå¦‚ä½•ä¸ Spring è¿›è¡Œæ•´åˆï¼Œå¦‚æœå¯¹ Spring çš„æ‰©å±•ç‚¹æœ‰ä¸€ä¸ªæ¯”è¾ƒæ¸…æ™°çš„è®¤è¯†ï¼ŒåŠ¿å¿…ä¼šäº‹åŠåŠŸå€ã€‚

== `@Import`

å…ˆæ¥çœ‹ä¸€ä¸‹ `@Import` æ³¨è§£çš„å®šä¹‰ï¼š

[source,java,{source_attr}]
----
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Import {

  /**
   * {@link Configuration @Configuration}, {@link ImportSelector},
   * {@link ImportBeanDefinitionRegistrar}, or regular component classes to import.
   */
  Class<?>[] value();

}
----

ä»å£°æ˜å¯ä»¥çœ‹å‡ºï¼Œä½¿ç”¨æ—¶ï¼Œåªéœ€è¦æŒ‡å®š `Class` å®ä¾‹å³å¯ï¼›ä»æ–¹æ³•çš„æ–‡æ¡£ä¸­å¯ä»¥çœ‹å‡ºï¼Œ`Class` å®ä¾‹å¯ä»¥åˆ†ä¸ºä¸‰ç§ï¼š`ImportSelector`ã€`ImportBeanDefinitionRegistrar` å’Œå¸¸è§„ç»„ä»¶ç±»ã€‚ç¤ºä¾‹å¦‚ä¸‹ï¼š

[source,java,{source_attr}]
----
@Configuration
@Import(LogImportSelector.class)
public static class Config {
}
----

åœ¨ `org.springframework.context.annotation.ConfigurationClassParser#processImports` æ–¹æ³•ä¸­ï¼Œé›†ä¸­äº†å¯¹ `@Import` æ³¨è§£çš„å¤„ç†ã€‚ä»ä»£ç å¯ä»¥éå¸¸æ¸…æ™°åœ°çœ‹å‡ºï¼Œåˆ†äº†ä¸‰ç§æƒ…å†µè¿›è¡Œå¤„ç†ï¼š

. `ImportSelector`
. `ImportBeanDefinitionRegistrar`
. å¸¸è§„ç»„ä»¶ `Class`

ä¸‹é¢åˆ†åˆ«å¯¹å…¶è¿›è¡Œä»‹ç»ã€‚

=== `ImportSelector`

å…ˆæ¥çœ‹ä¸€ä¸‹ `ImportSelector` æ¥å£çš„å®šä¹‰ï¼š

[source,java,{source_attr}]
----
/**
 * Interface to be implemented by types that determine which @{@link Configuration}
 * class(es) should be imported based on a given selection criteria, usually one or
 * more annotation attributes.
 *
 * <p>{@code ImportSelector} implementations are usually processed in the same way
 * as regular {@code @Import} annotations, however, it is also possible to defer
 * selection of imports until all {@code @Configuration} classes have been processed
 * (see {@link DeferredImportSelector} for details).
 *
 * @since 3.1
 * @see DeferredImportSelector
 * @see Import
 * @see ImportBeanDefinitionRegistrar
 * @see Configuration
 */
public interface ImportSelector {

  /**
   * Select and return the names of which class(es) should be imported based on
   * the {@link AnnotationMetadata} of the importing @{@link Configuration} class.
   * @return the class names, or an empty array if none
   */
  String[] selectImports(AnnotationMetadata importingClassMetadata);

  /**
   * Return a predicate for excluding classes from the import candidates, to be
   * transitively applied to all classes found through this selector's imports.
   * <p>If this predicate returns {@code true} for a given fully-qualified
   * class name, said class will not be considered as an imported configuration
   * class, bypassing class file loading as well as metadata introspection.
   * @return the filter predicate for fully-qualified candidate class names
   * of transitively imported configuration classes, or {@code null} if none
   * @since 5.2.4
   */
  @Nullable
  default Predicate<String> getExclusionFilter() {
    return null;
  }

}
----

ä»æ¥å£æ–‡æ¡£ä¸­å°±å¯ä»¥çœ‹å‡ºï¼Œä½¿ç”¨ `String[] selectImports(AnnotationMetadata importingClassMetadata)` æ–¹æ³•ï¼Œè¿”å›æ‰€éœ€è¦å¼•å…¥çš„ç±»å…¨é™å®šåå³å¯ã€‚å®ä¾‹å¦‚ä¸‹ï¼š

[source,java,{source_attr}]
----
public class LogImportSelector implements ImportSelector {
  @Override
  public String[] selectImports(AnnotationMetadata importingClassMetadata) {
    return new String[]{
        UserDao.class.getName(),
        UserService.class.getName(),
        ProtoService.class.getName()
    };
  }
}
----

=== `ImportBeanDefinitionRegistrar`

å…ˆæ¥çœ‹ä¸€ä¸‹ `ImportBeanDefinitionRegistrar` æ¥å£çš„å®šä¹‰ï¼š

[source,java,{source_attr}]
----
/**
 * Interface to be implemented by types that register additional bean definitions when
 * processing @{@link Configuration} classes. Useful when operating at the bean definition
 * level (as opposed to {@code @Bean} method/instance level) is desired or necessary.
 *
 * <p>Along with {@code @Configuration} and {@link ImportSelector}, classes of this type
 * may be provided to the @{@link Import} annotation (or may also be returned from an
 * {@code ImportSelector}).
 *
 * <p>See implementations and associated unit tests for usage examples.
 *
 * @since 3.1
 * @see Import
 * @see ImportSelector
 * @see Configuration
 */
public interface ImportBeanDefinitionRegistrar {

  /**
   * Register bean definitions as necessary based on the given annotation metadata of
   * the importing {@code @Configuration} class.
   * <p>Note that {@link BeanDefinitionRegistryPostProcessor} types may <em>not</em> be
   * registered here, due to lifecycle constraints related to {@code @Configuration}
   * class processing.
   * <p>The default implementation delegates to
   * {@link #registerBeanDefinitions(AnnotationMetadata, BeanDefinitionRegistry)}.
   * @param importingClassMetadata annotation metadata of the importing class
   * @param registry current bean definition registry
   * @param importBeanNameGenerator the bean name generator strategy for imported beans:
   * {@link ConfigurationClassPostProcessor#IMPORT_BEAN_NAME_GENERATOR} by default, or a
   * user-provided one if {@link ConfigurationClassPostProcessor#setBeanNameGenerator}
   * has been set. In the latter case, the passed-in strategy will be the same used for
   * component scanning in the containing application context (otherwise, the default
   * component-scan naming strategy is {@link AnnotationBeanNameGenerator#INSTANCE}).
   * @since 5.2
   * @see ConfigurationClassPostProcessor#IMPORT_BEAN_NAME_GENERATOR
   * @see ConfigurationClassPostProcessor#setBeanNameGenerator
   */
  default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry,
      BeanNameGenerator importBeanNameGenerator) {

    registerBeanDefinitions(importingClassMetadata, registry);
  }

  /**
   * Register bean definitions as necessary based on the given annotation metadata of
   * the importing {@code @Configuration} class.
   * <p>Note that {@link BeanDefinitionRegistryPostProcessor} types may <em>not</em> be
   * registered here, due to lifecycle constraints related to {@code @Configuration}
   * class processing.
   * <p>The default implementation is empty.
   * @param importingClassMetadata annotation metadata of the importing class
   * @param registry current bean definition registry
   */
  default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
  }

}
----

è¿™é‡Œä½¿ç”¨åˆ°äº† `BeanDefinitionRegistry` æ¥å£ï¼Œæ¥çœ‹ä¸€ä¸‹è¿™ä¸ªæ¥å£çš„å®šä¹‰ï¼š

[source,java,indent=0]
----
/**
 * Interface for registries that hold bean definitions, for example RootBeanDefinition
 * and ChildBeanDefinition instances. Typically implemented by BeanFactories that
 * internally work with the AbstractBeanDefinition hierarchy.
 *
 * <p>This is the only interface in Spring's bean factory packages that encapsulates
 * <i>registration</i> of bean definitions. The standard BeanFactory interfaces
 * only cover access to a <i>fully configured factory instance</i>.
 *
 * <p>Spring's bean definition readers expect to work on an implementation of this
 * interface. Known implementors within the Spring core are DefaultListableBeanFactory
 * and GenericApplicationContext.
 *
 * @author Juergen Hoeller
 * @since 26.11.2003
 * @see org.springframework.beans.factory.config.BeanDefinition
 * @see AbstractBeanDefinition
 * @see RootBeanDefinition
 * @see ChildBeanDefinition
 * @see DefaultListableBeanFactory
 * @see org.springframework.context.support.GenericApplicationContext
 * @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader
 * @see PropertiesBeanDefinitionReader
 */
public interface BeanDefinitionRegistry extends AliasRegistry {

  /**
   * Register a new bean definition with this registry.
   * Must support RootBeanDefinition and ChildBeanDefinition.
   * @param beanName the name of the bean instance to register
   * @param beanDefinition definition of the bean instance to register
   * @throws BeanDefinitionStoreException if the BeanDefinition is invalid
   * @throws BeanDefinitionOverrideException if there is already a BeanDefinition
   * for the specified bean name and we are not allowed to override it
   * @see GenericBeanDefinition
   * @see RootBeanDefinition
   * @see ChildBeanDefinition
   */
  void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
      throws BeanDefinitionStoreException;

  /**
   * Remove the BeanDefinition for the given name.
   * @param beanName the name of the bean instance to register
   * @throws NoSuchBeanDefinitionException if there is no such bean definition
   */
  void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;

  /**
   * Return the BeanDefinition for the given bean name.
   * @param beanName name of the bean to find a definition for
   * @return the BeanDefinition for the given name (never {@code null})
   * @throws NoSuchBeanDefinitionException if there is no such bean definition
   */
  BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;

  /**
   * Check if this registry contains a bean definition with the given name.
   * @param beanName the name of the bean to look for
   * @return if this registry contains a bean definition with the given name
   */
  boolean containsBeanDefinition(String beanName);

  /**
   * Return the names of all beans defined in this registry.
   * @return the names of all beans defined in this registry,
   * or an empty array if none defined
   */
  String[] getBeanDefinitionNames();

  /**
   * Return the number of beans defined in the registry.
   * @return the number of beans defined in the registry
   */
  int getBeanDefinitionCount();

  /**
   * Determine whether the given bean name is already in use within this registry,
   * i.e. whether there is a local bean or alias registered under this name.
   * @param beanName the name to check
   * @return whether the given bean name is already in use
   */
  boolean isBeanNameInUse(String beanName);

}
----

å¾ˆæ˜æ˜¾ï¼Œå¯ä»¥é€šè¿‡ `registerBeanDefinition(String beanName, BeanDefinition beanDefinition)` æ–¹æ³•ï¼Œå‘å®¹å™¨åœ¨ä¸­æ³¨å…¥æ‰€éœ€è¦çš„ `BeanDefinition`ï¼Œè€Œ `BeanDefinition` æ˜¯å¸¸è§çš„ Bean å®ä¾‹çš„åŸºçŸ³ã€‚ç¤ºä¾‹å¦‚ä¸‹ï¼š

[source,java,{source_attr}]
----
public class LogImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {
  @Override
  public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
                    BeanDefinitionRegistry registry) {
    RootBeanDefinition definition = new RootBeanDefinition(UserService.class);
    registry.registerBeanDefinition(UserService.class.getName(), definition);
  }
}
----

=== å¸¸è§„ç»„ä»¶ `Class`

è¿™æ˜¯æœ€ç®€å•çš„æƒ…å†µï¼Œç›´æ¥ä¸¾ä¾‹ï¼š

[source,java,{source_attr}]
----
@Configuration
@Import(UserService.class)
public static class Config {
}
----

[#bean-definition-registry-post-processor]
== `BeanDefinitionRegistryPostProcessor`

å…ˆæ¥çœ‹ä¸€ä¸‹ `BeanDefinitionRegistryPostProcessor` çš„å®šä¹‰ï¼š

[source,java,{source_attr}]
----
/**
 * Extension to the standard {@link BeanFactoryPostProcessor} SPI, allowing for
 * the registration of further bean definitions <i>before</i> regular
 * BeanFactoryPostProcessor detection kicks in. In particular,
 * BeanDefinitionRegistryPostProcessor may register further bean definitions
 * which in turn define BeanFactoryPostProcessor instances.
 *
 * @author Juergen Hoeller
 * @since 3.0.1
 * @see org.springframework.context.annotation.ConfigurationClassPostProcessor
 */
public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor {

  /**
   * Modify the application context's internal bean definition registry after its
   * standard initialization. All regular bean definitions will have been loaded,
   * but no beans will have been instantiated yet. This allows for adding further
   * bean definitions before the next post-processing phase kicks in.
   * @param registry the bean definition registry used by the application context
   * @throws org.springframework.beans.BeansException in case of errors
   */
  void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException;

}
----

è¿™ä¸ªæ¥å£æ‰©å±•äº†æ ‡å‡†çš„ `BeanFactoryPostProcessor` æ¥å£ï¼Œå…è®¸åœ¨æ™®é€šçš„ `BeanFactoryPostProcessor` æ¥å£å®ç°ç±»æ‰§è¡Œä¹‹å‰æ³¨å†Œæ›´å¤šçš„ `BeanDefinition`ã€‚ç‰¹åˆ«åœ°æ˜¯ï¼Œ`BeanDefinitionRegistryPostProcessor` å¯ä»¥æ³¨å†Œ `BeanFactoryPostProcessor` çš„ `BeanDefinition`ã€‚

`postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)` æ–¹æ³•å¯ä»¥ä¿®æ”¹åœ¨ `BeanDefinitionRegistry` æ¥å£å®ç°ç±»ä¸­æ³¨å†Œçš„ä»»æ„ `BeanDefinition`ï¼Œä¹Ÿå¯ä»¥å¢åŠ å’Œåˆ é™¤ `BeanDefinition`ã€‚åŸå› æ˜¯è¿™ä¸ªæ–¹æ³•æ‰§è¡Œå‰,æ‰€æœ‰å¸¸è§„çš„ `BeanDefinition` å·²ç»è¢«åŠ è½½åˆ° `BeanDefinitionRegistry` æ¥å£å®ç°ç±»ä¸­ï¼Œä½†è¿˜æ²¡æœ‰beanè¢«å®ä¾‹åŒ–ã€‚

å®ä¾‹å¦‚ä¸‹ï¼š

[source,java,{source_attr}]
----
public class LogBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor {
  @Override
  public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {
    System.out.println(getAndIncrement()
        + "LogBeanDefinitionRegistryPostProcessor.postProcessBeanDefinitionRegistry\n");
    RootBeanDefinition beanDefinition = new RootBeanDefinition(LogBeanFactoryPostProcessor.class);
    registry.registerBeanDefinition(beanDefinition.getBeanClassName(), beanDefinition);
  }

  @Override
  public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
    System.out.println(getAndIncrement()
        + "LogBeanDefinitionRegistryPostProcessor.postProcessBeanFactory\n");
  }
}
----

`BeanDefinitionRegistryPostProcessor` åœ¨ Spring å†…éƒ¨çš„ä½¿ç”¨ï¼Œæœ€é‡è¦çš„ç¤ºä¾‹å°±æ˜¯ `ConfigurationClassPostProcessor`ï¼Œè¿™ä¸ªç±»è´Ÿè´£è§£æ `@Import` å’Œ `@Configuration` ç­‰æ³¨è§£ã€‚æ„Ÿå…´è¶£å¯ä»¥è®¤çœŸç ”ç©¶ä¸€ä¸‹è¿™ä¸ªç±»çš„ä»£ç ã€‚


[#bean-factory-post-processor]
== `BeanFactoryPostProcessor`

`BeanFactory` ç”Ÿæˆåï¼Œå¦‚æœæƒ³å¯¹ `BeanFactory` è¿›è¡Œä¸€äº›å¤„ç†ï¼Œè¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿ`BeanFactoryPostProcessor` æ¥å£å°±æ˜¯ç”¨æ¥å¤„ç† `BeanFactory` çš„ã€‚

å…ˆæ¥çœ‹ä¸€ä¸‹æ¥å£å®šä¹‰ï¼š

[source,java,{source_attr}]
----
/**
 * Factory hook that allows for custom modification of an application context's
 * bean definitions, adapting the bean property values of the context's underlying
 * bean factory.
 *
 * <p>Useful for custom config files targeted at system administrators that
 * override bean properties configured in the application context. See
 * {@link PropertyResourceConfigurer} and its concrete implementations for
 * out-of-the-box solutions that address such configuration needs.
 *
 * <p>A {@code BeanFactoryPostProcessor} may interact with and modify bean
 * definitions, but never bean instances. Doing so may cause premature bean
 * instantiation, violating the container and causing unintended side-effects.
 * If bean instance interaction is required, consider implementing
 * {@link BeanPostProcessor} instead.
 *
 * <h3>Registration</h3>
 * <p>An {@code ApplicationContext} auto-detects {@code BeanFactoryPostProcessor}
 * beans in its bean definitions and applies them before any other beans get created.
 * A {@code BeanFactoryPostProcessor} may also be registered programmatically
 * with a {@code ConfigurableApplicationContext}.
 *
 * <h3>Ordering</h3>
 * <p>{@code BeanFactoryPostProcessor} beans that are autodetected in an
 * {@code ApplicationContext} will be ordered according to
 * {@link org.springframework.core.PriorityOrdered} and
 * {@link org.springframework.core.Ordered} semantics. In contrast,
 * {@code BeanFactoryPostProcessor} beans that are registered programmatically
 * with a {@code ConfigurableApplicationContext} will be applied in the order of
 * registration; any ordering semantics expressed through implementing the
 * {@code PriorityOrdered} or {@code Ordered} interface will be ignored for
 * programmatically registered post-processors. Furthermore, the
 * {@link org.springframework.core.annotation.Order @Order} annotation is not
 * taken into account for {@code BeanFactoryPostProcessor} beans.
 *
 * @author Juergen Hoeller
 * @author Sam Brannen
 * @since 06.07.2003
 * @see BeanPostProcessor
 * @see PropertyResourceConfigurer
 */
@FunctionalInterface
public interface BeanFactoryPostProcessor {

  /**
   * Modify the application context's internal bean factory after its standard
   * initialization. All bean definitions will have been loaded, but no beans
   * will have been instantiated yet. This allows for overriding or adding
   * properties even to eager-initializing beans.
   * @param beanFactory the bean factory used by the application context
   * @throws org.springframework.beans.BeansException in case of errors
   */
  void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;

}
----

è‹¥ IoC å®¹å™¨å†…æ·»åŠ äº†å®ç°äº† `BeanFactoryPostProcessor` æ¥å£çš„å®ç°ç±» Beanï¼Œé‚£ä¹ˆåœ¨è¯¥å®¹å™¨ä¸­å®ä¾‹åŒ–ä»»ä½•å…¶ä»– Bean ä¹‹å‰å¯ä»¥å›è°ƒè¯¥ Bean ä¸­çš„ `postPrcessorBeanFactory()` æ–¹æ³•æ¥å¯¹ Bean çš„é…ç½®å…ƒæ•°æ®è¿›è¡Œæ›´æ”¹ï¼Œæ¯”å¦‚è®¾ç½® `init-method`ï¼Œæˆ–è€…å°† `Scope` ä» `SINGLETON` æ”¹ä¸º `PROTOTYPE`ã€‚ç¤ºä¾‹å¦‚ä¸‹ï¼š

[source,java,{source_attr}]
----
public class LogBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
  @Override
  public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
    System.out.println(getAndIncrement()
        + "LogBeanFactoryPostProcessor.postProcessBeanFactory\n");
    System.out.println(Arrays.toString(beanFactory.getBeanDefinitionNames()).replaceAll(",", ",\n"));
    BeanDefinition definition = beanFactory.getBeanDefinition(UserService.class.getName());
    // è®¾ç½® init æ–¹æ³•
    definition.setInitMethodName("init");
  }
}
----

åœ¨ä»£ç  `org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors` ä¸­ï¼Œé›†ä¸­äº†å¯¹ `BeanFactoryPostProcessor` çš„è°ƒç”¨ã€‚è¯¥æ–¹æ³•æŠŠå¤„ç†è¿‡ç¨‹ï¼Œå§”æ‰˜ç»™äº† `org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, java.util.List<BeanFactoryPostProcessor>)` æ–¹æ³•æ¥å¤„ç†ã€‚æ ¹æ®ä»£ç å¯ä»¥æ•´ç†å‡ºå¤„ç†æµç¨‹å¦‚ä¸‹ï¼š

. å¦‚æœ `beanFactory` æ˜¯ä¸€ä¸ª `BeanDefinitionRegistry` å®ä¾‹ï¼Œåˆ™ï¼š
.. é¦–å…ˆå¤„ç†å‚æ•°ä¼ è¿‡æ¥çš„ `List<BeanFactoryPostProcessor> beanFactoryPostProcessors` å¯¹è±¡
... å¦‚æœ `postProcessor` æ˜¯ `BeanDefinitionRegistryPostProcessor` å®ç°ç±»ï¼Œåˆ™ç›´æ¥è°ƒç”¨ `postProcessBeanDefinitionRegistry`ï¼Œç„¶ååŠ å…¥åˆ° `List<BeanDefinitionRegistryPostProcessor> registryProcessors` åˆ—è¡¨ä¸­ï¼›
... å¦‚æœä¸æ˜¯ï¼Œåˆ™åŠ å…¥åˆ° `List<BeanFactoryPostProcessor> regularPostProcessors` åˆ—è¡¨ä¸­ï¼›
.. ä» `BeanFactory` ä¸­é€šè¿‡ `beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false)` æ–¹æ³•è·å– `BeanDefinitionRegistryPostProcessor` åç§°åˆ—è¡¨ã€‚ç­›é€‰å‡ºå®ç°äº† `PriorityOrdered` æ¥å£çš„å®ä¾‹ï¼Œç„¶åæ’åºå†é€ä¸€è°ƒç”¨ `postProcessBeanDefinitionRegistry` æ–¹æ³•ã€‚æœ€åï¼ŒåŠ å…¥åˆ° `List<BeanDefinitionRegistryPostProcessor> registryProcessors` åˆ—è¡¨ä¸­ã€‚
.. ä» `BeanFactory` ä¸­é€šè¿‡ `beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false)` æ–¹æ³•è·å– `BeanDefinitionRegistryPostProcessor` åç§°åˆ—è¡¨ã€‚ç­›é€‰å‡ºå®ç°äº† `Ordered` æ¥å£çš„å®ä¾‹ï¼Œç„¶åæ’åºå†é€ä¸€è°ƒç”¨ `postProcessBeanDefinitionRegistry` æ–¹æ³•ã€‚æœ€åï¼ŒåŠ å…¥åˆ° `List<BeanDefinitionRegistryPostProcessor> registryProcessors` åˆ—è¡¨ä¸­ã€‚(æ³¨æ„ï¼šä¸Šä¸€æ­¥å·²ç»è°ƒç”¨è¿‡çš„åˆ™ä¸å†é‡å¤è°ƒç”¨ã€‚)
.. ä» `BeanFactory` ä¸­é€šè¿‡ `beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false)` æ–¹æ³•è·å– `BeanDefinitionRegistryPostProcessor` åç§°åˆ—è¡¨ã€‚å‰”é™¤æ‰å‰ä¸¤æ­¥è°ƒç”¨è¿‡çš„ç±»ï¼Œæ’åºå†é€ä¸€è°ƒç”¨ `postProcessBeanDefinitionRegistry` æ–¹æ³•ã€‚æœ€åï¼ŒåŠ å…¥åˆ° `List<BeanDefinitionRegistryPostProcessor> registryProcessors` åˆ—è¡¨ä¸­ã€‚è¦å¼ºè°ƒçš„ä¸€ç‚¹æ˜¯ï¼šè¿™é‡Œæ˜¯é€šè¿‡ä¸€ä¸ªå¾ªç¯æ¥åå¤æ‰§è¡Œè¿™ä¸€æ­¥ï¼ŒDç“œå“¥è®¤ä¸ºæ˜¯åœ¨è°ƒç”¨ `postProcessBeanDefinitionRegistry` æ–¹æ³•ä¸­ï¼Œæœ‰ä¼šå‚æ•°æ–°æ³¨å†Œçš„ `BeanDefinitionRegistryPostProcessor`ï¼Œæ‰€ä»¥éœ€è¦åå¤è°ƒç”¨ã€‚å¤§å®¶å¦‚æœæœ‰ä¸åŒè§è§£ï¼Œä¹Ÿæ¬¢è¿ç•™è¨€è®¨è®ºã€‚
.. è°ƒç”¨ `BeanDefinitionRegistryPostProcessor` å¯¹è±¡çš„ `postProcessBeanFactory` æ–¹æ³•ï¼›
.. è°ƒç”¨ `BeanFactoryPostProcessor` å¯¹è±¡çš„ `postProcessBeanFactory` æ–¹æ³•ï¼›
. å¦‚æœ `beanFactory` ä¸æ˜¯ `BeanDefinitionRegistry` å®ä¾‹ï¼Œåˆ™ç›´æ¥è°ƒç”¨ `BeanFactoryPostProcessor` å¯¹è±¡çš„ `postProcessBeanFactory` æ–¹æ³•ï¼›
. ä» `BeanFactory` ä¸­é€šè¿‡ `beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false)` æ–¹æ³•è·å– `BeanFactoryPostProcessor` åç§°åˆ—è¡¨ã€‚å°†å…¶åˆ†ä¸ºï¼š
.. å®ç° `PriorityOrdered` æ¥å£çš„å®ä¾‹
.. å®ç° `Ordered` æ¥å£çš„å®ä¾‹
.. æœªæ’åºçš„å®ä¾‹
+
æŒ‰ç…§è¿™ä¸ªé¡ºåºï¼Œæ’é™¤å·²ç»å¤„ç†è¿‡çš„å®ä¾‹ï¼Œå†åˆ†ç±»ï¼Œç„¶åæ’åºå†è·Ÿç€è¿™ä¸ªé¡ºåºä¾æ¬¡é€ä¸€è°ƒç”¨ `BeanFactoryPostProcessor` å¯¹è±¡çš„ `postProcessBeanFactory` æ–¹æ³•ï¼›
+
. æœ€åï¼Œå‘ `BeanFactory` æ³¨å†Œ `ApplicationListenerDetector` å®ä¾‹ã€‚


== `InstantiationAwareBeanPostProcessor`

æ³¨æ„åŒºåˆ† *`Instantiation`* å’Œ *`Initialization`*ã€‚

* *`Instantiation`* -- å®ä¾‹åŒ–ï¼Œåœ¨å®ä¾‹åŒ–ä¹‹å‰è¿˜æ²¡æœ‰ç”Ÿæˆå¯¹è±¡ã€‚
* *`Initialization`* -- åˆå§‹åŒ–ï¼Œå¯¹è±¡å·²ç»ç”Ÿæˆï¼Œéœ€è¦å¯¹å…¶åšè¿›ä¸€æ­¥çš„å¤„ç†ï¼Œæ¯”å¦‚èµ‹å€¼ç­‰ã€‚

[#factory-bean]
== `FactoryBean`

åœ¨å¯¹è±¡ç”Ÿæˆä¸Šï¼Œæœ‰æ—¶ä¹Ÿè®¸éœ€è¦åšäº›ç‰¹æ®Šå¤„ç†ã€‚æ¯”å¦‚ï¼Œåˆ›å»ºå¯¹è±¡è¿‡ç¨‹æ¯”è¾ƒç¹çï¼Œå¸Œæœ›å¯ä»¥é€šè¿‡å®ç° `FactoryBean` æ¥å°è£…åˆå§‹åŒ–è¿‡ç¨‹ã€‚

åœ¨ Spring å®˜æ–¹æ–‡æ¡£ https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-extension-factorybean[Core Technologies: Customizing Instantiation Logic with a `FactoryBean`^] ä¹Ÿæœ‰è¿›ä¸€æ­¥çš„è¯´æ˜ã€‚

ç›®å‰ï¼ŒSpring æºç ä¸­ï¼Œ`FactoryBean` çš„å®ç°ç±»å°±æœ‰äº”åå¤šä¸ªï¼Œéšä¾¿ä¸¾å‡ ä¸ªæ —å­ğŸŒ°ï¼š

* `org.springframework.http.converter.json.GsonFactoryBean`
* `org.springframework.cache.jcache.JCacheManagerFactoryBean`
* `org.springframework.aop.framework.ProxyFactoryBean`

ç¤ºä¾‹å¦‚ä¸‹ï¼š

[source,java,{source_attr}]
----
package com.diguage.truman.context;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.context.annotation.*;

import java.util.Arrays;

/**
 * FactoryBean æµ‹è¯•
 *
 * @author Dç“œå“¥, https://www.diguage.com/
 * @since 2020-05-26 16:34
 */
public class FactoryBeanTest {
  @Test
  public void test() {
    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
    context.register(Config.class);
    context.refresh();

    UserService userService = context.getBean(UserService.class);
    System.out.println(userService.getById(119L));

    System.out.println("-â†“----");
    System.out.println("&userServiceFactoryBean = " // <1>
        + context.getBean("&userServiceFactoryBean"));
    System.out.println(" userServiceFactoryBean = " // <2>
        + context.getBean("userServiceFactoryBean"));
    System.out.println("-â†‘----");

    UserServiceFactoryBean factoryBean = context.getBean(UserServiceFactoryBean.class);
    System.out.println(factoryBean);
    System.out.println(Arrays.toString(context.getBeanDefinitionNames())
        .replaceAll(",", ",\n"));
  }

  @Configuration
  public static class Config {
    @Bean
    public UserServiceFactoryBean userServiceFactoryBean() {
      return new UserServiceFactoryBean();
    }
  }


  public static class UserService {
    public String getById(Long id) {
      return "Name-" + id;
    }
  }

  public static class UserServiceFactoryBean implements FactoryBean<UserService> {
    @Override
    public UserService getObject() throws Exception {
      return new UserService();
    }

    @Override
    public Class<?> getObjectType() {
      return UserService.class;
    }

    @Override
    public boolean isSingleton() {
      return false;
    }
  }
}
----
<1> é€šè¿‡ Bean åç§° `&userServiceFactoryBean` è·å¾—çš„ Bean æ˜¯ `UserServiceFactoryBean` å¯¹è±¡ï¼›
<2> é€šè¿‡ Bean åç§° `userServiceFactoryBean` è·å¾—çš„ Bean æ˜¯ `UserService` å¯¹è±¡ï¼›

æœ‰ä¸€ç‚¹éœ€è¦å¼ºè°ƒä¸€ä¸‹ï¼š`&` ç¬¦å·çš„ä½¿ç”¨éœ€è¦æ³¨æ„ã€‚ä¸Šé¢çš„ä»£ç å’Œç›¸åº”æ³¨é‡Šç»™å‡ºäº†è¯´æ˜ã€‚


== `ObjectFactory`

Dç“œå“¥ä¸ªäººè®¤ä¸º `FactoryBean` å’Œ `ObjectFactory` åŠŸèƒ½æœ‰äº›é‡å ï¼Œéƒ½æ˜¯ä¸ºäº†åˆ›å»ºå¯¹è±¡è€Œè®¾è®¡çš„ã€‚

é€šè¿‡ `ObjectFactory` çš„æ–‡æ¡£ï¼ŒSpring ç»™å‡ºäº†å®˜æ–¹è§£é‡Šï¼š

****
è¿™ä¸ªæ¥å£é€šå¸¸ç”¨äºå°è£…ä¸€ä¸ªé€šç”¨çš„å·¥å‚ï¼Œå®ƒåœ¨æ¯æ¬¡è°ƒç”¨æ—¶è¿”å›æŸä¸ªç›®æ ‡å¯¹è±¡çš„æ–°å®ä¾‹ï¼ˆåŸå‹ï¼‰ã€‚

è¿™ä¸ªæ¥å£ç±»ä¼¼äº `FactoryBean`ï¼Œä½†åè€…çš„å®ç°é€šå¸¸æ˜¯ä½œä¸º `BeanFactory` ä¸­çš„ SPI å®ä¾‹æ¥å®šä¹‰ï¼Œè€Œè¿™ä¸ªç±»çš„å®ç°é€šå¸¸æ˜¯ä½œä¸º API é¦ˆé€ç»™å…¶ä»– Beanï¼ˆé€šè¿‡æ³¨å…¥ï¼‰ã€‚å› æ­¤ï¼ŒgetObject()æ–¹æ³•æœ‰ä¸åŒçš„å¼‚å¸¸å¤„ç†è¡Œä¸ºã€‚
****

Spring åœ¨è§£å†³å¾ªç¯ä¾èµ–æ—¶å’Œåœ¨åˆ›å»º Bean æ—¶ï¼Œéƒ½ä½¿ç”¨åˆ°æ¥å£ã€‚å®ƒä¼¼ä¹å¯ä»¥è„±ç¦» Spring å•ç‹¬ä½¿ç”¨ã€‚

== `ObjectProvider`

`ObjectProvider` ç»§æ‰¿äº† `ObjectFactory` æ¥å£ï¼Œå®ƒæ˜¯åè€…çš„ä¸€ä¸ªå˜ä½“ï¼Œæä¾›äº†æ›´åŠ ä¸°å¯Œçš„æ“ä½œ `T getIfAvailable()`ï¼ŒT getIfUnique() ç­‰ã€‚åœ¨ Spring 5.1 ä»¥åï¼Œæœ‰ç»§æ‰¿äº† `Iterable<T>` æ¥å£ï¼Œæ–¹æ³•ç”¨äºå¾ªç¯æˆ–è€… `forEach` æ–¹æ³•ã€‚åœ¨ `org.springframework.beans.factory.support.DefaultListableBeanFactory` ä¸­æœ‰ä½¿ç”¨ç¤ºä¾‹ã€‚

== `BeanPostProcessor`

`BeanPostProcessor` æ˜¯ Spring ä¸­æœ€æœ€é‡è¦çš„æ‰©å±•ç‚¹ã€‚Spring å†…éƒ¨å¤§é‡çš„åŠŸèƒ½ IoC å’Œ AOP ä¹Ÿéƒ½æ˜¯é€šè¿‡ `BeanPostProcessor` æ¥å®ç°çš„ã€‚å…ˆæ¥çœ‹ä¸€ä¸‹æ¥å£å®šä¹‰ï¼š

[source,java,{source_attr}]
----
/**
 * Factory hook that allows for custom modification of new bean instances &mdash;
 * for example, checking for marker interfaces or wrapping beans with proxies.
 *
 * <p>Typically, post-processors that populate beans via marker interfaces
 * or the like will implement {@link #postProcessBeforeInitialization},
 * while post-processors that wrap beans with proxies will normally
 * implement {@link #postProcessAfterInitialization}.
 *
 * <h3>Registration</h3>
 * <p>An {@code ApplicationContext} can autodetect {@code BeanPostProcessor} beans
 * in its bean definitions and apply those post-processors to any beans subsequently
 * created. A plain {@code BeanFactory} allows for programmatic registration of
 * post-processors, applying them to all beans created through the bean factory.
 *
 * <h3>Ordering</h3>
 * <p>{@code BeanPostProcessor} beans that are autodetected in an
 * {@code ApplicationContext} will be ordered according to
 * {@link org.springframework.core.PriorityOrdered} and
 * {@link org.springframework.core.Ordered} semantics. In contrast,
 * {@code BeanPostProcessor} beans that are registered programmatically with a
 * {@code BeanFactory} will be applied in the order of registration; any ordering
 * semantics expressed through implementing the
 * {@code PriorityOrdered} or {@code Ordered} interface will be ignored for
 * programmatically registered post-processors. Furthermore, the
 * {@link org.springframework.core.annotation.Order @Order} annotation is not
 * taken into account for {@code BeanPostProcessor} beans.
 *
 * @author Juergen Hoeller
 * @author Sam Brannen
 * @since 10.10.2003
 * @see InstantiationAwareBeanPostProcessor
 * @see DestructionAwareBeanPostProcessor
 * @see ConfigurableBeanFactory#addBeanPostProcessor
 * @see BeanFactoryPostProcessor
 */
public interface BeanPostProcessor {

  /**
   * Apply this {@code BeanPostProcessor} to the given new bean instance <i>before</i> any bean
   * initialization callbacks (like InitializingBean's {@code afterPropertiesSet}
   * or a custom init-method). The bean will already be populated with property values.
   * The returned bean instance may be a wrapper around the original.
   * <p>The default implementation returns the given {@code bean} as-is.
   * @param bean the new bean instance
   * @param beanName the name of the bean
   * @return the bean instance to use, either the original or a wrapped one;
   * if {@code null}, no subsequent BeanPostProcessors will be invoked
   * @throws org.springframework.beans.BeansException in case of errors
   * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet
   */
  @Nullable
  default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
    return bean;
  }

  /**
   * Apply this {@code BeanPostProcessor} to the given new bean instance <i>after</i> any bean
   * initialization callbacks (like InitializingBean's {@code afterPropertiesSet}
   * or a custom init-method). The bean will already be populated with property values.
   * The returned bean instance may be a wrapper around the original.
   * <p>In case of a FactoryBean, this callback will be invoked for both the FactoryBean
   * instance and the objects created by the FactoryBean (as of Spring 2.0). The
   * post-processor can decide whether to apply to either the FactoryBean or created
   * objects or both through corresponding {@code bean instanceof FactoryBean} checks.
   * <p>This callback will also be invoked after a short-circuiting triggered by a
   * {@link InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation} method,
   * in contrast to all other {@code BeanPostProcessor} callbacks.
   * <p>The default implementation returns the given {@code bean} as-is.
   * @param bean the new bean instance
   * @param beanName the name of the bean
   * @return the bean instance to use, either the original or a wrapped one;
   * if {@code null}, no subsequent BeanPostProcessors will be invoked
   * @throws org.springframework.beans.BeansException in case of errors
   * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet
   * @see org.springframework.beans.factory.FactoryBean
   */
  @Nullable
  default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
    return bean;
  }

}
----

å…·ä½“åˆ°å®é™…åº”ç”¨ä¸Šï¼ŒSpring å†…ç½®äº†å¤§é‡çš„åº”ç”¨ï¼š

. `ApplicationContextAwareProcessor` -- `Aware` æ¥å£çš„å¤„ç†ã€‚
. `InitDestroyAnnotationBeanPostProcessor` -- `init-method` å’Œ `destroy-method` æ–¹æ³•çš„è°ƒç”¨ã€‚
. `InstantiationAwareBeanPostProcessor` 
. `CommonAnnotationBeanPostProcessor` -- å¸¸ç”¨æ³¨è§£ `@Resource`ã€`@PostConstruct` å’Œ `@PreDestroy` çš„è§£æã€‚
. `AutowiredAnnotationBeanPostProcessor` -- å¸¸ç”¨æ³¨è§£ `@Autowired`ã€`@Value` å’Œ `@Inject` çš„è§£æã€‚
. `BeanValidationPostProcessor` -- å­—æ®µæ ¡éªŒã€‚
. `AbstractAutoProxyCreator` -- ç”Ÿæˆä»£ç†ã€‚

å°‘åºŸè¯ï¼Œç›´æ¥ä¸Šä»£ç ï¼š

[source,java,{source_attr}]
----
public class LogBeanPostProcessor implements BeanPostProcessor {
  @Override
  public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
    if (bean instanceof UserService) {
      System.out.println(getAndIncrement()
          + "LogBeanPostProcessor.postProcessBeforeInitialization");
      System.out.println(bean);
      System.out.println();
    }
    return bean;
  }

  @Override
  public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
    if (bean instanceof UserService) {
      System.out.println(getAndIncrement()
          + "LogBeanPostProcessor.postProcessAfterInitialization");
      System.out.println(bean);
      System.out.println();
    }
    return bean;
  }
}

// å°†å…¶æ³¨å†Œåˆ° BeanFactory ä¸Š
beanFactory.addBeanPostProcessor(new LogBeanPostProcessor());
----

åœ¨ `org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean(String, Object, RootBeanDefinition)` æ–¹æ³•ä¸­ï¼Œé€šè¿‡ `applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName)` å’Œ `applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName)` æ¥åˆ†åˆ«è°ƒç”¨ `postProcessBeforeInitialization` å’Œ `postProcessAfterInitialization` æ–¹æ³•ã€‚

== å„ç§ Aware

æœ‰æ—¶ï¼Œè‡ªå·±å¼€å‘çš„ä»£ç å¯èƒ½éœ€è¦ `ApplicationContext` æˆ–è€… `BeanFactory` ç­‰å®ä¾‹ã€‚åˆ™å¯ä»¥é€šè¿‡å®ç°ç›¸åº”çš„ `Aware` æ¥å£æ¥è·å¾—å¯¹åº”çš„å®ä¾‹ã€‚ç›®å‰æœ‰å¦‚ä¸‹è¿™äº› `Aware` æ¥å£ï¼š

. `ApplicationContextAware`
. `ApplicationEventPublisherAware`
. `BeanClassLoaderAware`
. `BeanFactoryAware`
. `BeanNameAware`
. `BootstrapContextAware`
. `EmbeddedValueResolverAware`
. `EnvironmentAware`
. `ImportAware`
. `LoadTimeWeaverAware`
. `MessageSourceAware`
. `NotificationPublisherAware`
. `ResourceLoaderAware`
. `SchedulerContextAware`
. `ServletConfigAware`
. `ServletContextAware`

åœ¨ä»£ç  `org.springframework.context.support.ApplicationContextAwareProcessor#invokeAwareInterfaces` ä¸­ï¼Œé›†ä¸­å¤„ç†äº† `EnvironmentAware`ã€`EmbeddedValueResolverAware`ã€`ResourceLoaderAware`ã€`ApplicationEventPublisherAware`ã€`MessageSourceAware` å’Œ `ApplicationContextAware` ç­‰å…­ç§ `Aware` æ³¨å…¥ã€‚å€¼å¾—ä¸€æçš„æ˜¯ï¼Œé€šè¿‡ç±»çš„å®šä¹‰å¯ä»¥å¾—çŸ¥ï¼Œ`ApplicationContextAwareProcessor` æ˜¯ä¸€ä¸ª `BeanPostProcessor` å®ç°ç±»ï¼Œé‚£ä¹ˆ `BeanPostProcessor` çš„å¤„ç†æœºåˆ¶ä¹Ÿé€šè¿‡é€‚ç”¨äºè¯¥ç±»ã€‚

=== `ApplicationContextAware`

å¦‚æœæŸä¸ª Bean å®ç°äº† `ApplicationContextAware` æ¥å£ï¼Œé‚£ä¹ˆ Spring å°†ä¼šå°†è¯¥ Bean æ‰€åœ¨çš„ä¸Šä¸‹æ–‡ç¯å¢ƒ `ApplicationContext` ä¼ é€’ç»™ `setApplicationContext()` æ–¹æ³•ï¼Œåœ¨ Bean ç±»ä¸­æ–°å¢ä¸€ä¸ª `ApplicationContext` å­—æ®µç”¨æ¥ä¿å­˜ `ApplicationContext` çš„å€¼ï¼Œå¹¶å®ç° `setApplicationContext()` æ–¹æ³•ã€‚

[source,java,{source_attr}]
----
@Service
public static class UserService implements InitializingBean, ApplicationContextAware {
  @Resource
  UserDao userDao;

  ApplicationContext applicationContext;

  public UserService() {
    System.out.println(getAndIncrement()
        + "UserService()\n");
  }

  @Override
  public void afterPropertiesSet() throws Exception {
    System.out.println(getAndIncrement()
        + "UserService.afterPropertiesSet\n");
  }

  public void init() {
    System.out.println(getAndIncrement()
        + "UserService.init\n");
  }

  String getById(Long id) {
    return userDao.getById(id);
  }

  @Override
  public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
    System.out.println(getAndIncrement()
        + "UserService.setApplicationContext\n");
    this.applicationContext = applicationContext;
  }
}
----

=== `BeanClassLoaderAware`

å¦‚æœæŸä¸ª Bean å®ç°äº† `BeanClassLoaderAware` æ¥å£ï¼Œé‚£ä¹ˆ Spring å°†ä¼šå°†åˆ›å»º Bean çš„ `ClassLoader` ä¼ é€’ç»™ `setBeanClassLoader()` æ–¹æ³•ï¼Œåœ¨ Bean ç±»ä¸­æ–°å¢äº†ä¸€ä¸ª `classLoader` å­—æ®µç”¨æ¥ä¿å­˜ `ClassLoader` çš„å€¼ï¼Œå¹¶å®ç° `setBeanClassLoader()` æ–¹æ³•ã€‚

=== `BeanFactoryAware`

å¦‚æœæŸä¸ª Bean å®ç°äº† `BeanFactoryAware` æ¥å£ï¼Œé‚£ä¹ˆ Spring å°†ä¼šå°†åˆ›å»º Bean çš„ `BeanFactory` ä¼ é€’ç»™ `setBeanFactory()` æ–¹æ³•ï¼Œåœ¨ Bean ç±»ä¸­æ–°å¢äº†ä¸€ä¸ª `beanFactory` å­—æ®µç”¨æ¥ä¿å­˜ `BeanFactory` çš„å€¼ï¼Œå¹¶å®ç° `setBeanFactory()` æ–¹æ³•ã€‚

=== `BeanNameAware`

å¦‚æœæŸä¸ª Bean å®ç°äº† `BeanNameAware` æ¥å£ï¼Œé‚£ä¹ˆ Spring å°†ä¼šå°† Bean å®ä¾‹çš„IDä¼ é€’ç»™ `setBeanName()` æ–¹æ³•ï¼Œåœ¨ Bean ç±»ä¸­æ–°å¢ä¸€ä¸ª `beanName` å­—æ®µï¼Œå¹¶å®ç° `setBeanName()` æ–¹æ³•ã€‚

=== `ServletContextAware`

è¿™ä¸ªæ¥å£åªèƒ½åœ¨ Web é¡¹ç›®ä¸­ä½¿ç”¨ã€‚

å¦‚æœæŸä¸ª Bean å®ç°äº† `ServletContextAware` æ¥å£ï¼Œé‚£ä¹ˆ Spring å°†ä¼šå°† `ServletContext` ä¼ é€’ç»™ `setServletContext()` æ–¹æ³•ï¼Œåœ¨ Bean ç±»ä¸­æ–°å¢ä¸€ä¸ªå­—æ®µï¼Œå¹¶å®ç° `setServletContext()` æ–¹æ³•ã€‚

[#init-method]
== `InitializingBean` ä¸ `init-method`

è®¾ç½® `init-method` æ–¹æ³•å’Œå®ç° `InitializingBean` æ–¹æ³•è¾¾åˆ°çš„æ•ˆæœæ˜¯ä¸€æ ·çš„ã€‚åœ¨ä»£ç  `org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#invokeInitMethods` ä¸­å¯ä»¥çœ‹åˆ°å¾ˆè¯¦ç»†çš„å¤„ç†æµç¨‹ï¼š

. åˆ¤æ–­ Bean æ˜¯å¦æ˜¯ `InitializingBean` å®ä¾‹ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™åšç±»å‹è½¬æ¢ï¼Œç„¶åå†è°ƒç”¨å…¶ `afterPropertiesSet()` æ–¹æ³•ï¼›
. è·å– `AbstractBeanDefinition#initMethodName` å±æ€§ï¼Œç„¶ååˆ¤æ–­æ˜¯å¦åˆæ³•ï¼ˆâ‘ é•¿åº¦å¤§äºé›¶ï¼Œâ‘¡å’Œç¬¬ä¸€æ­¥æ¡ä»¶ä¸é‡å¤ï¼Œâ‘¢ä¸æ˜¯å¤–éƒ¨ç®¡ç†çš„åˆå§‹åŒ–æ–¹æ³•ï¼‰ï¼Œå¦‚æœåˆæ³•ï¼Œåˆ™è°ƒç”¨è¯¥æ–¹æ³•ã€‚

`init-method` æ˜¯é€šè¿‡åå°„æ‰§è¡Œçš„ï¼Œè€Œ `afterPropertiesSet()` æ˜¯ç›´æ¥æ‰§è¡Œçš„ã€‚æ‰€ä»¥ `afterPropertiesSet()` çš„æ‰§è¡Œæ•ˆç‡æ¯” `init-method` è¦é«˜ï¼›ä¸è¿‡ `init-method` æ¶ˆé™¤äº† Bean å¯¹ Spring ä¾èµ–ã€‚

å…¶å®ï¼ŒæŒ‰ç…§ä¸€ç§æ–¹å¼è®¾ç½®å³å¯ã€‚å¦‚æœä¸¤è€…åŒæ—¶å­˜åœ¨ï¼Œåˆ™æŒ‰ç…§ä¸Šè¿°é¡ºåºæ‰§è¡Œã€‚ç¤ºä¾‹è§ä¸Šé¢çš„ `ApplicationContextAware` ç¤ºä¾‹ã€‚

== `DestructionAwareBeanPostProcessor`

èƒ½å¦åœ¨ Bean é”€æ¯ä¹‹å‰ï¼Œå¯¹å…¶åšäº›æ“ä½œå‘¢ï¼Ÿç­”æ¡ˆæ˜¯å¯ä»¥çš„ã€‚

`DestructionAwareBeanPostProcessor` å°±å¯ä»¥å®ç°è¿™ä¸ªåŠŸèƒ½ã€‚å…ˆæ¥çœ‹ä¸€ä¸‹æ¥å£å®šä¹‰ï¼š

[source,java,{source_attr}]
----
/**
 * Subinterface of {@link BeanPostProcessor} that adds a before-destruction callback.
 *
 * <p>The typical usage will be to invoke custom destruction callbacks on
 * specific bean types, matching corresponding initialization callbacks.
 *
 * @author Juergen Hoeller
 * @since 1.0.1
 */
public interface DestructionAwareBeanPostProcessor extends BeanPostProcessor {

  /**
   * Apply this BeanPostProcessor to the given bean instance before its
   * destruction, e.g. invoking custom destruction callbacks.
   * <p>Like DisposableBean's {@code destroy} and a custom destroy method, this
   * callback will only apply to beans which the container fully manages the
   * lifecycle for. This is usually the case for singletons and scoped beans.
   * @param bean the bean instance to be destroyed
   * @param beanName the name of the bean
   * @throws org.springframework.beans.BeansException in case of errors
   * @see org.springframework.beans.factory.DisposableBean#destroy()
   * @see org.springframework.beans.factory.support.AbstractBeanDefinition#setDestroyMethodName(String)
   */
  void postProcessBeforeDestruction(Object bean, String beanName) throws BeansException;

  /**
   * Determine whether the given bean instance requires destruction by this
   * post-processor.
   * <p>The default implementation returns {@code true}. If a pre-5 implementation
   * of {@code DestructionAwareBeanPostProcessor} does not provide a concrete
   * implementation of this method, Spring silently assumes {@code true} as well.
   * @param bean the bean instance to check
   * @return {@code true} if {@link #postProcessBeforeDestruction} is supposed to
   * be called for this bean instance eventually, or {@code false} if not needed
   * @since 4.3
   */
  default boolean requiresDestruction(Object bean) {
    return true;
  }

}
----

ç”±äº `DestructionAwareBeanPostProcessor` æ˜¯ `BeanPostProcessor` å­ç±»ï¼Œç”±æ­¤å¯è§ï¼Œå¯ä»¥åƒæ“ä½œ `BeanPostProcessor` ä¸€æ ·æ¥æ“ä½œ `DestructionAwareBeanPostProcessor` å®ç°ç±»ã€‚ç¤ºä¾‹å¦‚ä¸‹ï¼š


[source,java,{source_attr}]
----
public class LogDestructionAwareBeanPostProcessor implements DestructionAwareBeanPostProcessor {
  @Override
  public void postProcessBeforeDestruction(Object bean, String beanName) throws BeansException {
    System.out.println(getAndIncrement()
        + "LogDestructionAwareBeanPostProcessor.postProcessBeforeDestruction");
    System.out.println(bean.getClass().getName());
  }
}

// å°†å…¶æ³¨å†Œåˆ° BeanFactory ä¸Š
beanFactory.addBeanPostProcessor(new LogDestructionAwareBeanPostProcessor());
----

è°ƒç”¨æ˜¯åœ¨ `org.springframework.beans.factory.support.DisposableBeanAdapter#destroy` æ–¹æ³•ä¸­å®ç°çš„ã€‚

å½“è°ƒç”¨ `beanFactory.destroyBean(bean)` æ¥æ‰‹åŠ¨é”€æ¯ Bean æ—¶ï¼Œå°±ä¼šåˆ›å»º `DisposableBeanAdapter` å®ä¾‹ï¼Œç„¶åè°ƒç”¨ `destroy()` æ¥è§¦å‘è¿™ä¸ªå›è°ƒã€‚ä¹Ÿæ˜¯åœ¨è¿™ä¸ªæ–¹æ³•ä¸­ï¼Œå½“è°ƒç”¨å®Œå›è°ƒåï¼Œå°±ä¼šè§¦å‘ä¸‹é¢çš„ `DisposableBean` å›è°ƒã€‚

== `DisposableBean` ä¸ `destroy-method`

æƒ³è¦è§¦å‘ç”Ÿå‘½å‘¨æœŸå‡½æ•°çš„ `destroy()` æ–¹æ³•ï¼Œå¿…é¡»è¦è¦æ‰‹åŠ¨è°ƒç”¨ `beanFactory.destroyBean(bean)` æ–¹æ³•æ‰è¡Œï¼š

[source,java,{source_attr}]
----
DggDisposableBean dggDisposableBean = applicationContext.getBean(DggDisposableBean.class);
ConfigurableListableBeanFactory beanFactory = ApplicationContext.getBeanFactory();
beanFactory.destroyBean(dggDisposableBean);
----

è°ƒç”¨æ˜¯åœ¨ `org.springframework.beans.factory.support.DisposableBeanAdapter#destroy` æ–¹æ³•ä¸­å®ç°çš„ã€‚

å’Œ <<init-method>> ç±»ä¼¼ï¼Œ`destroy-method` ä¹Ÿæ˜¯åœ¨ `DisposableBean#destroy()` ä¹‹åæ‰§è¡Œçš„ã€‚å¦‚æœåŒæ—¶å­˜åœ¨ï¼Œåªè¦ä¸¤è€…ä¸é‡å¤ï¼Œåˆ™ä¸¤ä¸ªåŒæ—¶éƒ½ä¼šæ‰§è¡Œã€‚

== `ApplicationListener`

åœ¨ `org.springframework.context.support.AbstractApplicationContext#finishRefresh` ä¸­ï¼Œå‘å¸ƒäº† `ContextRefreshedEvent` äº‹ä»¶ã€‚

// == `ReaderEventListener`

== æ•´åˆå®è·µ

ä¸Šé¢ä»‹ç»é‚£ä¹ˆå¤šï¼Œç°åœ¨æ‰¾ä¸€äº›å®é™…é¡¹ç›®å¯¹æ•´åˆè¿‡ç¨‹åšä¸ªåˆ†æã€‚å…ˆæ¥ä¸ªç®€å•çš„ã€‚

=== Hibernate ä¸ Spring æ•´åˆ

åœ¨ Spring å®˜ç½‘ä¸­ï¼Œç»™å‡ºäº†éå¸¸è¯¦ç»†çš„ä»‹ç»ï¼š https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#orm-hibernate[Data Access: Hibernate^]

Hibernate ä¸ Spring æ•´åˆä¸»è¦æ¶‰åŠä¸‹é¢å‡ ä¸ªç±»ï¼š

. `LocalSessionFactoryBean` -- å£°æ˜ Hibernate é…ç½®ä¿¡æ¯ï¼›æˆ–è€…æ³¨å…¥æ•°æ®åº“è¿æ¥æ± å¯¹è±¡ã€‚
. `HibernateTransactionManager` -- è´Ÿè´£å¤„ç† Hibernate çš„äº‹åŠ¡ã€‚

å®ä¾‹ä»£ç ï¼š

[source,xml,{source_attr}]
----
<beans>
  <bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    <property name="driverClassName" value="org.hsqldb.jdbcDriver"/>
    <property name="url" value="jdbc:hsqldb:hsql://localhost:9001"/>
    <property name="username" value="sa"/>
    <property name="password" value=""/>
  </bean>

  <bean id="mySessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
    <property name="dataSource" ref="myDataSource"/>
    <property name="mappingResources">
      <list>
        <value>product.hbm.xml</value>
      </list>
    </property>
    <property name="hibernateProperties">
      <value>
        hibernate.dialect=org.hibernate.dialect.HSQLDialect
      </value>
    </property>
  </bean>

  <bean id="transactionManager"
      class="org.springframework.orm.hibernate5.HibernateTransactionManager">
    <property name="sessionFactory" ref="sessionFactory"/>
  </bean>

  <tx:annotation-driven/>

  <bean id="myProductDao" class="product.ProductDaoImpl">
    <property name="sessionFactory" ref="mySessionFactory"/>
  </bean>

  <bean id="myProductService" class="product.SimpleProductService">
    <property name="productDao" ref="myProductDao"/>
  </bean>
</beans>
----

Spring ä¸ Hibernate çš„æ•´åˆè¿‡ç¨‹è¿˜æ˜¯æ¯”è¾ƒç®€å•çš„ï¼Œå°±æ˜¯æŠŠ Hibernate çš„ç›¸å…³å¯¹è±¡å½“åšæ™®é€šçš„ Bean æ³¨å†Œåˆ° Spring å®¹å™¨ä¸­å³å¯ã€‚

å¦å¤–ï¼Œè¿˜æœ‰ä¸€ç§ `HibernateTemplate` æ–¹å¼ï¼Œå’Œä¸Šé¢çš„æ–¹å¼ç±»ä¼¼ï¼Œå°±ä¸å†èµ˜è¿°ã€‚

åŸè®¡åˆ’è¿˜å‡†å¤‡æ·»åŠ  Spring ä¸ MyBATIS å’Œ Apache Dubbo æ•´åˆåˆ†æã€‚è€ƒè™‘åˆ°æœ¬ç¯‡å†…å®¹å·²ç»éå¸¸é•¿ï¼Œä»”ç»†åˆ†æå®ƒä»¬çš„æ•´åˆè¿‡ç¨‹åˆéœ€è¦å¤§ç¯‡å¹…å†…å®¹ï¼Œæ‰€ä»¥ï¼Œå¦å¤–å•ç‹¬å¼€æ–‡ç« è¿›è¡Œè¯´æ˜ã€‚

== å‚è€ƒèµ„æ–™

. https://www.jianshu.com/p/397c15cbf34a[Springæ‰©å±•ç‚¹æ€»ç»“ - ç®€ä¹¦^]
. https://www.cnblogs.com/v1haoge/p/6106456.html[Springä¸­Beançš„ç”Ÿå‘½å‘¨æœŸåŠå…¶æ‰©å±•ç‚¹ - å”¯ä¸€æµ©å“¥ - åšå®¢å›­^]
. https://leokongwq.github.io/2017/04/02/spring-expandPoint.html[springæ‰©å±•ç‚¹æ•´ç† | æˆ’ä¿®-æ²‰è¿·æŠ€æœ¯çš„å°æ²™å¼¥^]
. https://juejin.im/post/5da995d25188256a49204d7b[springæºç ç³»åˆ—7ï¼šSpringä¸­çš„InstantiationAwareBeanPostProcessorå’ŒBeanPostProcessorçš„åŒºåˆ« - æ˜é‡‘^]
. https://juejin.im/post/5d31b1d2518825276a6f9c70[Dubboæºç ä¹‹Springæ•´åˆ - æ˜é‡‘^]
. https://blog.csdn.net/canot/article/details/50512217[è¯¦ç»†è§£é‡ŠSpringä¸Hibernateçš„æ•´åˆåŸç†_java_ä¸èƒ½è¯´çš„ç§˜å¯†çš„åšå®¢-CSDNåšå®¢^]
. https://blog.csdn.net/u012291108/article/details/51886269[beançš„åŠ è½½ï¼ˆä¹ï¼‰è®°å½•åˆ›å»ºbeançš„ObjectFactory_java_u012291108çš„åšå®¢-CSDNåšå®¢^]
