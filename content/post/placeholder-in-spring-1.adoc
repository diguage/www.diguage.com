---
title: "Spring 对占位符的处理（一）：XML"
date: 2023-05-01T22:15:55+08:00
draft: false
keywords: ["Java", "Spring", "占位符"]
tags: ["Java","设计","架构", "Spring"]
categories: ["程序设计"]
thumbnail: "images/logo/spring.svg"
aliases: "/post/placeholder-in-spring/"

weight: 1
---


最近有小伙伴在开发时，遇到了一个 Spring 占位符，例如 `${token}`， 在不同环境下处理不一致的问题，正好对 Spring 对占位符的处理也有一些不清楚的地方，趁此机会，把 Spring 对占位符的处理机制深入了解一下，方便后续排查问题。

经常阅读D瓜哥博客的朋友可能知道，D瓜哥在 https://www.diguage.com/post/spring-extensions-and-dubbo-1/#spring-plugin[Spring 扩展点实践：整合 Apache Dubbo（一）： Spring 插件机制简介^] 中已经介绍了 Spring 的插件机制。在阅读以下内容之前，建议大家先去阅读一下这篇文章中“Spring 插件机制简介”章节的内容，以便于无缝衔接。

在分析的过程中发现， Spring 对占位符有两种截然不同的出来阶段：① XML 配置文件中的占位符；② Java 源代码中 `@Value` 注解中的占位符。由于内容较多，一篇讲解完有些过长，所以分为上下两篇文章来分别介绍这两种处理过程。

本篇首先来介绍一下对 XML 配置文件中的占位符的处理。

== 示例代码

在正式开始之前，先来看一下示例代码：

.`UserRpc.java`
[source%nowrap,java,{source_attr}]
----
/**
 * @author D瓜哥 · https://www.diguage.com
 * @since 2023-05-02 10:23:49
 */
public static class UserRpc {

  @Value("${user.appId}")
  private String appId;

  // 这里不使用注解，而是使用 XML 配置
  // @Value("${user.token}")
  private String token;
}
----

.`token.properties`
[source%nowrap,bash,{source_attr}]
----
user.appId=dummyAppId
user.token=dummyToken
----


.`spring.xml`
[source%nowrap,xml,{source_attr}]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans.xsd
          http://www.springframework.org/schema/context
          https://www.springframework.org/schema/context/spring-context.xsd">

  <!-- @author D瓜哥 · https://www.diguage.com -->

  <context:annotation-config/>

  <bean id="userRpc"
        class="com.diguage.truman.context.PlaceholderTest.UserRpc">
    <!-- XML 配置的占位符实例在此 -->
    <property name="token" value="${user.token}"/>
  </bean>

  <context:property-placeholder
      location="classpath:com/diguage/truman/context/token.properties"/>

</beans>
----

== 标签处理

根据 https://www.diguage.com/post/spring-extensions-and-dubbo-1/#spring-plugin[Spring 扩展点实践：整合 Apache Dubbo（一）： Spring 插件机制简介^] 的内容可知，看到 `<context:property-placeholder>` 标签就可以知道，应该存在一个 `ContextNamespaceHandler`，并且在里面注册了一个对 `<context:property-placeholder>` 标签做处理的 `BeanDefinitionParser` 实现类。

用上述类名或者关键字在 Spring 源码中搜索，确实可以找到 `org.springframework.context.config.ContextNamespaceHandler`，里面也确实存在一个 `BeanDefinitionParser` 实现类来处理 `<context:property-placeholder>` 标签。代码如下：

.`ContextNamespaceHandler.java`
[source%nowrap,java,{source_attr}]
----
public class ContextNamespaceHandler extends NamespaceHandlerSupport {

  @Override
  public void init() {
    registerBeanDefinitionParser("property-placeholder",
                                 new PropertyPlaceholderBeanDefinitionParser());
    // ...此处省略一万行代码...
  }

}
----

下面来看一下 `PropertyPlaceholderBeanDefinitionParser` 的继承结构：

image::/images/spring-framework/PropertyPlaceholderBeanDefinitionParser.svg[title="PropertyPlaceholderBeanDefinitionParser 继承体系",alt="PropertyPlaceholderBeanDefinitionParser 继承体系",{image_attr}]

从该继承关系图上来看， `PropertyPlaceholderBeanDefinitionParser` 是一个 `BeanDefinitionParser`，将 `<property-placeholder>` 标签处理成一个 `BeanDefinition`，然后后续交给 Spring 来处理。

找到 `org.springframework.beans.factory.xml.AbstractBeanDefinitionParser#parse` 方法，在方法体的代码上打个断点，运行程序，进行单步调试，来了解一下它的内部实现。

单步调试下来，整体的流程图如下：

image::/images/spring-framework/PropertyPlaceholderBeanDefinitionParser-parse.svg[title="PropertyPlaceholderBeanDefinitionParser - parse 时序图",alt="PropertyPlaceholderBeanDefinitionParser - parse 时序图",{image_attr}]

这里选择两个关键点来解释说明一下。

先来说明一下 `getBeanClass` 方法。上文中已经介绍 `BeanDefinitionParser` 的功能就是将 XML 转化成一个 `BeanDefinition`。而 `BeanDefinition` 中最重要的一个属性就是 `beanClass`，这直接决定了该 Bean 的行为。 `PropertyPlaceholderBeanDefinitionParser` 通过重载 `getBeanClass` 方法来返回了该属性： `PropertySourcesPlaceholderConfigurer.class`。 `PropertySourcesPlaceholderConfigurer.class` 能起到什么作用？我们后面再做更详细的介绍。

.`PropertyPlaceholderBeanDefinitionParser`
[source%nowrap,java,{source_attr}]
----
@Override
@SuppressWarnings("deprecation")
protected Class<?> getBeanClass(Element element) {
  // The default value of system-properties-mode is 'ENVIRONMENT'. This value
  // indicates that resolution of placeholders against system properties is a
  // function of the Environment and its current set of PropertySources.
  if (SYSTEM_PROPERTIES_MODE_DEFAULT.equals(element.getAttribute(SYSTEM_PROPERTIES_MODE_ATTRIBUTE))) {
    return PropertySourcesPlaceholderConfigurer.class;
  }

  // The user has explicitly specified a value for system-properties-mode: revert to
  // PropertyPlaceholderConfigurer to ensure backward compatibility with 3.0 and earlier.
  // This is deprecated; to be removed along with PropertyPlaceholderConfigurer itself.
  return org.springframework.beans.factory.config.PropertyPlaceholderConfigurer.class;
}
----

下面来看看关于 `location` 属性的处理。这块处理是在 `AbstractPropertyLoadingBeanDefinitionParser` 的 `doParse` 方法中完成的，具体代码如下：

.`AbstractPropertyLoadingBeanDefinitionParser`
[source%nowrap,java,{source_attr}]
----
@Override
protected void doParse(Element element, ParserContext parserContext,
                       BeanDefinitionBuilder builder) {
  // 读取 location 属性
  String location = element.getAttribute("location");
  if (StringUtils.hasLength(location)) {
    location = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(location);
    String[] locations = StringUtils.commaDelimitedListToStringArray(location);
    builder.addPropertyValue("locations", locations);
  }

  String propertiesRef = element.getAttribute("properties-ref");
  if (StringUtils.hasLength(propertiesRef)) {
    builder.addPropertyReference("properties", propertiesRef);
  }

  String fileEncoding = element.getAttribute("file-encoding");
  if (StringUtils.hasLength(fileEncoding)) {
    builder.addPropertyValue("fileEncoding", fileEncoding);
  }

  String order = element.getAttribute("order");
  if (StringUtils.hasLength(order)) {
    builder.addPropertyValue("order", Integer.valueOf(order));
  }

  builder.addPropertyValue("ignoreResourceNotFound",
      Boolean.valueOf(element.getAttribute("ignore-resource-not-found")));

  builder.addPropertyValue("localOverride",
      Boolean.valueOf(element.getAttribute("local-override")));

  builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
}
----

该方法将读取了 `<context:property-placeholder>` 中配置的 `location` 属性，经过处理后，设置到了 `BeanDefinition` 的属性中，最后由 `PropertySourcesPlaceholderConfigurer` 类的 `locations` 属性承接。从实现上来看， `location` 属性可以配置多个配置文件，中间只需要使用逗号 `,` 分割即可。

这里插一句，在获取 `location` 属性后，后续还执行了一行 `.getEnvironment().resolvePlaceholders(location)`，我们来查看一下 `resolvePlaceholders(location)` 做了什么？

== `location` 属性解析

// TODO 这里需要补充

*`location` 可以使用环境变量信息来做占位符替换。也就是说， `location` 属性也支持使用占位符，在解析时，会从环境变量中查询占位符对应的信息。*

下面来看看 `PropertySourcesPlaceholderConfigurer` 的实现原理。

== 配置文件解析

先来看看 `PropertySourcesPlaceholderConfigurer` 的继承结构：

image::/images/spring-framework/PropertySourcesPlaceholderConfigurer.svg[title="PropertySourcesPlaceholderConfigurer 继承体系",alt="PropertySourcesPlaceholderConfigurer 继承体系",{image_attr}]

从该继承关系图上来看， `PropertySourcesPlaceholderConfigurer` 是一个 `BeanFactoryPostProcessor`。D瓜哥在 https://www.diguage.com/post/spring-startup-process-overview/[Spring 启动流程概述^] 介绍了 Spring 的启动流程，根据该文章内容可知， `BeanFactoryPostProcessor` 的特性可知，它会在 Spring 容器初始化时、Bean 创建之前，完成对部分占位符的处理。

来看一下 `PropertySourcesPlaceholderConfigurer` 对 `postProcessBeanFactory` 的实现：

[#PropertySourcesPlaceholderConfigurer-postProcessBeanFactory]
.`PropertySourcesPlaceholderConfigurer`
[source%nowrap,java,{source_attr}]
----
@Override
public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
  if (this.propertySources == null) {
    this.propertySources = new MutablePropertySources();
    if (this.environment != null) {
      PropertyResolver propertyResolver = this.environment;
      // If the ignoreUnresolvablePlaceholders flag is set to true, we have to create a
      // local PropertyResolver to enforce that setting, since the Environment is most
      // likely not configured with ignoreUnresolvablePlaceholders set to true.
      // See https://github.com/spring-projects/spring-framework/issues/27947
      if (this.ignoreUnresolvablePlaceholders &&
          (this.environment instanceof ConfigurableEnvironment configurableEnvironment)) {
        PropertySourcesPropertyResolver resolver =
            new PropertySourcesPropertyResolver(configurableEnvironment.getPropertySources());
        resolver.setIgnoreUnresolvableNestedPlaceholders(true);
        propertyResolver = resolver;
      }
      PropertyResolver propertyResolverToUse = propertyResolver;
      // 1、先把环境变量中的信息加入到来属性源列表中
      this.propertySources.addLast(
        new PropertySource<>(ENVIRONMENT_PROPERTIES_PROPERTY_SOURCE_NAME, this.environment) {
          @Override
          @Nullable
          public String getProperty(String key) {
            return propertyResolverToUse.getProperty(key);
          }
        }
      );
    }
    try {
      // 2、将配置的多个属性文件合并到一个 PropertySource 对象中，再添加到属性来源列表中
      PropertySource<?> localPropertySource =
          new PropertiesPropertySource(LOCAL_PROPERTIES_PROPERTY_SOURCE_NAME, mergeProperties());
      if (this.localOverride) {
        this.propertySources.addFirst(localPropertySource);
      }
      else {
        this.propertySources.addLast(localPropertySource);
      }
    }
    catch (IOException ex) {
      throw new BeanInitializationException("Could not load properties", ex);
    }
  }

  // 3、处理属性配置
  processProperties(beanFactory, new PropertySourcesPropertyResolver(this.propertySources));
  this.appliedPropertySources = this.propertySources;
}
----

这个方法里，首先，把环境变量中的信息加入到属性来源列表中；然后，将配置的多个属性文件合并到一个 `PropertySource` 对象中，再添加到属性来源列表中；最后，再去处理属性配置。从这个代码可以，环境变量中配置的信息，也是可以作为占位符的数据来源的。

下面来看一下合并属性文件的实现：

.`PropertiesLoaderSupport`
[source%nowrap,java,{source_attr}]
----
/**
 * Return a merged Properties instance containing both the
 * loaded properties and properties set on this FactoryBean.
 */
protected Properties mergeProperties() throws IOException {
  Properties result = new Properties();

  if (this.localOverride) {
    // Load properties from file upfront, to let local properties override.
    // 将 location 中配置的配置文件内容，加载到 result 里
    loadProperties(result);
  }

  if (this.localProperties != null) {
    for (Properties localProp : this.localProperties) {
      CollectionUtils.mergePropertiesIntoMap(localProp, result);
    }
  }

  if (!this.localOverride) {
    // Load properties from file afterwards, to let those properties override.
    // 将 location 中配置的配置文件内容，加载到 result 里
    loadProperties(result);
  }

  return result;
}
----

这个方法里，主要就是把配置文件加载到程序中，然后合并到一个 `Properties` 对象中，最后返回该对象。


接下来，通过 `processProperties` 方法看一下属性的处理过程：

[#PropertySourcesPlaceholderConfigurer-processProperties]
.`PropertySourcesPlaceholderConfigurer.processProperties`
[source%nowrap,java,{source_attr}]
----
/**
 * Visit each bean definition in the given bean factory and attempt to replace ${...} property
 * placeholders with values from the given properties.
 */
protected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess,
    final ConfigurablePropertyResolver propertyResolver) throws BeansException {
  // 设置占位符前缀，默认是 ${
  propertyResolver.setPlaceholderPrefix(this.placeholderPrefix);
  // 设置占位符后缀，默认是 }
  propertyResolver.setPlaceholderSuffix(this.placeholderSuffix);
  // 设置占位符默认值分割符，默认是:
  propertyResolver.setValueSeparator(this.valueSeparator);

  // 构建字符串解析器，底层还是使用上面传过来的 PropertySourcesPropertyResolver 对象
  StringValueResolver valueResolver = strVal -> {
    String resolved = (this.ignoreUnresolvablePlaceholders ?
        propertyResolver.resolvePlaceholders(strVal) :
        propertyResolver.resolveRequiredPlaceholders(strVal));
    if (this.trimValues) {
      resolved = resolved.trim();
    }
    return (resolved.equals(this.nullValue) ? null : resolved);
  };

  // 真正执行处理属性解析
  doProcessProperties(beanFactoryToProcess, valueResolver);
}
----

在这个方法里并没有真正处理属性，而是委托给了 `PlaceholderConfigurerSupport` 类的 `doProcessProperties` 方法。接着往下看：

.`PlaceholderConfigurerSupport`
[source%nowrap,java,{source_attr}]
----
protected void doProcessProperties(ConfigurableListableBeanFactory beanFactoryToProcess,
    StringValueResolver valueResolver) {

  // 注意：这里使用上面传过来的 StringValueResolver 对象创建了 BeanDefinitionVisitor 对象
  // 后续调用 visitor.visitBeanDefinition(bd) 时，就会使用 StringValueResolver 对象来解析其属性。
  BeanDefinitionVisitor visitor = new BeanDefinitionVisitor(valueResolver);

  String[] beanNames = beanFactoryToProcess.getBeanDefinitionNames();
  for (String curName : beanNames) {
    // Check that we're not parsing our own bean definition,
    // to avoid failing on unresolvable placeholders in properties file locations.
    if (!(curName.equals(this.beanName) && beanFactoryToProcess.equals(this.beanFactory))) {
      BeanDefinition bd = beanFactoryToProcess.getBeanDefinition(curName);
      try {
        // 使用 Visitor 模式处理 BeanDefinition 的各种属性
        visitor.visitBeanDefinition(bd);
      }
      catch (Exception ex) {
        throw new BeanDefinitionStoreException(bd.getResourceDescription(), curName, ex.getMessage(), ex);
      }
    }
  }

  // Resolve placeholders in alias target names and aliases as well.
  // 解析别名 alias 中使用的占位符
  beanFactoryToProcess.resolveAliases(valueResolver);

  // Resolve placeholders in embedded values such as annotation attributes.
  // 解析嵌入值中的占位符，例如注释属性。
  // 其实，@Value 等注解中的占位符是并不是在这里解析的。这里仅仅是把 valueResolver
  // 对象加入到 AbstractBeanFactory.embeddedValueResolvers 中，后续通过调用
  // AbstractBeanFactory.resolveEmbeddedValue 方法来解析注解中的占位符
  // 跟踪 resolveEmbeddedValue 方法的调用，就可以发现，占位符的处理是
  // 在 AutowiredAnnotationBeanPostProcessor.postProcessProperties 中完成处理的
  beanFactoryToProcess.addEmbeddedValueResolver(valueResolver);
}
----

在这个方法中，可以看到有三处对占位符的处理：①、使用 `BeanDefinitionVisitor.visitBeanDefinition` 方法处理 `BeanDefinition` 的各种属性；②、解析别名 alias 中使用的占位符；③、解析嵌入值中的占位符，同时将配置信息加入到容器中，以备后用。

通过单步调试可以发现，在第 ① 种方法里， `visitBeanDefinition` 方法中，由于 `BeanDefinition` 还没有属性信息，导致没有处理占位符。又不涉及别名 `alias`，第 ② 种情况可以直接跳过。只剩下第 ③ 种情况了。

其实， `@Value` 等注解中的占位符是并不是在这里解析的。这里仅仅是把 `valueResolver` 对象加入到 `AbstractBeanFactory.embeddedValueResolvers` 中，后续通过调用 `AbstractBeanFactory.resolveEmbeddedValue` 方法来解析注解中的占位符跟踪 `resolveEmbeddedValue` 方法的调用，就可以发现，占位符的处理是在 `AutowiredAnnotationBeanPostProcessor.postProcessProperties` 中，通过调用 `AbstractBeanFactory.resolveEmbeddedValue` 方法来完成处理的。

下面，我们看一下 `@Value("${user.appId}")` 占位符的处理过程。
