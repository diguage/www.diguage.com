---
title: "ZooKeeper 入门"
date: 2020-03-21T00:05:18+08:00
draft: false
tags: ["分布式"]
categories: ["分布式","算法"]

weight: 1
// toc: true

# You can also close(false) or open(true) something for this content.
# P.S. comment can only be closed
# comment: false
# toc: true

---


== ZAB 协议

ZAB 协议全称：Zookeeper Atomic Broadcast（Zookeeper 原子广播协议）。

Zookeeper 是一个为分布式应用提供高效且可靠的分布式协调服务。在解决分布式一致性方面，Zookeeper 并没有使用 Paxos ，而是采用了 ZAB 协议。

ZAB 协议定义：ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持崩溃恢复和原子广播协议。基于该协议，Zookeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间 数据一致性。

image::/images/the-abc-of-zookeeper/save-data-through-leader.webp[]


复制过程类似 2PC，ZAB 只需要 Follower 有一半以上返回 Ack 信息就可以执行提交，大大减小了同步阻塞。也提高了可用性。

=== 选举过程

image::/images/the-abc-of-zookeeper/phase-election.webp[]

=== 发现阶段

followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。这个一阶段的主要目的是发现当前大多数节点接收的最新提议，并且准 leader 生成新的 epoch，让 followers 接受，更新它们的 acceptedEpoch

image::/images/the-abc-of-zookeeper/phase-discovery.webp[]

一个 follower 只会连接一个 leader，如果有一个节点 f 认为另一个 follower p 是 leader，f 在尝试连接 p 时会被拒绝，f 被拒绝之后，就会进入 Phase 0。

=== 消息广播

ZAB 协议的消息广播过程使用的是一个原子广播协议，类似一个二阶段提交过程。对于客户端发送的写请求，全部由 Leader 接收，Leader 将请求封装成一个事务 Proposal，将其发送给所有 Follwer ，然后，根据所有 Follwer 的反馈，如果超过半数成功响应，则执行 commit 操作（先提交自己，再发送 commit 给所有 Follwer）。

注意：ZAB 提交事务并不像 2PC 一样需要全部 follower 都 ACK，只需要得到 quorum （超过半数的节点）的 ACK 就可以了。

整个广播流程分为 3 步骤：

. 将数据都复制到 Follwer 中
+
image::/images/the-abc-of-zookeeper/copy-data-to-follower.webp[]
+
. 等待 Follwer 回应 Ack，最低超过半数即成功
+
image::/images/the-abc-of-zookeeper/wait-for-ack-from-followers.webp[]
+
. 当超过半数成功回应，则执行 commit ，同时提交自己
+
image::/images/the-abc-of-zookeeper/commit-proposal.webp[]

在 Leader 和 Follwer 之间还有一个消息队列，用来解耦他们之间的耦合，避免同步，实现异步解耦。


==== 一些细节

. Leader 在收到客户端请求之后，会将这个请求封装成一个事务，并给这个事务分配一个全局递增的唯一 ID，称为事务ID（ZXID），ZAB 兮协议需要保证事务的顺序，因此必须将每一个事务按照 ZXID 进行先后排序然后处理。
. 在 Leader 和 Follwer 之间还有一个消息队列，用来解耦他们之间的耦合，解除同步阻塞。
. zookeeper集群中为保证任何所有进程能够有序的顺序执行，只能是 Leader 服务器接受写请求，即使是 Follower 服务器接受到客户端的请求，也会转发到 Leader 服务器进行处理。
. 实际上，这是一种简化版本的 2PC，不能解决单点问题。等会我们会讲述 ZAB 如何解决单点问题（即 Leader 崩溃问题）。


=== 崩溃恢复

当 Leader 崩溃，即进入我们开头所说的崩溃恢复模式（崩溃即：Leader 失去与过半 Follwer 的联系）。

* 假设1：Leader 在复制数据给所有 Follwer 之后崩溃，怎么办？ 
* 假设2：Leader 在收到 Ack 并提交了自己，同时发送了部分 commit 出去之后崩溃怎么办？

ZAB 定义了 2 个原则：

. ZAB 协议确保那些已经在 Leader 提交的事务最终会被所有服务器提交。
. ZAB 协议确保丢弃那些只在 Leader 提出/复制，但没有提交的事务。

ZAB 设计了下面这样一个选举算法：能够确保提交已经被 Leader 提交的事务，同时丢弃已经被跳过的事务。

如果让 Leader 选举算法能够保证新选举出来的 Leader 服务器拥有集群总所有机器编号（即 ZXID 最大）的事务，那么就能够保证这个新选举出来的 Leader 一定具有所有已经提交的提案。 而且这么做有一个好处是：可以省去 Leader 服务器检查事务的提交和丢弃工作的这一步操作。

image::/images/the-abc-of-zookeeper/select-leader.webp[]

这样，我们刚刚假设的两个问题便能够解决。假设 1 最终会丢弃调用没有提交的数据，假设 2 最终会同步所有服务器的数据。这个时候，就引出了一个问题，如何同步？

image::/images/the-abc-of-zookeeper/phase-recovery.webp[]

=== 数据同步

当崩溃恢复之后，需要在正式工作之前（接收客户端请求），Leader 服务器首先确认事务是否都已经被过半的 Follwer 提交了，即是否完成了数据同步。目的是为了保持数据一致。

当所有的 Follwer 服务器都成功同步之后，Leader 会将这些服务器加入到可用服务器列表中。

实际上，Leader 服务器处理或丢弃事务都是依赖着 ZXID 的，那么这个 ZXID 如何生成呢？

答：在 ZAB 协议的事务编号 ZXID 设计中，ZXID 是一个 64 位的数字，其中低 32 位可以看作是一个简单的递增的计数器，针对客户端的每一个事务请求，Leader 都会产生一个新的事务 Proposal 并对该计数器进行 + 1 操作。

而高 32 位则代表了 Leader 服务器上取出本地日志中最大事务 Proposal 的 ZXID，并从该 ZXID 中解析出对应的 epoch 值，然后再对这个值加一。

image::/images/the-abc-of-zookeeper/proposal-zxid.webp[]

高 32 位代表了每代 Leader 的唯一性，低 32 代表了每代 Leader 中事务的唯一性。同时，也能让 Follwer 通过高 32 位识别不同的 Leader。简化了数据恢复流程。

基于这样的策略：当 Follower 链接上 Leader 之后，Leader 服务器会根据自己服务器上最后被提交的 ZXID 和 Follower 上的 ZXID 进行比对，比对结果要么回滚，要么和 Leader 同步。


同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。只有当 quorum 都同步完成，准 leader 才会成为真正的 leader。follower 只会接收 zxid 比自己的 lastZxid 大的提议。

image::/images/the-abc-of-zookeeper/phase-synchronization.webp[]



image::/images/the-abc-of-zookeeper/copy-data-to-follower.webp[]


== 参考资料

. https://juejin.im/post/5c989f6e5188252d785f2333[ZooKeeper 一致性协议 ZAB 原理分析！ - 掘金]
. https://juejin.im/post/5b924b0de51d450e9a2de615[看大牛如何分析Zookeeper ZAB 协议 - 掘金]