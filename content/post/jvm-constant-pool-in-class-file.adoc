---
title: "æ·±å…¥ç†è§£å­—èŠ‚ç ï¼ˆ.classï¼‰æ–‡ä»¶ä¸­çš„å¸¸é‡æ± "
date: 2022-10-18T08:38:35+08:00
draft: true
keywords: ["Java","è™šæ‹Ÿæœº"]
tags: ["Java","è™šæ‹Ÿæœº"]
categories: ["ç³»ç»Ÿæ¶æ„","ç¨‹åºè®¾è®¡"]
thumbnail: "images/java/java-class-file-overview.png"

weight: 1
---

æœ€è¿‘åœ¨å­¦ä¹  Java å­—èŠ‚ç çš„ç›¸å…³æŠ€æœ¯ã€‚å­—èŠ‚ç æŠ€æœ¯çš„åŸºç¡€å°±æ˜¯å­—èŠ‚ç ï¼ˆ.classï¼‰æ–‡ä»¶ã€‚æ•´ä½“ç»“æ„å¦‚å¤´å›¾æ‰€ç¤ºã€‚è¿™ä¸¤å¤©ç ”ç©¶äº†ä¸€ä¸‹å…¶ä¸­çš„å¸¸é‡æ± ï¼ˆä»¥ä¸‹ç§°å¸¸é‡æ± ï¼‰ï¼Œç•¥æœ‰æ”¶è·ï¼Œå†™å‡ºæ¥ï¼Œä»¥å¤‡åç”¨ã€‚

åœ¨ https://docs.oracle.com/javase/specs/jvms/se17/html/jvms-4.html#jvms-4.4[Java Virtual Machine Specification / Chapter 4. The class File Format / 4.4. The Constant Pool^] ä¸­å¯¹å¸¸é‡æ± æœ‰äº†è¯¦ç»†çš„æè¿°ã€‚æœ¬æ–‡æ¥ä¸‹æ¥çš„å†…å®¹ä¹Ÿä¸»è¦æ˜¯æ ¹æ®è¿™ä¸ªç« èŠ‚çš„å†…å®¹è€Œæ¥ã€‚

== ä¸“ç”¨æ•°æ®ç±»å‹ç®€ä»‹

åœ¨ JVM è§„èŒƒä¸­ï¼Œä¸ºäº†æè¿°å­—èŠ‚ç æ–‡ä»¶å†…å®¹ï¼Œä¸“é—¨å®šä¹‰äº†ä¸€ç»„ä¸“ç”¨çš„æ•°æ®ç±»å‹ï¼ŒåŒ…æ‹¬ `u1`ã€ `u2`ã€ `u4`ï¼Œåˆ†åˆ«è¡¨ç¤º 1ã€ 2 å’Œ 4 ä¸ªå­—èŠ‚çš„æ— ç¬¦å·æ•°ã€‚

== å¸¸é‡æ± ç®€ä»‹

åœ¨å­—èŠ‚ç æ–‡ä»¶ä¸­ï¼Œå’Œå¸¸é‡æ± ç›¸å…³çš„æœ‰ä¸¤é¡¹ï¼š

[source%nowrap,java,{source_attr}]
----
ClassFile {
    ...
    u2      constant_pool_count;
    cp_info constant_pool[constant_pool_count-1];
    ...
}
----

å…¶ä¸­ï¼Œ `u2 constant_pool_count;` è¡¨ç¤ºå¸¸é‡æ± ä¸­çš„å…ƒç´ ä¸ªæ•°ã€‚è¿™é‡Œæ˜¯ `u2` æ˜¯ä¸€ä¸ª 2 å­—èŠ‚çš„æ— ç¬¦å·æ•°ï¼Œ2^16^ - 1 = 65535ï¼Œæ‰€ä»¥ï¼Œæœ€å¤šå¯ä»¥æœ‰ 65535 ä¸ªå¸¸é‡ã€‚

`cp_info constant_pool[constant_pool_count-1];` åˆ™æ˜¯å…·ä½“çš„å¸¸é‡æ± ã€‚å¸¸é‡æ± æ˜¯ä¸€ä¸ªè¡¨ç»“æ„ï¼ŒåŒ…å«å­—èŠ‚ç æ–‡ä»¶å…¶ä»–ç»“æ„ä¸­ä½¿ç”¨çš„å­—ç¬¦ä¸²å¸¸é‡ï¼Œè¿™é‡Œæœ‰ç±»åã€å­—æ®µåã€æ–¹æ³•åå’Œç¨‹åºä¸­çš„å­—ç¬¦ä¸²å­—é¢é‡ç­‰ç­‰ã€‚

å¸¸é‡æ± ä»¥ `1` ~ `constant_pool_count-1` ä¸ºç´¢å¼•ï¼Œç´¢å¼•å€¼ `0` æ˜¯æ— æ•ˆç´¢å¼•ã€‚ä½†æ˜¯ï¼Œåœ¨å…¶ä»–éœ€è¦å¼•ç”¨å¸¸é‡æ± çš„ç»“æ„ä¸­ï¼Œå¯ä»¥ç”¨ `0` è¡¨ç¤ºä¸ç”¨ä»»ä½•ä¸€ä¸ªå¸¸é‡æ± é¡¹ã€‚

ç»¼ä¸Šï¼Œå¯ä»¥æœ‰ `65535 - 1 = 65534` ä¸ªç´¢å¼•ã€‚

== å¸¸é‡æ± é¡¹é€šç”¨æ ¼å¼

å¸¸é‡æ± ä¸­ï¼Œæ‰€æœ‰çš„é¡¹éƒ½å…·æœ‰å¦‚ä¸‹æ ¼å¼ï¼š

[source%nowrap,java,{source_attr}]
----
cp_info {
    u1 tag;
    u1 info[];
}
----

`u1 tag;` è¡¨ç¤ºå¸¸é‡æ± é¡¹çš„ç±»å‹ï¼Œæ¯ä¸ªå¸¸é‡é¡¹éƒ½å¿…é¡»æœ‰ä¸€ä¸ªç±»å‹å€¼ã€‚æˆªæ­¢åˆ° Java 17 ä¸ºæ­¢ï¼Œä¸€å…±æœ‰å¦‚ä¸‹ 17 ç§ç±»å‹ï¼š

. `CONSTANT_Class_info`
. `CONSTANT_Fieldref_info`
. `CONSTANT_Methodref_info`
. `CONSTANT_InterfaceMethodref_info`
. `CONSTANT_String_info`
. `CONSTANT_Integer_info`
. `CONSTANT_Float_info`
. `CONSTANT_Long_info`
. `CONSTANT_Double_info`
. `CONSTANT_NameAndType_info`
. `CONSTANT_Utf8_info`
. `CONSTANT_MethodHandle_info`
. `CONSTANT_MethodType_info`
. `CONSTANT_Dynamic_info`
. `CONSTANT_InvokeDynamic_info`
. `CONSTANT_Module_info`
. `CONSTANT_Package_info`

`u1 info[];` æ˜¯å„ä¸ªå¸¸é‡æ± é¡¹çš„å†…å®¹ï¼Œè¿™é‡Œçš„å†…å®¹ç”± `tag` ç±»å‹å†³å®šã€‚

== åä¸ƒç§å¸¸é‡æ± é¡¹

ä¸‹é¢æ¥ä¾æ¬¡ä»‹ç»è¿™ 17 ç§å¸¸é‡æ± é¡¹ã€‚

=== `CONSTANT_Class_info`
=== `CONSTANT_Fieldref_info`
=== `CONSTANT_Methodref_info`
=== `CONSTANT_InterfaceMethodref_info`
=== `CONSTANT_String_info`
=== `CONSTANT_Integer_info`
=== `CONSTANT_Float_info`
=== `CONSTANT_Long_info`
=== `CONSTANT_Double_info`
=== `CONSTANT_NameAndType_info`
=== `CONSTANT_Utf8_info`
=== `CONSTANT_MethodHandle_info`
=== `CONSTANT_MethodType_info`
=== `CONSTANT_Dynamic_info`
=== `CONSTANT_InvokeDynamic_info`
=== `CONSTANT_Module_info`
=== `CONSTANT_Package_info`

== Utf8 ç¼–ç è¯¦è°ˆ

.OpenJDK17/src/jdk.compiler/share/classes/com/sun/tools/javac/util/Convert.java
[source%nowrap,java,{source_attr}]
----
    /** Convert `len' bytes from utf8 to characters.
     *  Parameters are as in System.arraycopy
     *  Return first index in `dst' past the last copied char.
     *  @param src        The array holding the bytes to convert.
     *  @param sindex     The start index from which bytes are converted.
     *  @param dst        The array holding the converted characters..
     *  @param dindex     The start index from which converted characters
     *                    are written.
     *  @param len        The maximum number of bytes to convert.
     */
    public static int utf2chars(byte[] src, int sindex,
                                char[] dst, int dindex,
                                int len) {
        int i = sindex;
        int j = dindex;
        int limit = sindex + len;
        while (i < limit) {
            int b = src[i++] & 0xFF;
            if (b >= 0xE0) {
                b = (b & 0x0F) << 12;
                b = b | (src[i++] & 0x3F) << 6;
                b = b | (src[i++] & 0x3F);
            } else if (b >= 0xC0) {
                b = (b & 0x1F) << 6;
                b = b | (src[i++] & 0x3F);
            }
            dst[j++] = (char)b;
        }
        return j;
    }

    /** Return bytes in Utf8 representation as a string.
     *  @param src        The array holding the bytes.
     *  @param sindex     The start index from which bytes are converted.
     *  @param len        The maximum number of bytes to convert.
     */
    public static String utf2string(byte[] src, int sindex, int len) {
        char dst[] = new char[len];
        int len1 = utf2chars(src, sindex, dst, 0, len);
        return new String(dst, 0, len1);
    }

    /** Copy characters in source array to bytes in target array,
     *  converting them to Utf8 representation.
     *  The target array must be large enough to hold the result.
     *  returns first index in `dst' past the last copied byte.
     *  @param src        The array holding the characters to convert.
     *  @param sindex     The start index from which characters are converted.
     *  @param dst        The array holding the converted characters..
     *  @param dindex     The start index from which converted bytes
     *                    are written.
     *  @param len        The maximum number of characters to convert.
     */
    public static int chars2utf(char[] src, int sindex,
                                byte[] dst, int dindex,
                                int len) {
        int j = dindex;
        int limit = sindex + len;
        for (int i = sindex; i < limit; i++) {
            char ch = src[i];
            if (1 <= ch && ch <= 0x7F) {
                dst[j++] = (byte)ch;
            } else if (ch <= 0x7FF) {
                dst[j++] = (byte)(0xC0 | (ch >> 6));
                dst[j++] = (byte)(0x80 | (ch & 0x3F));
            } else {
                dst[j++] = (byte)(0xE0 | (ch >> 12));
                dst[j++] = (byte)(0x80 | ((ch >> 6) & 0x3F));
                dst[j++] = (byte)(0x80 | (ch & 0x3F));
            }
        }
        return j;
    }
----


* ç¬¬ä¸€æ­¥ï¼Œå…ˆå°† Unicode è½¬æ¢æˆ UTF-16 ç¼–ç ï¼›å¯¹äºè¶…è¿‡ BMP çš„å­—ç¬¦ï¼ŒUTF-16 ä¼šå°†å…¶æ‹†åˆ†æˆä¸¤ä¸ªå­—ç¬¦æ¥å¤„ç†ã€‚ç”±äº Java å†…éƒ¨ï¼Œ`char` ç±»å‹çš„æ•°æ®å°±æ˜¯ä½¿ç”¨ UTF-16 ç¼–ç çš„ï¼Œæ‰€ä»¥ï¼Œè¿™ä¸€æ­¥å·²ç»æå‰å®Œæˆï¼Œæ— éœ€å†åšå¤„ç†ã€‚
+
--
æ‹¿ ğŸ˜‚ = `U+1f602` ä¸¾ä¾‹ï¼Œæ¥æ¼”ç¤ºä¸€ä¸‹ä» Unicode è½¬ UTF-16 çš„è¿‡ç¨‹ï¼š

----
U+1f602 - 0x10000 = 0x0f602
0x0f602 = 00 0011 1101, 10 0000 0010

ç¬¬ä¸€ä¸ªå­—ç¬¦
          00 0011 1101
  +             0xD800
----------------------
  =       00 0011 1101
  + 11011000 0000 0000
----------------------
  = 11011000 0011 1101
  = d83d

ç¬¬äºŒä¸ªå­—ç¬¦
          10 0000 0010
  +             0xDC00
----------------------
  =       10 0000 0010
  + 11011100 0000 0000
----------------------
  +  11011110 0000 0010
  = de02
----
--
* ç¬¬äºŒæ­¥ï¼Œ`char` å€¼å¤§äºç­‰äº `0x800` çš„ `char`ï¼Œä¼šå°†å…¶â€œå€¼â€å½“åš Unicode ç„¶åè½¬æ¢æˆâ€œ3ä¸ªå­—èŠ‚çš„UTF-8â€ã€‚å¦‚æœæ˜¯éœ€è¦ä¸¤ä¸ª `char` è¡¨ç¤ºçš„å­—ç¬¦ï¼Œåˆ™å½“åšä¸¤ä¸ª â€œUnicode å€¼â€å¤„ç†ï¼Œåˆ™ ä¼šè½¬æˆä¸¤ä¸ªâ€œ3 ä¸ªå­—èŠ‚çš„ UTF-8â€ï¼Œå°±æ˜¯å…­ä¸ªå­—èŠ‚ã€‚
+
--
æ³¨ï¼šè¿™é‡Œçš„â€œ3ä¸ªå­—èŠ‚çš„UTF-8â€ï¼Œå¹¶ä¸æ˜¯é€šå¸¸è¯´çš„ UTF-8 ç¼–ç ï¼Œ
    åªæ˜¯å€Ÿç”¨äº†â€œ3ä¸ªå­—èŠ‚çš„UTF-8â€çš„ç¼–ç æ ¼å¼ï¼Œå¾’æœ‰å…¶è¡¨è€Œå·²ã€‚

11011000 0011 1101 â†’ 11101101 10100000 10111101 +
11011110 0000 0010 â†’ 11101101 10111000 10000010

è½¬æ¢ç®—æ³•è§ä¸Šé¢çš„â€œUnicode ä¸ UTF-8 çš„è½¬æ¢â€å›¾è¡¨ã€‚
--

`0x10000`~16~ ~ `0x10FFFF`~16~

`0x10000`~16~ = 10000000000000000~2~ â†’ 0xD800DC00~16~ = 11011000 00000000 11011100 00000000~2~

`0x10FFFF`~16~ = 100001111111111111111~2~ â†’ 0xDBFFDFFF~16~ = 11011011 11111111 11011111 11111111~2~

.ä¸‹é™ `0x10000`
----
                  0x10000
  -               0x10000
-------------------------
  =                     0
  = 0000000000 0000000000

ç¬¬ä¸€ä¸ªå­—ç¬¦
               0000000000
  +                0xD800
-------------------------
  =          00 0000 0000
  +    11011000 0000 0000
-------------------------
  =    11011000 0000 0000
  =    0xD800

ç¬¬äºŒä¸ªå­—ç¬¦
               0000000000
  +                0xDC00
-------------------------
  =          00 0000 0000
  +    11011100 0000 0000
-------------------------
  +    11011100 0000 0000
  =    0xDC00
----

.ä¸Šé™ `0x10FFFF`
----
                 0x10FFFF
  -               0x10000
-------------------------
  = 100001111111111111111
  -     10000000000000000
-------------------------
  = 1111111111 1111111111

ç¬¬ä¸€ä¸ªå­—ç¬¦
               1111111111
  +                0xD800
-------------------------
  =          11 1111 1111
  +    11011000 0000 0000
-------------------------
  =    11011011 1111 1111
  =    0xDBFF

ç¬¬äºŒä¸ªå­—ç¬¦
               1111111111
  +                0xDC00
-------------------------
  =          11 1111 1111
  +    11011100 0000 0000
-------------------------
  =    11011111 1111 1111
  =    0xDFFF
----





.Hessian/src/main/java/com/caucho/hessian/io/Hessian2Output.java
[source%nowrap,java,{source_attr}]
----
  /**
   * Prints a string to the stream, encoded as UTF-8
   *
   * @param v the string to print.
   */
  public void printString(String v, int strOffset, int length)
    throws IOException
  {
    int offset = _offset;
    byte []buffer = _buffer;

    for (int i = 0; i < length; i++) {
      if (SIZE <= offset + 16) {
        _offset = offset;
        flushBuffer();
        offset = _offset;
      }

      char ch = v.charAt(i + strOffset);

      if (ch < 0x80)
        buffer[offset++] = (byte) (ch);
      else if (ch < 0x800) {
        buffer[offset++] = (byte) (0xc0 + ((ch >> 6) & 0x1f));
        buffer[offset++] = (byte) (0x80 + (ch & 0x3f));
      }
      else {
        buffer[offset++] = (byte) (0xe0 + ((ch >> 12) & 0xf));
        buffer[offset++] = (byte) (0x80 + ((ch >> 6) & 0x3f));
        buffer[offset++] = (byte) (0x80 + (ch & 0x3f));
      }
    }

    _offset = offset;
  }
----

== æ€»ç»“

æœ€åï¼Œä½¿ç”¨ä¸€å¼ å›¾æ¥æ€»ç»“å¸¸é‡æ± çš„å…³è”å…³ç³»ï¼š

image::/images/java/jvm-constant-pool.svg[alt="å­—èŠ‚ç ï¼ˆ.classï¼‰æ–‡ä»¶ä¸­çš„å¸¸é‡æ± è§£æ",{image_attr}]


== å‚è€ƒèµ„æ–™

. https://docs.oracle.com/javase/specs/jvms/se17/html/jvms-4.html[Java Virtual Machine Specification / Chapter 4. The class File Format^]
. https://blog.lse.epita.fr/2014/04/28/0xcafebabe-java-class-file-format-an-overview.html[0xCAFEBABE ? - java class file format, an overview^]