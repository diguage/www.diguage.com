---
title: "Designing Data-Intensive Applications 之 Storage and Retrieval"
date: 2020-03-06T22:23:45+08:00
draft: false
tags: ["数据库","事务","存储","检索","索引"]
categories: ["存储"]

weight: 1
// toc: true

# You can also close(false) or open(true) something for this content.
# P.S. comment can only be closed
# comment: false
# toc: true

---

一个数据库在最基础的层次上需要完成两件事情：当你把数据交给数据库时，它应当把数据存储起来；而后当你向数据库要数据时，它应当把数据返回给你。

* 日志结构（log-structured） 的存储引擎
* 面向页面（page-oriented） 的存储引擎（例如B树）

== 驱动数据库的数据结构

许多数据库在内部使用了日志（log），也就是一个 仅追加（append-only） 的数据文件。

索引背后的大致思想是，保存一些额外的元数据作为路标，帮助你找到想要的数据。

任何类型的索引通常都会减慢写入速度，因为每次写入数据时都需要更新索引。

存储系统中一个重要的权衡：精心选择的索引加快了读查询的速度，但是每个索引都会拖慢写入速度。

=== 哈希索引

最简单的索引策略就是：保留一个内存中的哈希映射，其中每个键都映射到一个数据文件中的字节偏移量，指明了可以找到对应值的位置

image::/images/ddia/ddia_0301.png[]

只是追加写入一个文件 —— 所以如何避免最终用完磁盘空间？一种好的解决方案是，将日志分为特定大小的段，当日志增长到特定尺寸时关闭当前段文件，并开始写入一个新的段文件。然后，我们就可以对这些段进行压缩（compaction）。

image::/images/ddia/ddia_0302.png[]

由于压缩经常会使得段变得很小（假设在一个段内键被平均重写了好几次），我们也可以在执行压缩的同时将多个段合并在一起。

image::/images/ddia/ddia_0302.png[]

. 文件格式
. 删除记录 -- 增加删除标识。
. 崩溃恢复 -- 使用追加日志。
. 并发控制

哈希表索引也有局限性：

* 散列表必须能放进内存
* 范围查询效率不高。


=== SSTables 和 LSM 树

排序字符串表（Sorted String Table），简称SSTable。

* 要求键值对的序列按键排序。
* 要求每个键只在每个合并的段文件中出现一次（压缩过程已经保证）。

优势：

. 合并段是简单而高效的，即使文件大于可用内存。
+
image::/images/ddia/ddia_0303.png[]
+
. 为了在文件中找到一个特定的键，你不再需要保存内存中所有键的索引。
. 写去磁盘可以对其进行压缩
+
image::/images/ddia/ddia_0304.png[]

. 写入时，将其添加到内存中的平衡树数据结构，称为内存表（memtable）。
. 当内存表大于某个阈值（通常为几兆字节）时，将其作为SSTable文件写入磁盘。
. 为了提供读取请求，首先尝试在内存表中找到关键字，然后在最近的磁盘段中，然后在下一个较旧的段中找到该关键字。
. 有时会在后台运行合并和压缩过程以组合段文件并丢弃覆盖或删除的值。

基于合并和压缩排序文件原理的存储引擎通常被称为LSM存储引擎。

LevelDB，RocksDB，Cassandra，HBase，Lucene

==== 性能优化

为了解决查找不存在的键需要访问全部数据的问题，存储引擎通常使用额外的Bloom过滤器。

最常见的选择是大小分层压缩。 LevelDB和RocksDB使用平坦压缩（LevelDB因此得名），HBase使用大小分层，Cassandra同时支持。

LSM 树的基本思想 —— 保存一系列在后台合并的SSTables —— 简单而有效。


=== B树

image::/images/ddia/ddia_0306.png[]

如果要更新B树中现有键的值，则搜索包含该键的叶页，更改该页中的值，并将该页写回到磁盘（对该页的任何引用保持有效） 。如果你想添加一个新的键，你需要找到其范围包含新键的页面，并将其添加到该页面。如果页面中没有足够的可用空间容纳新键，则将其分成两个半满页面，并更新父页面以解释键范围的新分区。

image::/images/ddia/ddia_0307.png[]

该算法确保树保持平衡：具有 n 个键的B树总是具有 O(logN) 的深度。大多数数据库可以放入一个三到四层的B树，所以你不需要遵追踪多页面引用来找到你正在查找的页面。 （分支因子为 500 的 4KB 页面的四级树可以存储多达 256TB 。）

==== 让B树更可靠

为了使数据库对崩溃具有韧性，B树实现通常会带有一个额外的磁盘数据结构：预写式日志（WAL, write-ahead-log）（也称为重做日志（redo log））。

更新页面的一个额外的复杂情况是，如果多个线程要同时访问B树，则需要仔细的并发控制 —— 否则线程可能会看到树处于不一致的状态。这通常通过使用锁存器（latches）（轻量级锁）保护树的数据结构来完成。

==== B树优化

. 一些数据库（如LMDB）使用写时复制方案，而不是覆盖页面并维护WAL进行崩溃恢复。
. 我们可以通过不存储整个键来节省页面空间，但可以缩小它的大小。
. 额外的指针已添加到树中。例如，每个叶子页面可以在左边和右边具有对其兄弟页面的引用，这允许不跳回父页面就能顺序扫描。
. B树的变体如分形树借用一些日志结构的思想来减少磁盘寻道（而且它们与分形无关）。



=== 比较B树和LSM树

通常LSM树的写入速度更快，而B树的读取速度更快。

==== LSM树的优点


B树索引必须至少两次写入每一段数据：一次写入预先写入日志，一次写入树页面本身（也许再次分页）。


由于反复压缩和合并SSTables，日志结构索引也会重写数据。在数据库的生命周期中写入数据库导致对磁盘的多次写入 —— 被称为写放大（write amplification）。

在写入繁重的应用程序中，性能瓶颈可能是数据库可以写入磁盘的速度。

存储引擎写入磁盘的次数越多，可用磁盘带宽内的每秒写入次数越少。

LSM树可以被压缩得更好，因此经常比B树在磁盘上产生更小的文件。 

更紧凑地表示数据可在可用的I/O带宽内提供更多的读取和写入请求。


==== LSM树的缺点


日志结构存储的缺点是压缩过程有时会干扰正在进行的读写操作。

压缩的另一个问题出现在高写入吞吐量：磁盘的有限写入带宽需要在初始写入（记录和刷新内存表到磁盘）和在后台运行的压缩线程之间共享。

如果写入吞吐量很高，压缩跟不上写入速率，磁盘空间有可能用完。

B树的一个优点是每个键只存在于索引中的一个位置，而日志结构化的存储引擎可能在不同的段中有相同键的多个副本。


没有快速和容易的规则来确定哪种类型的存储引擎对你的场景更好，所以值得进行一些经验上的测试。

=== 其他索引结构


主键（primary key） 索引

二级索引

聚集索引（clustered index） 

非聚集索引（nonclustered index）

包含列的索引（index with included columns）或覆盖索引（covering index）

==== 多列索引

连接索引（concatenated index）

多维索引（multi-dimensional index）

R树

一个有趣的主意是，多维索引不仅可以用于地理位置。



==== 全文搜索和模糊索引

全文搜索引擎通常允许搜索一个单词以扩展为包括该单词的同义词，忽略单词的语法变体，并且搜索在相同文档中彼此靠近的单词的出现，并且支持各种其他功能取决于文本的语言分析。

Lucene为其词典使用了一个类似于SSTable的结构。

==== 在内存中存储一切

随着RAM变得更便宜，每GB的成本价格被侵蚀了。许多数据集不是那么大，所以将它们全部保存在内存中是非常可行的，可能分布在多个机器上。这导致了内存数据库的发展。

内存数据库重新启动时，需要从磁盘或通过网络从副本重新加载其状态（除非使用特殊的硬件）。

写入磁盘也具有操作优势：磁盘上的文件可以很容易地由外部实用程序进行备份，检查和分析。

VoltDB，MemSQL和Oracle TimesTen、RAM Cloud

内存数据库更快的原因在于省去了将内存数据结构编码为磁盘数据结构的开销。

内存数据库的另一个有趣的领域是提供难以用基于磁盘的索引实现的数据模型。例如，Redis。

反缓存（anti-caching） 方法通过在内存不足的情况下将最近最少使用的数据从内存转移到磁盘，并在将来再次访问时将其重新加载到内存中。


== 事务处理还是分析？

根据用户的输入插入或更新记录。由于这些应用程序是交互式的，因此访问模式被称为 在线事务处理（OLTP, OnLine Transaction Processing） 。

在线分析处理（OLAP, OnLine Analytice Processing）

数据仓库（data warehouse）

=== 数据仓库

OLTP系统往往对业务运作至关重要，因而通常会要求 高可用 与 低延迟。

从OLTP数据库中提取数据（使用定期的数据转储或连续的更新流），转换成适合分析的模式，清理并加载到数据仓库中。将数据存入仓库的过程称为“抽取-转换-加载（ETL）”。

image::/images/ddia/ddia_0308.png[]


使用单独的数据仓库，而不是直接查询OLTP系统进行分析的一大优势是数据仓库可针对分析访问模式进行优化。


==== OLTP数据库和数据仓库之间的分歧

星型模式也称为维度建模

雪花模式

在典型的数据仓库中，表格通常非常宽泛：事实表格通常有100列以上，有时甚至有数百列。

== 列存储

在大多数OLTP数据库中，存储都是以面向行的方式进行布局的：表格的一行中的所有值都相邻存储。文档数据库是相似的：整个文档通常存储为一个连续的字节序列。

面向列的存储背后的想法很简单：不要将所有来自一行的值存储在一起，而是将来自每一列的所有值存储在一起。如果每个列存储在一个单独的文件中，查询只需要读取和解析查询中使用的那些列，这可以节省大量的工作。

=== 列压缩

面向列的存储通常很适合压缩。


image::/images/ddia/ddia_0311.png[]

对于需要扫描数百万行的数据仓库查询来说，一个巨大的瓶颈是从磁盘获取数据到内存的带宽。

矢量化处理


=== 列存储中的排序顺序















