---
title: "TCP 三次握手和四次挥手"
date: 2020-08-02T20:57:26+08:00
draft: false
keywords: ["HTTP1","HTTP2","HTTP3","SPDY","三次握手","多路复用","QUIC","TCP","UDP","网络"]
tags: ["TCP","网络","架构","设计"]
categories: ["网络","程序设计","算法"]
thumbnail: "images/tcp/arpanet-1974.svg"

weight: 1
---

:source-highlighter: pygments
:pygments-style: monokai
:pygments-linenums-mode: table
:source_attr: indent=0,subs="attributes,verbatim,quotes"
:image_attr: align=center

传输控制协议（英语：Transmission Control Protocol，缩写：TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。在简化的计算机网络 OSI 模型中，它完成第四层传输层所指定的功能。

毫不夸张地说，TCP 协议是目前整个互联网的基础。它解决了一系列的网络问题。带来的结果，就是协议本身非常复杂。考虑到文章篇幅问题，本文着重说明 TCP 建立连接时的三次握手过程和关闭连接时的四次挥手过程。

== 三次握手

image::/images/tcp/tcp-connection-made-three-way-handshake.png[{image_attr},title="TCP 三次握手",alt="TCP 三次握手"]


. 第一次握手(`SYN=1`, `seq=x`):
+
客户端发送一个 TCP 的 `SYN` 标志位置 `1` 的包，指明客户端打算连接的服务器的端口，以及初始序号  `x`，保存在包头的序列号(`Sequence Number`)字段里。
+
发送完毕后，客户端进入 `SYN_SEND` 状态。
+
. 第二次握手(`SYN=1`、`seq=y`；`ACK=1`、`ACKnum=x+1`):
+
服务器发回确认包(`ACK`)应答。即 `SYN` 标志位和 `ACK` 标志位均为 `1`。服务器端选择自己 `ISN` 序列号，放到包头的序列号(`Sequence Number`)字段里，同时将确认序号(`Acknowledgement Number`)设置为客户的 `ISN` 加 `1`，即 `x+1`。
+
发送完毕后，服务器端进入 `SYN_RCVD` 状态。
+
. 第三次握手(`ACK=1`，`ACKnum=y+1`)
+
客户端再次发送确认包(`ACK`)，SYN 标志位为 `0`，`ACK` 标志位为 `1`，并且把服务器发来 `ISN` 的序号字段+1，放在确定字段中发送给对方，即数据段放写 `y+1`。
+
发送完毕后，客户端进入 `ESTABLISHED` 状态，当服务器端接收到这个包时，也进入 `ESTABLISHED` 状态，TCP 握手结束。

=== SYN Flood 攻击

在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 `SYN_RCVD` 状态。当收到 ACK 后，服务器才能转入 `ESTABLISHED` 状态.

SYN Flood 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送 `SYN` 包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的 `SYN` 包将长时间占用未连接队列，正常的 `SYN` 请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。

SYN Flood 攻击是一种典型的 DoS/DDoS 攻击。

检测 SYN Flood 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN Flood 攻击。在 Linux/Unix 上可以使用系统自带的 `netstats` 命令来检测 SYN Flood 攻击。

防御 SYN Flood 攻击的办法大致有这么几种：

* *延缓TCB分配方法* -- 消耗服务器资源主要是因为当 `SYN` 数据报文一到达，系统立即分配 TCB，从而占用了资源。而 SYN Flood 由于很难建立起正常连接，因此，当正常连接建立起来后再分配 TCB 则可以有效地减轻服务器资源的消耗。常见的方法是使用 Syn Cache 和 Syn Cookie 技术。
* *Syn Cache技术* -- 系统在收到一个 `SYN` 报文时，在一个专用HASH表中保存这种半连接信息，直到收到正确的回应 `ACK` 报文再分配 TCB。这个开销远小于 TCB 的开销。当然还需要保存序列号。
* *使用SYN Proxy防火墙* -- 一种方式是防止墙dqywb连接的有效性后，防火墙才会向内部服务器发起SYN请求。防火墙代服务器发出的SYN ACK包使用的序列号为c, 而真正的服务器回应的序列号为c', 这样，在每个数据报文经过防火墙的时候进行序列号的修改。另一种方式是防火墙确定了连接的安全后，会发出一个safe reset命令，client会进行重新连接，这时出现的syn报文会直接放行。这样不需要修改序列号了。但是，client需要发起两次握手过程，因此建立连接的时间将会延长。

== 四次挥手

image::/images/tcp/tcp-connection-closed-four-way-handshake.png[{image_attr},title="TCP 四次挥手",alt="TCP 四次挥手"]


. 第一次挥手(`FIN=1`，`seq=x`)
+
假设客户端想要关闭连接，客户端发送一个 `FIN` 标志位置为 `1` 的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。
+
发送完毕后，客户端进入 `FIN_WAIT_1` 状态。
+
. 第二次挥手(`ACK=1`，`ACKnum=x+1`)
+
服务器端确认客户端的 `FIN` 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。
+
发送完毕后，服务器端进入 `CLOSE_WAIT` 状态，客户端接收到这个确认包之后，进入 `FIN_WAIT_2` 状态，等待服务器端关闭连接。
+
. 第三次挥手(`FIN=1`，`seq=y`)
+
服务器端准备好关闭连接时，向客户端发送结束连接请求，`FIN` 置为 `1`。
+
发送完毕后，服务器端进入 `LAST_ACK` 状态，等待来自客户端的最后一个 `ACK`。
+
. 第四次挥手(`ACK=1`，`ACKnum=y+1`)
+
客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 `TIME_WAIT` 状态，等待可能出现的要求重传的 `ACK` 包。
+
服务器端接收到这个确认包之后，关闭连接，进入 `CLOSED` 状态。
+
客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 `ACK`，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 `CLOSED` 状态。


== 常见问题答疑

=== 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？

这是因为服务端在 `LISTEN` 状态下，收到建立连接请求的 `SYN` 报文后，把 `ACK` 和 `SYN` 放在一个报文里发送给客户端。

而关闭连接时，当收到对方的 `FIN` 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而 TCP 是一个全双工的协议，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方 `ACK` 和 `FIN` 一般都会分开发送。

=== 为什么 `TIME_WAIT` 状态需要经过 2MSL(最大报文段生存时间)才能返回到 `CLOSE` 状态？

. 为了保证发送的最后一个 `ACK` 报文段能够到达对方。
. 防止“已失效的连接请求报文段”出现在本连接中。在发送完最后一个 `ACK` 报文段后，再经过实践 2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种就得连接请求报文段。

有点累了，先写道这里。后续再来补充问题。

== 小结

综上所述，TCP 的完整状态转换图如下：

image::/images/tcp/tcp-state-diagram.svg[{image_attr},title="TCP 状态图",alt="TCP 状态图"]

从 TCP 中可以学到很多很多东西。比如，如何设计一个流量控制系统？在没有 TCP 支持的情况下，如何确保数据的安全可靠传输？

== 参考资料

. https://hit-alibaba.github.io/interview/basic/network/TCP.html[TCP 协议 · 笔试面试知识整理^]
. https://en.wikipedia.org/wiki/Transmission_Control_Protocol[Transmission Control Protocol - Wikipedia^]
. https://taylor.git-pages.mst.edu/index_files/ComputerNetworking/Content/03-Transport.html[03-Transport^]
. https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE[传输控制协议 - 维基百科，自由的百科全书^]
. https://sites.google.com/site/newmedianewtechnology2019/portfolios/nicole/1-2-homage[1.2 An Homage to ARPAnet: DERPnet - New Media New Technology 2019^]
. https://www.jianshu.com/p/9968b16b607e[图解TCP协议中的三次握手和四次挥手 - 简书^]
. https://zhuanlan.zhihu.com/p/53374516[“三次握手，四次挥手”你真的懂吗？ - 知乎^]